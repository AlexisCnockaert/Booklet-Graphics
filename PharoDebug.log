THERE_BE_DRAGONS_HERE

4 August 2024 10:35:19.499748 am

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 74b785ff-50d8-0d00-86f4-c64e0df24b96 Jun 28 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 74b785ff-50d8-0d00-86f4-c64e0df24b96 Jun 28 2024
v10.3.0 - Commit: ce151716 - Date: 2024-06-28 10:12:41 +0200

Image: Pharo12.0.0SNAPSHOT [Build information: Pharo-12.0.0+SNAPSHOT.build.1526.sha.404d3af7531f656b5c294762c79011c10bea1ef3 (64 Bit)]

ClapMicrodownBookReferenceCheckerCommand(Object)>>halt
	Receiver: a ClapMicrodownBookReferenceCheckerCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		arguments: 	a ClapNamedMatch
		project: 	nil


ClapMicrodownBookReferenceCheckerCommand>>execute
	Receiver: a ClapMicrodownBookReferenceCheckerCommand
	Arguments and temporary variables: 
		file: 	File @ index.md
		checker: 	nil
	Receiver's instance variables: 
		arguments: 	a ClapNamedMatch
		project: 	nil


[ :args |
			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].
			(self with: args) execute ] in ClapMicrodownBookReferenceCheckerCommand class>>commandSpecification
	Receiver: ClapMicrodownBookReferenceCheckerCommand
	Arguments and temporary variables: 
		args: 	a ClapNamedMatch
	Receiver's instance variables: 
		superclass: 	ClapPillarCommand
		methodDict: 	a MethodDictionary(#execute->ClapMicrodownBookReferenceCheckerC[..]
		format: 	65538
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (execution) - 2 selector(s))
		subclasses: 	nil
		name: 	#ClapMicrodownBookReferenceCheckerCommand
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	7449745
		packageTag: 	a PackageTag(Uncategorized)


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :args |
			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].
			(se[..]
	Arguments and temporary variables: 
		anArg: 	a ClapNamedMatch
	Receiver's instance variables: 
		outerContext: 	ClapMicrodownBookReferenceCheckerCommand class>>commandSpecif[..]
		compiledBlock: 	a CompiledBlock: [ :args |
			args at: #helpFlag ifPresent: [..]
		numArgs: 	1
		receiver: 	ClapMicrodownBookReferenceCheckerCommand


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ :args |
			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].
			(se[..]
	Arguments and temporary variables: 
		firstArg: 	a ClapNamedMatch
		secondArg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		outerContext: 	ClapMicrodownBookReferenceCheckerCommand class>>commandSpecif[..]
		compiledBlock: 	a CompiledBlock: [ :args |
			args at: #helpFlag ifPresent: [..]
		numArgs: 	1
		receiver: 	ClapMicrodownBookReferenceCheckerCommand


ClapCommand(ClapParameter)>>valueFor:with:
	Receiver: a ClapCommand(referenceCheck)
	Arguments and temporary variables: 
		aMatch: 	a ClapNamedMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		identifier: 	#referenceCheck
		canonicalName: 	nil
		description: 	'Check the duplicated or unknown references'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help | help val[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #requestedFile[..]
		positionals: 	an OrderedCollection(a ClapPositional(requestedFile))
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help))
		subcommands: 	an OrderedCollection()


[ super valueFor: aMatch with: arg ] in ClapCommand>>valueFor:with:
	Receiver: a ClapCommand(referenceCheck)
	Arguments and temporary variables: 
		aMatch: 	a ClapNamedMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		identifier: 	#referenceCheck
		canonicalName: 	nil
		description: 	'Check the duplicated or unknown references'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help | help val[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #requestedFile[..]
		positionals: 	an OrderedCollection(a ClapPositional(requestedFile))
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help))
		subcommands: 	an OrderedCollection()


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(a ClapWordMatch)
	Arguments and temporary variables: 
		aBlock: 	[ :child | specification subcommands includes: child specification ]
		foundBlock: 	[ :cmdMatch | foundBlock cull: cmdMatch ]
		exceptionBlock: 	[ super valueFor: aMatch with: arg ]
	Receiver's instance variables: 
		array: 	an Array(a ClapWordMatch nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


ClapNamedMatch(ClapCompositeMatch)>>matchedSubcommand:ifNone:
	Receiver: a ClapNamedMatch
	Arguments and temporary variables: 
		foundBlock: 	[ :sub | sub value: arg ]
		noneBlock: 	[ super valueFor: aMatch with: arg ]
	Receiver's instance variables: 
		specification: 	a ClapCommand(referenceCheck)
		parent: 	a ClapCompositeMatch
		startIndex: 	1
		children: 	an OrderedCollection(a ClapWordMatch)
		keyword: 	'referenceCheck'


ClapCommand>>valueFor:with:
	Receiver: a ClapCommand(referenceCheck)
	Arguments and temporary variables: 
		aMatch: 	a ClapNamedMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		identifier: 	#referenceCheck
		canonicalName: 	nil
		description: 	'Check the duplicated or unknown references'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help | help val[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #requestedFile[..]
		positionals: 	an OrderedCollection(a ClapPositional(requestedFile))
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help))
		subcommands: 	an OrderedCollection()


ClapNamedMatch(ClapExpression)>>value:
	Receiver: a ClapNamedMatch
	Arguments and temporary variables: 
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		specification: 	a ClapCommand(referenceCheck)
		parent: 	a ClapCompositeMatch
		startIndex: 	1
		children: 	an OrderedCollection(a ClapWordMatch)
		keyword: 	'referenceCheck'


[ :sub | sub value: arg ] in ClapRoot(ClapCommand)>>valueFor:with:
	Receiver: a ClapRoot(clap)
	Arguments and temporary variables: 
		aMatch: 	a ClapCompositeMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
		sub: 	a ClapNamedMatch
	Receiver's instance variables: 
		identifier: 	#clap
		canonicalName: 	nil
		description: 	'Entry point for commands implemented with Clap'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help |
				help[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #helpCommand->[..]
		positionals: 	an OrderedCollection()
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help) a ClapFlag(save) a ClapFlag(no[..]
		subcommands: 	an OrderedCollection(a ClapCommand(help) a ClapCommand(image) [..]


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :sub | sub value: arg ]
	Arguments and temporary variables: 
		anArg: 	a ClapNamedMatch
	Receiver's instance variables: 
		outerContext: 	ClapRoot(ClapCommand)>>valueFor:with:
		compiledBlock: 	a CompiledBlock: [ :sub | sub value: arg ]
		numArgs: 	1
		receiver: 	a ClapRoot(clap)


[ :cmdMatch | foundBlock cull: cmdMatch ] in ClapCompositeMatch>>matchedSubcommand:ifNone:
	Receiver: a ClapCompositeMatch
	Arguments and temporary variables: 
		foundBlock: 	[ :sub | sub value: arg ]
		noneBlock: 	[ super valueFor: aMatch with: arg ]
		cmdMatch: 	a ClapNamedMatch
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		parent: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
		startIndex: 	1
		children: 	an OrderedCollection(a ClapNamedMatch)


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :cmdMatch | foundBlock cull: cmdMatch ]
	Arguments and temporary variables: 
		anArg: 	a ClapNamedMatch
	Receiver's instance variables: 
		outerContext: 	ClapCompositeMatch>>matchedSubcommand:ifNone:
		compiledBlock: 	a CompiledBlock: [ :cmdMatch | foundBlock cull: cmdMatch ]
		numArgs: 	1
		receiver: 	a ClapCompositeMatch


[ :each |
			(aBlock value: each)
				ifTrue: [ ^ foundBlock cull: each ] ] in OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(a ClapNamedMatch)
	Arguments and temporary variables: 
		aBlock: 	[ :child | specification subcommands includes: child specification ]
		foundBlock: 	[ :cmdMatch | foundBlock cull: cmdMatch ]
		exceptionBlock: 	[ super valueFor: aMatch with: arg ]
		each: 	a ClapNamedMatch
	Receiver's instance variables: 
		array: 	an Array(a ClapNamedMatch nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


OrderedCollection>>do:
	Receiver: an OrderedCollection(a ClapNamedMatch)
	Arguments and temporary variables: 
		aBlock: 	[ :each |
			(aBlock value: each)
				ifTrue: [ ^ foundBlock cull: [..]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a ClapNamedMatch nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(a ClapNamedMatch)
	Arguments and temporary variables: 
		aBlock: 	[ :child | specification subcommands includes: child specification ]
		foundBlock: 	[ :cmdMatch | foundBlock cull: cmdMatch ]
		exceptionBlock: 	[ super valueFor: aMatch with: arg ]
	Receiver's instance variables: 
		array: 	an Array(a ClapNamedMatch nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


ClapCompositeMatch>>matchedSubcommand:ifNone:
	Receiver: a ClapCompositeMatch
	Arguments and temporary variables: 
		foundBlock: 	[ :sub | sub value: arg ]
		noneBlock: 	[ super valueFor: aMatch with: arg ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		parent: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
		startIndex: 	1
		children: 	an OrderedCollection(a ClapNamedMatch)


ClapRoot(ClapCommand)>>valueFor:with:
	Receiver: a ClapRoot(clap)
	Arguments and temporary variables: 
		aMatch: 	a ClapCompositeMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		identifier: 	#clap
		canonicalName: 	nil
		description: 	'Entry point for commands implemented with Clap'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help |
				help[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #helpCommand->[..]
		positionals: 	an OrderedCollection()
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help) a ClapFlag(save) a ClapFlag(no[..]
		subcommands: 	an OrderedCollection(a ClapCommand(help) a ClapCommand(image) [..]


ClapCompositeMatch(ClapExpression)>>value:
	Receiver: a ClapCompositeMatch
	Arguments and temporary variables: 
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		parent: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
		startIndex: 	1
		children: 	an OrderedCollection(a ClapNamedMatch)


[ :m |
				m value: self.
				self exitSuccess ] in [
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ]
			ifMismatch: [ self noneMatched ]
	] in ClapContext>>executeToExit:
	Receiver: a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Arguments and temporary variables: 
		exitBlock: 	[ :exit | self handleExit: exit ]
		m: 	a ClapCompositeMatch
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		arguments: 	an OrderedCollection('referenceCheck' 'index.md')
		obeyingExits: 	true
		stdio: 	Stdio
		match: 	a ClapCompositeMatch
		leftovers: 	an OrderedCollection()
		session: 	a WorkingSession
		exitException: 	nil


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :m |
				m value: self.
				self exitSuccess ]
	Arguments and temporary variables: 
		anArg: 	a ClapCompositeMatch
	Receiver's instance variables: 
		outerContext: 	[
		self rememberSession;
			ifMatch: [ :m |
				m value: sel[..]
		compiledBlock: 	a CompiledBlock: [ :m |
				m value: self.
				self exitSucc[..]
		numArgs: 	1
		receiver: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))


ClapCompositeMatch(ClapSubExpression)>>ifMatch:ifMismatch:
	Receiver: a ClapCompositeMatch
	Arguments and temporary variables: 
		matchBlock: 	[ :m |
				m value: self.
				self exitSuccess ]
		mismatchBlock: 	[ self noneMatched ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		parent: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
		startIndex: 	1
		children: 	an OrderedCollection(a ClapNamedMatch)


ClapContext>>ifMatch:ifMismatch:
	Receiver: a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Arguments and temporary variables: 
		matchBlock: 	[ :m |
				m value: self.
				self exitSuccess ]
		failBlock: 	[ self noneMatched ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		arguments: 	an OrderedCollection('referenceCheck' 'index.md')
		obeyingExits: 	true
		stdio: 	Stdio
		match: 	a ClapCompositeMatch
		leftovers: 	an OrderedCollection()
		session: 	a WorkingSession
		exitException: 	nil


[
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ]
			ifMismatch: [ self noneMatched ]
	] in ClapContext>>executeToExit:
	Receiver: a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Arguments and temporary variables: 
		exitBlock: 	[ :exit | self handleExit: exit ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		arguments: 	an OrderedCollection('referenceCheck' 'index.md')
		obeyingExits: 	true
		stdio: 	Stdio
		match: 	a ClapCompositeMatch
		leftovers: 	an OrderedCollection()
		session: 	a WorkingSession
		exitException: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ][..]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exception |
			exitException := exception.
			exitBlock v[..]
	Receiver's instance variables: 
		outerContext: 	ClapContext>>executeToExit:
		compiledBlock: 	a CompiledBlock: [
		self rememberSession;
			ifMatch: [ :m [..]
		numArgs: 	0
		receiver: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))


ClapContext>>executeToExit:
	Receiver: a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Arguments and temporary variables: 
		exitBlock: 	[ :exit | self handleExit: exit ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		arguments: 	an OrderedCollection('referenceCheck' 'index.md')
		obeyingExits: 	true
		stdio: 	Stdio
		match: 	a ClapCompositeMatch
		leftovers: 	an OrderedCollection()
		session: 	a WorkingSession
		exitException: 	nil


[
		ClapContext withPragmaCommands
			beObeyingExits;
			setStdio: Stdio;
			arguments: self arguments;
			executeToExit: [ :exit | self handleExit: exit ]
	] in ClapCommandLineHandler>>activate
	Receiver: a ClapCommandLineHandler
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
	Receiver: [
		ClapContext withPragmaCommands
			beObeyingExits;
			setStdio: Stdio;
			arguments[..]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		outerContext: 	ClapCommandLineHandler>>activate
		compiledBlock: 	a CompiledBlock: [
		ClapContext withPragmaCommands
			beObe[..]
		numArgs: 	0
		receiver: 	a ClapCommandLineHandler



--- The full stack ---
ClapMicrodownBookReferenceCheckerCommand(Object)>>halt
ClapMicrodownBookReferenceCheckerCommand>>execute
[ :args |
			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].
			(self with: args) execute ] in ClapMicrodownBookReferenceCheckerCommand class>>commandSpecification
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
ClapCommand(ClapParameter)>>valueFor:with:
[ super valueFor: aMatch with: arg ] in ClapCommand>>valueFor:with:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
ClapNamedMatch(ClapCompositeMatch)>>matchedSubcommand:ifNone:
ClapCommand>>valueFor:with:
ClapNamedMatch(ClapExpression)>>value:
[ :sub | sub value: arg ] in ClapRoot(ClapCommand)>>valueFor:with:
FullBlockClosure(BlockClosure)>>cull:
[ :cmdMatch | foundBlock cull: cmdMatch ] in ClapCompositeMatch>>matchedSubcommand:ifNone:
FullBlockClosure(BlockClosure)>>cull:
[ :each |
			(aBlock value: each)
				ifTrue: [ ^ foundBlock cull: each ] ] in OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
ClapCompositeMatch>>matchedSubcommand:ifNone:
ClapRoot(ClapCommand)>>valueFor:with:
ClapCompositeMatch(ClapExpression)>>value:
[ :m |
				m value: self.
				self exitSuccess ] in [
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ]
			ifMismatch: [ self noneMatched ]
	] in ClapContext>>executeToExit:
FullBlockClosure(BlockClosure)>>cull:
ClapCompositeMatch(ClapSubExpression)>>ifMatch:ifMismatch:
ClapContext>>ifMatch:ifMismatch:
[
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ]
			ifMismatch: [ self noneMatched ]
	] in ClapContext>>executeToExit:
FullBlockClosure(BlockClosure)>>on:do:
ClapContext>>executeToExit:
[
		ClapContext withPragmaCommands
			beObeyingExits;
			setStdio: Stdio;
			arguments: self arguments;
			executeToExit: [ :exit | self handleExit: exit ]
	] in ClapCommandLineHandler>>activate
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE

4 August 2024 10:36:22.375598 am

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 74b785ff-50d8-0d00-86f4-c64e0df24b96 Jun 28 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 74b785ff-50d8-0d00-86f4-c64e0df24b96 Jun 28 2024
v10.3.0 - Commit: ce151716 - Date: 2024-06-28 10:12:41 +0200

Image: Pharo12.0.0SNAPSHOT [Build information: Pharo-12.0.0+SNAPSHOT.build.1526.sha.404d3af7531f656b5c294762c79011c10bea1ef3 (64 Bit)]

ClapMicrodownBookReferenceCheckerCommand(Object)>>halt
	Receiver: a ClapMicrodownBookReferenceCheckerCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		arguments: 	a ClapNamedMatch
		project: 	nil


ClapMicrodownBookReferenceCheckerCommand>>execute
	Receiver: a ClapMicrodownBookReferenceCheckerCommand
	Arguments and temporary variables: 
		file: 	File @ index.md
		checker: 	nil
	Receiver's instance variables: 
		arguments: 	a ClapNamedMatch
		project: 	nil


[ :args |
			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].
			(self with: args) execute ] in ClapMicrodownBookReferenceCheckerCommand class>>commandSpecification
	Receiver: ClapMicrodownBookReferenceCheckerCommand
	Arguments and temporary variables: 
		args: 	a ClapNamedMatch
	Receiver's instance variables: 
		superclass: 	ClapPillarCommand
		methodDict: 	a MethodDictionary(#execute->ClapMicrodownBookReferenceCheckerC[..]
		format: 	65538
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (execution) - 2 selector(s))
		subclasses: 	nil
		name: 	#ClapMicrodownBookReferenceCheckerCommand
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	7449745
		packageTag: 	a PackageTag(Uncategorized)


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :args |
			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].
			(se[..]
	Arguments and temporary variables: 
		anArg: 	a ClapNamedMatch
	Receiver's instance variables: 
		outerContext: 	ClapMicrodownBookReferenceCheckerCommand class>>commandSpecif[..]
		compiledBlock: 	a CompiledBlock: [ :args |
			args at: #helpFlag ifPresent: [..]
		numArgs: 	1
		receiver: 	ClapMicrodownBookReferenceCheckerCommand


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ :args |
			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].
			(se[..]
	Arguments and temporary variables: 
		firstArg: 	a ClapNamedMatch
		secondArg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		outerContext: 	ClapMicrodownBookReferenceCheckerCommand class>>commandSpecif[..]
		compiledBlock: 	a CompiledBlock: [ :args |
			args at: #helpFlag ifPresent: [..]
		numArgs: 	1
		receiver: 	ClapMicrodownBookReferenceCheckerCommand


ClapCommand(ClapParameter)>>valueFor:with:
	Receiver: a ClapCommand(referenceCheck)
	Arguments and temporary variables: 
		aMatch: 	a ClapNamedMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		identifier: 	#referenceCheck
		canonicalName: 	nil
		description: 	'Check the duplicated or unknown references'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help | help val[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #requestedFile[..]
		positionals: 	an OrderedCollection(a ClapPositional(requestedFile))
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help))
		subcommands: 	an OrderedCollection()


[ super valueFor: aMatch with: arg ] in ClapCommand>>valueFor:with:
	Receiver: a ClapCommand(referenceCheck)
	Arguments and temporary variables: 
		aMatch: 	a ClapNamedMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		identifier: 	#referenceCheck
		canonicalName: 	nil
		description: 	'Check the duplicated or unknown references'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help | help val[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #requestedFile[..]
		positionals: 	an OrderedCollection(a ClapPositional(requestedFile))
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help))
		subcommands: 	an OrderedCollection()


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(a ClapWordMatch)
	Arguments and temporary variables: 
		aBlock: 	[ :child | specification subcommands includes: child specification ]
		foundBlock: 	[ :cmdMatch | foundBlock cull: cmdMatch ]
		exceptionBlock: 	[ super valueFor: aMatch with: arg ]
	Receiver's instance variables: 
		array: 	an Array(a ClapWordMatch nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


ClapNamedMatch(ClapCompositeMatch)>>matchedSubcommand:ifNone:
	Receiver: a ClapNamedMatch
	Arguments and temporary variables: 
		foundBlock: 	[ :sub | sub value: arg ]
		noneBlock: 	[ super valueFor: aMatch with: arg ]
	Receiver's instance variables: 
		specification: 	a ClapCommand(referenceCheck)
		parent: 	a ClapCompositeMatch
		startIndex: 	1
		children: 	an OrderedCollection(a ClapWordMatch)
		keyword: 	'referenceCheck'


ClapCommand>>valueFor:with:
	Receiver: a ClapCommand(referenceCheck)
	Arguments and temporary variables: 
		aMatch: 	a ClapNamedMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		identifier: 	#referenceCheck
		canonicalName: 	nil
		description: 	'Check the duplicated or unknown references'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help | help val[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #requestedFile[..]
		positionals: 	an OrderedCollection(a ClapPositional(requestedFile))
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help))
		subcommands: 	an OrderedCollection()


ClapNamedMatch(ClapExpression)>>value:
	Receiver: a ClapNamedMatch
	Arguments and temporary variables: 
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		specification: 	a ClapCommand(referenceCheck)
		parent: 	a ClapCompositeMatch
		startIndex: 	1
		children: 	an OrderedCollection(a ClapWordMatch)
		keyword: 	'referenceCheck'


[ :sub | sub value: arg ] in ClapRoot(ClapCommand)>>valueFor:with:
	Receiver: a ClapRoot(clap)
	Arguments and temporary variables: 
		aMatch: 	a ClapCompositeMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
		sub: 	a ClapNamedMatch
	Receiver's instance variables: 
		identifier: 	#clap
		canonicalName: 	nil
		description: 	'Entry point for commands implemented with Clap'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help |
				help[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #helpCommand->[..]
		positionals: 	an OrderedCollection()
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help) a ClapFlag(save) a ClapFlag(no[..]
		subcommands: 	an OrderedCollection(a ClapCommand(help) a ClapCommand(image) [..]


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :sub | sub value: arg ]
	Arguments and temporary variables: 
		anArg: 	a ClapNamedMatch
	Receiver's instance variables: 
		outerContext: 	ClapRoot(ClapCommand)>>valueFor:with:
		compiledBlock: 	a CompiledBlock: [ :sub | sub value: arg ]
		numArgs: 	1
		receiver: 	a ClapRoot(clap)


[ :cmdMatch | foundBlock cull: cmdMatch ] in ClapCompositeMatch>>matchedSubcommand:ifNone:
	Receiver: a ClapCompositeMatch
	Arguments and temporary variables: 
		foundBlock: 	[ :sub | sub value: arg ]
		noneBlock: 	[ super valueFor: aMatch with: arg ]
		cmdMatch: 	a ClapNamedMatch
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		parent: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
		startIndex: 	1
		children: 	an OrderedCollection(a ClapNamedMatch)


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :cmdMatch | foundBlock cull: cmdMatch ]
	Arguments and temporary variables: 
		anArg: 	a ClapNamedMatch
	Receiver's instance variables: 
		outerContext: 	ClapCompositeMatch>>matchedSubcommand:ifNone:
		compiledBlock: 	a CompiledBlock: [ :cmdMatch | foundBlock cull: cmdMatch ]
		numArgs: 	1
		receiver: 	a ClapCompositeMatch


[ :each |
			(aBlock value: each)
				ifTrue: [ ^ foundBlock cull: each ] ] in OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(a ClapNamedMatch)
	Arguments and temporary variables: 
		aBlock: 	[ :child | specification subcommands includes: child specification ]
		foundBlock: 	[ :cmdMatch | foundBlock cull: cmdMatch ]
		exceptionBlock: 	[ super valueFor: aMatch with: arg ]
		each: 	a ClapNamedMatch
	Receiver's instance variables: 
		array: 	an Array(a ClapNamedMatch nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


OrderedCollection>>do:
	Receiver: an OrderedCollection(a ClapNamedMatch)
	Arguments and temporary variables: 
		aBlock: 	[ :each |
			(aBlock value: each)
				ifTrue: [ ^ foundBlock cull: [..]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a ClapNamedMatch nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(a ClapNamedMatch)
	Arguments and temporary variables: 
		aBlock: 	[ :child | specification subcommands includes: child specification ]
		foundBlock: 	[ :cmdMatch | foundBlock cull: cmdMatch ]
		exceptionBlock: 	[ super valueFor: aMatch with: arg ]
	Receiver's instance variables: 
		array: 	an Array(a ClapNamedMatch nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


ClapCompositeMatch>>matchedSubcommand:ifNone:
	Receiver: a ClapCompositeMatch
	Arguments and temporary variables: 
		foundBlock: 	[ :sub | sub value: arg ]
		noneBlock: 	[ super valueFor: aMatch with: arg ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		parent: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
		startIndex: 	1
		children: 	an OrderedCollection(a ClapNamedMatch)


ClapRoot(ClapCommand)>>valueFor:with:
	Receiver: a ClapRoot(clap)
	Arguments and temporary variables: 
		aMatch: 	a ClapCompositeMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		identifier: 	#clap
		canonicalName: 	nil
		description: 	'Entry point for commands implemented with Clap'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help |
				help[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #helpCommand->[..]
		positionals: 	an OrderedCollection()
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help) a ClapFlag(save) a ClapFlag(no[..]
		subcommands: 	an OrderedCollection(a ClapCommand(help) a ClapCommand(image) [..]


ClapCompositeMatch(ClapExpression)>>value:
	Receiver: a ClapCompositeMatch
	Arguments and temporary variables: 
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		parent: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
		startIndex: 	1
		children: 	an OrderedCollection(a ClapNamedMatch)


[ :m |
				m value: self.
				self exitSuccess ] in [
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ]
			ifMismatch: [ self noneMatched ]
	] in ClapContext>>executeToExit:
	Receiver: a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Arguments and temporary variables: 
		exitBlock: 	[ :exit | self handleExit: exit ]
		m: 	a ClapCompositeMatch
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		arguments: 	an OrderedCollection('referenceCheck' 'index.md')
		obeyingExits: 	true
		stdio: 	Stdio
		match: 	a ClapCompositeMatch
		leftovers: 	an OrderedCollection()
		session: 	a WorkingSession
		exitException: 	nil


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :m |
				m value: self.
				self exitSuccess ]
	Arguments and temporary variables: 
		anArg: 	a ClapCompositeMatch
	Receiver's instance variables: 
		outerContext: 	[
		self rememberSession;
			ifMatch: [ :m |
				m value: sel[..]
		compiledBlock: 	a CompiledBlock: [ :m |
				m value: self.
				self exitSucc[..]
		numArgs: 	1
		receiver: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))


ClapCompositeMatch(ClapSubExpression)>>ifMatch:ifMismatch:
	Receiver: a ClapCompositeMatch
	Arguments and temporary variables: 
		matchBlock: 	[ :m |
				m value: self.
				self exitSuccess ]
		mismatchBlock: 	[ self noneMatched ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		parent: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
		startIndex: 	1
		children: 	an OrderedCollection(a ClapNamedMatch)


ClapContext>>ifMatch:ifMismatch:
	Receiver: a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Arguments and temporary variables: 
		matchBlock: 	[ :m |
				m value: self.
				self exitSuccess ]
		failBlock: 	[ self noneMatched ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		arguments: 	an OrderedCollection('referenceCheck' 'index.md')
		obeyingExits: 	true
		stdio: 	Stdio
		match: 	a ClapCompositeMatch
		leftovers: 	an OrderedCollection()
		session: 	a WorkingSession
		exitException: 	nil


[
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ]
			ifMismatch: [ self noneMatched ]
	] in ClapContext>>executeToExit:
	Receiver: a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Arguments and temporary variables: 
		exitBlock: 	[ :exit | self handleExit: exit ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		arguments: 	an OrderedCollection('referenceCheck' 'index.md')
		obeyingExits: 	true
		stdio: 	Stdio
		match: 	a ClapCompositeMatch
		leftovers: 	an OrderedCollection()
		session: 	a WorkingSession
		exitException: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ][..]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exception |
			exitException := exception.
			exitBlock v[..]
	Receiver's instance variables: 
		outerContext: 	ClapContext>>executeToExit:
		compiledBlock: 	a CompiledBlock: [
		self rememberSession;
			ifMatch: [ :m [..]
		numArgs: 	0
		receiver: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))


ClapContext>>executeToExit:
	Receiver: a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Arguments and temporary variables: 
		exitBlock: 	[ :exit | self handleExit: exit ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		arguments: 	an OrderedCollection('referenceCheck' 'index.md')
		obeyingExits: 	true
		stdio: 	Stdio
		match: 	a ClapCompositeMatch
		leftovers: 	an OrderedCollection()
		session: 	a WorkingSession
		exitException: 	nil


[
		ClapContext withPragmaCommands
			beObeyingExits;
			setStdio: Stdio;
			arguments: self arguments;
			executeToExit: [ :exit | self handleExit: exit ]
	] in ClapCommandLineHandler>>activate
	Receiver: a ClapCommandLineHandler
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
	Receiver: [
		ClapContext withPragmaCommands
			beObeyingExits;
			setStdio: Stdio;
			arguments[..]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		outerContext: 	ClapCommandLineHandler>>activate
		compiledBlock: 	a CompiledBlock: [
		ClapContext withPragmaCommands
			beObe[..]
		numArgs: 	0
		receiver: 	a ClapCommandLineHandler



--- The full stack ---
ClapMicrodownBookReferenceCheckerCommand(Object)>>halt
ClapMicrodownBookReferenceCheckerCommand>>execute
[ :args |
			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].
			(self with: args) execute ] in ClapMicrodownBookReferenceCheckerCommand class>>commandSpecification
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
ClapCommand(ClapParameter)>>valueFor:with:
[ super valueFor: aMatch with: arg ] in ClapCommand>>valueFor:with:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
ClapNamedMatch(ClapCompositeMatch)>>matchedSubcommand:ifNone:
ClapCommand>>valueFor:with:
ClapNamedMatch(ClapExpression)>>value:
[ :sub | sub value: arg ] in ClapRoot(ClapCommand)>>valueFor:with:
FullBlockClosure(BlockClosure)>>cull:
[ :cmdMatch | foundBlock cull: cmdMatch ] in ClapCompositeMatch>>matchedSubcommand:ifNone:
FullBlockClosure(BlockClosure)>>cull:
[ :each |
			(aBlock value: each)
				ifTrue: [ ^ foundBlock cull: each ] ] in OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
ClapCompositeMatch>>matchedSubcommand:ifNone:
ClapRoot(ClapCommand)>>valueFor:with:
ClapCompositeMatch(ClapExpression)>>value:
[ :m |
				m value: self.
				self exitSuccess ] in [
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ]
			ifMismatch: [ self noneMatched ]
	] in ClapContext>>executeToExit:
FullBlockClosure(BlockClosure)>>cull:
ClapCompositeMatch(ClapSubExpression)>>ifMatch:ifMismatch:
ClapContext>>ifMatch:ifMismatch:
[
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ]
			ifMismatch: [ self noneMatched ]
	] in ClapContext>>executeToExit:
FullBlockClosure(BlockClosure)>>on:do:
ClapContext>>executeToExit:
[
		ClapContext withPragmaCommands
			beObeyingExits;
			setStdio: Stdio;
			arguments: self arguments;
			executeToExit: [ :exit | self handleExit: exit ]
	] in ClapCommandLineHandler>>activate
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Message not understood: FileReference >> #referenceTo:
4 August 2024 10:36:24.618836 am

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 74b785ff-50d8-0d00-86f4-c64e0df24b96 Jun 28 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 74b785ff-50d8-0d00-86f4-c64e0df24b96 Jun 28 2024
v10.3.0 - Commit: ce151716 - Date: 2024-06-28 10:12:41 +0200

Image: Pharo12.0.0SNAPSHOT [Build information: Pharo-12.0.0+SNAPSHOT.build.1526.sha.404d3af7531f656b5c294762c79011c10bea1ef3 (64 Bit)]

FileReference(Object)>>doesNotUnderstand: #referenceTo:
	Receiver: File @ /Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/PharoBooks2/Booklet-Gra[..]
	Arguments and temporary variables: 
		aMessage: 	referenceTo: '/Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Wri[..]
		exception: 	Instance of FileReference did not understand #referenceTo:
		resumeValue: 	nil
	Receiver's instance variables: 
		path: 	Path / 'Users' / 'ducasse' / 'Workspace' / 'FirstCircle' / 'MyBooks' [..]
		filesystem: 	a FileSystem


[ :inputFile |
			| fr doc |
			"later we will have to fix this ugly expression"
			fr := self fileSystem referenceTo:
				      (inputFile arguments at: 'path') uri asFileReference
					      pathString.
			
			"Since we are just checking that a file exist it does not matter when we check.
			We do not have to wait until we walk through all the files."
			
			(visited includes: fr path pathString) ifFalse: [
				[
				doc := Microdown parseFile: fr.
				worklist addFirst: doc ]
					on: FileDoesNotExistException
					do: [ unexistingFiles add: inputFile ] ] ] in MicFileCollector>>visitRoot:
	Receiver: a MicFileCollector
	Arguments and temporary variables: 
		micDocument: 	a MicRootBlock
		worklist: 	an OrderedCollection()
		currentDocument: 	a MicRootBlock
		fr: 	nil
		doc: 	nil
		inputFile: 	a MicInputfileBlock
	Receiver's instance variables: 
		fileSystem: 	File @ /Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/[..]
		visited: 	a Set('/Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/Pha[..]
		unexistingFiles: 	a Set()
		inputFiles: 	an OrderedCollection(a MicInputfileBlock a MicInputfileBlock a [..]


OrderedCollection>>do:
	Receiver: an OrderedCollection(a MicInputfileBlock a MicInputfileBlock a MicInputfileBlock a Mic[..]
	Arguments and temporary variables: 
		aBlock: 	[ :inputFile |
			| fr doc |
			"later we will have to fix this ugl[..]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a MicInputfileBlock a MicInputfileBlock a MicInputfileBlock[..]
		firstIndex: 	1
		lastIndex: 	19


MicFileCollector>>visitRoot:
	Receiver: a MicFileCollector
	Arguments and temporary variables: 
		micDocument: 	a MicRootBlock
		worklist: 	an OrderedCollection()
		currentDocument: 	a MicRootBlock
	Receiver's instance variables: 
		fileSystem: 	File @ /Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/[..]
		visited: 	a Set('/Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/Pha[..]
		unexistingFiles: 	a Set()
		inputFiles: 	an OrderedCollection(a MicInputfileBlock a MicInputfileBlock a [..]


MicRootBlock>>accept:
	Receiver: a MicRootBlock
	Arguments and temporary variables: 
		aVisitor: 	a MicFileCollector
	Receiver's instance variables: 
		parent: 	nil
		properties: 	a Dictionary(#file->'/Users/ducasse/Workspace/FirstCircle/MyBoo[..]
		children: 	an OrderedCollection(a MicInputfileBlock a MicHeaderBlock a MicIn[..]
		parser: 	a MicrodownParser


MicFileCollector(MicrodownVisitor)>>visit:
	Receiver: a MicFileCollector
	Arguments and temporary variables: 
		aMicElement: 	a MicRootBlock
	Receiver's instance variables: 
		fileSystem: 	File @ /Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/[..]
		visited: 	a Set('/Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/Pha[..]
		unexistingFiles: 	a Set()
		inputFiles: 	an OrderedCollection(a MicInputfileBlock a MicInputfileBlock a [..]


MicReferenceChecker>>checkProject:
	Receiver: a MicReferenceChecker
	Arguments and temporary variables: 
		aFileReference: 	File @ index.md
		mainMic: 	a MicRootBlock
		collector: 	a MicFileCollector
		listOfFiles: 	nil
	Receiver's instance variables: 
		references: 	an OrderedCollection()
		anchors: 	an OrderedCollection()
		duplicatedAnchors: 	an OrderedCollection()
		results: 	an OrderedCollection()
		fileSystem: 	File @ /Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/[..]


ClapMicrodownBookReferenceCheckerCommand>>execute
	Receiver: a ClapMicrodownBookReferenceCheckerCommand
	Arguments and temporary variables: 
		file: 	File @ index.md
		checker: 	a MicReferenceChecker
	Receiver's instance variables: 
		arguments: 	a ClapNamedMatch
		project: 	nil


[ :args |
			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].
			(self with: args) execute ] in ClapMicrodownBookReferenceCheckerCommand class>>commandSpecification
	Receiver: ClapMicrodownBookReferenceCheckerCommand
	Arguments and temporary variables: 
		args: 	a ClapNamedMatch
	Receiver's instance variables: 
		superclass: 	ClapPillarCommand
		methodDict: 	a MethodDictionary(#execute->ClapMicrodownBookReferenceCheckerC[..]
		format: 	65538
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (execution) - 2 selector(s))
		subclasses: 	nil
		name: 	#ClapMicrodownBookReferenceCheckerCommand
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	7449745
		packageTag: 	a PackageTag(Uncategorized)


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :args |
			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].
			(se[..]
	Arguments and temporary variables: 
		anArg: 	a ClapNamedMatch
	Receiver's instance variables: 
		outerContext: 	ClapMicrodownBookReferenceCheckerCommand class>>commandSpecif[..]
		compiledBlock: 	a CompiledBlock: [ :args |
			args at: #helpFlag ifPresent: [..]
		numArgs: 	1
		receiver: 	ClapMicrodownBookReferenceCheckerCommand


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ :args |
			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].
			(se[..]
	Arguments and temporary variables: 
		firstArg: 	a ClapNamedMatch
		secondArg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		outerContext: 	ClapMicrodownBookReferenceCheckerCommand class>>commandSpecif[..]
		compiledBlock: 	a CompiledBlock: [ :args |
			args at: #helpFlag ifPresent: [..]
		numArgs: 	1
		receiver: 	ClapMicrodownBookReferenceCheckerCommand


ClapCommand(ClapParameter)>>valueFor:with:
	Receiver: a ClapCommand(referenceCheck)
	Arguments and temporary variables: 
		aMatch: 	a ClapNamedMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		identifier: 	#referenceCheck
		canonicalName: 	nil
		description: 	'Check the duplicated or unknown references'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help | help val[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #requestedFile[..]
		positionals: 	an OrderedCollection(a ClapPositional(requestedFile))
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help))
		subcommands: 	an OrderedCollection()


[ super valueFor: aMatch with: arg ] in ClapCommand>>valueFor:with:
	Receiver: a ClapCommand(referenceCheck)
	Arguments and temporary variables: 
		aMatch: 	a ClapNamedMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		identifier: 	#referenceCheck
		canonicalName: 	nil
		description: 	'Check the duplicated or unknown references'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help | help val[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #requestedFile[..]
		positionals: 	an OrderedCollection(a ClapPositional(requestedFile))
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help))
		subcommands: 	an OrderedCollection()


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(a ClapWordMatch)
	Arguments and temporary variables: 
		aBlock: 	[ :child | specification subcommands includes: child specification ]
		foundBlock: 	[ :cmdMatch | foundBlock cull: cmdMatch ]
		exceptionBlock: 	[ super valueFor: aMatch with: arg ]
	Receiver's instance variables: 
		array: 	an Array(a ClapWordMatch nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


ClapNamedMatch(ClapCompositeMatch)>>matchedSubcommand:ifNone:
	Receiver: a ClapNamedMatch
	Arguments and temporary variables: 
		foundBlock: 	[ :sub | sub value: arg ]
		noneBlock: 	[ super valueFor: aMatch with: arg ]
	Receiver's instance variables: 
		specification: 	a ClapCommand(referenceCheck)
		parent: 	a ClapCompositeMatch
		startIndex: 	1
		children: 	an OrderedCollection(a ClapWordMatch)
		keyword: 	'referenceCheck'


ClapCommand>>valueFor:with:
	Receiver: a ClapCommand(referenceCheck)
	Arguments and temporary variables: 
		aMatch: 	a ClapNamedMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		identifier: 	#referenceCheck
		canonicalName: 	nil
		description: 	'Check the duplicated or unknown references'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help | help val[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #requestedFile[..]
		positionals: 	an OrderedCollection(a ClapPositional(requestedFile))
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help))
		subcommands: 	an OrderedCollection()


ClapNamedMatch(ClapExpression)>>value:
	Receiver: a ClapNamedMatch
	Arguments and temporary variables: 
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		specification: 	a ClapCommand(referenceCheck)
		parent: 	a ClapCompositeMatch
		startIndex: 	1
		children: 	an OrderedCollection(a ClapWordMatch)
		keyword: 	'referenceCheck'


[ :sub | sub value: arg ] in ClapRoot(ClapCommand)>>valueFor:with:
	Receiver: a ClapRoot(clap)
	Arguments and temporary variables: 
		aMatch: 	a ClapCompositeMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
		sub: 	a ClapNamedMatch
	Receiver's instance variables: 
		identifier: 	#clap
		canonicalName: 	nil
		description: 	'Entry point for commands implemented with Clap'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help |
				help[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #helpCommand->[..]
		positionals: 	an OrderedCollection()
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help) a ClapFlag(save) a ClapFlag(no[..]
		subcommands: 	an OrderedCollection(a ClapCommand(help) a ClapCommand(image) [..]


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :sub | sub value: arg ]
	Arguments and temporary variables: 
		anArg: 	a ClapNamedMatch
	Receiver's instance variables: 
		outerContext: 	ClapRoot(ClapCommand)>>valueFor:with:
		compiledBlock: 	a CompiledBlock: [ :sub | sub value: arg ]
		numArgs: 	1
		receiver: 	a ClapRoot(clap)


[ :cmdMatch | foundBlock cull: cmdMatch ] in ClapCompositeMatch>>matchedSubcommand:ifNone:
	Receiver: a ClapCompositeMatch
	Arguments and temporary variables: 
		foundBlock: 	[ :sub | sub value: arg ]
		noneBlock: 	[ super valueFor: aMatch with: arg ]
		cmdMatch: 	a ClapNamedMatch
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		parent: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
		startIndex: 	1
		children: 	an OrderedCollection(a ClapNamedMatch)


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :cmdMatch | foundBlock cull: cmdMatch ]
	Arguments and temporary variables: 
		anArg: 	a ClapNamedMatch
	Receiver's instance variables: 
		outerContext: 	ClapCompositeMatch>>matchedSubcommand:ifNone:
		compiledBlock: 	a CompiledBlock: [ :cmdMatch | foundBlock cull: cmdMatch ]
		numArgs: 	1
		receiver: 	a ClapCompositeMatch


[ :each |
			(aBlock value: each)
				ifTrue: [ ^ foundBlock cull: each ] ] in OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(a ClapNamedMatch)
	Arguments and temporary variables: 
		aBlock: 	[ :child | specification subcommands includes: child specification ]
		foundBlock: 	[ :cmdMatch | foundBlock cull: cmdMatch ]
		exceptionBlock: 	[ super valueFor: aMatch with: arg ]
		each: 	a ClapNamedMatch
	Receiver's instance variables: 
		array: 	an Array(a ClapNamedMatch nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


OrderedCollection>>do:
	Receiver: an OrderedCollection(a ClapNamedMatch)
	Arguments and temporary variables: 
		aBlock: 	[ :each |
			(aBlock value: each)
				ifTrue: [ ^ foundBlock cull: [..]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a ClapNamedMatch nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(a ClapNamedMatch)
	Arguments and temporary variables: 
		aBlock: 	[ :child | specification subcommands includes: child specification ]
		foundBlock: 	[ :cmdMatch | foundBlock cull: cmdMatch ]
		exceptionBlock: 	[ super valueFor: aMatch with: arg ]
	Receiver's instance variables: 
		array: 	an Array(a ClapNamedMatch nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


ClapCompositeMatch>>matchedSubcommand:ifNone:
	Receiver: a ClapCompositeMatch
	Arguments and temporary variables: 
		foundBlock: 	[ :sub | sub value: arg ]
		noneBlock: 	[ super valueFor: aMatch with: arg ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		parent: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
		startIndex: 	1
		children: 	an OrderedCollection(a ClapNamedMatch)


ClapRoot(ClapCommand)>>valueFor:with:
	Receiver: a ClapRoot(clap)
	Arguments and temporary variables: 
		aMatch: 	a ClapCompositeMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		identifier: 	#clap
		canonicalName: 	nil
		description: 	'Entry point for commands implemented with Clap'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help |
				help[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #helpCommand->[..]
		positionals: 	an OrderedCollection()
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help) a ClapFlag(save) a ClapFlag(no[..]
		subcommands: 	an OrderedCollection(a ClapCommand(help) a ClapCommand(image) [..]


ClapCompositeMatch(ClapExpression)>>value:
	Receiver: a ClapCompositeMatch
	Arguments and temporary variables: 
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		parent: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
		startIndex: 	1
		children: 	an OrderedCollection(a ClapNamedMatch)


[ :m |
				m value: self.
				self exitSuccess ] in [
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ]
			ifMismatch: [ self noneMatched ]
	] in ClapContext>>executeToExit:
	Receiver: a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Arguments and temporary variables: 
		exitBlock: 	[ :exit | self handleExit: exit ]
		m: 	a ClapCompositeMatch
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		arguments: 	an OrderedCollection('referenceCheck' 'index.md')
		obeyingExits: 	true
		stdio: 	Stdio
		match: 	a ClapCompositeMatch
		leftovers: 	an OrderedCollection()
		session: 	a WorkingSession
		exitException: 	nil


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :m |
				m value: self.
				self exitSuccess ]
	Arguments and temporary variables: 
		anArg: 	a ClapCompositeMatch
	Receiver's instance variables: 
		outerContext: 	[
		self rememberSession;
			ifMatch: [ :m |
				m value: sel[..]
		compiledBlock: 	a CompiledBlock: [ :m |
				m value: self.
				self exitSucc[..]
		numArgs: 	1
		receiver: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))


ClapCompositeMatch(ClapSubExpression)>>ifMatch:ifMismatch:
	Receiver: a ClapCompositeMatch
	Arguments and temporary variables: 
		matchBlock: 	[ :m |
				m value: self.
				self exitSuccess ]
		mismatchBlock: 	[ self noneMatched ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		parent: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
		startIndex: 	1
		children: 	an OrderedCollection(a ClapNamedMatch)


ClapContext>>ifMatch:ifMismatch:
	Receiver: a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Arguments and temporary variables: 
		matchBlock: 	[ :m |
				m value: self.
				self exitSuccess ]
		failBlock: 	[ self noneMatched ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		arguments: 	an OrderedCollection('referenceCheck' 'index.md')
		obeyingExits: 	true
		stdio: 	Stdio
		match: 	a ClapCompositeMatch
		leftovers: 	an OrderedCollection()
		session: 	a WorkingSession
		exitException: 	nil


[
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ]
			ifMismatch: [ self noneMatched ]
	] in ClapContext>>executeToExit:
	Receiver: a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Arguments and temporary variables: 
		exitBlock: 	[ :exit | self handleExit: exit ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		arguments: 	an OrderedCollection('referenceCheck' 'index.md')
		obeyingExits: 	true
		stdio: 	Stdio
		match: 	a ClapCompositeMatch
		leftovers: 	an OrderedCollection()
		session: 	a WorkingSession
		exitException: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ][..]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exception |
			exitException := exception.
			exitBlock v[..]
	Receiver's instance variables: 
		outerContext: 	ClapContext>>executeToExit:
		compiledBlock: 	a CompiledBlock: [
		self rememberSession;
			ifMatch: [ :m [..]
		numArgs: 	0
		receiver: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))


ClapContext>>executeToExit:
	Receiver: a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Arguments and temporary variables: 
		exitBlock: 	[ :exit | self handleExit: exit ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		arguments: 	an OrderedCollection('referenceCheck' 'index.md')
		obeyingExits: 	true
		stdio: 	Stdio
		match: 	a ClapCompositeMatch
		leftovers: 	an OrderedCollection()
		session: 	a WorkingSession
		exitException: 	nil


[
		ClapContext withPragmaCommands
			beObeyingExits;
			setStdio: Stdio;
			arguments: self arguments;
			executeToExit: [ :exit | self handleExit: exit ]
	] in ClapCommandLineHandler>>activate
	Receiver: a ClapCommandLineHandler
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
	Receiver: [
		ClapContext withPragmaCommands
			beObeyingExits;
			setStdio: Stdio;
			arguments[..]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		outerContext: 	ClapCommandLineHandler>>activate
		compiledBlock: 	a CompiledBlock: [
		ClapContext withPragmaCommands
			beObe[..]
		numArgs: 	0
		receiver: 	a ClapCommandLineHandler



--- The full stack ---
FileReference(Object)>>doesNotUnderstand: #referenceTo:
[ :inputFile |
			| fr doc |
			"later we will have to fix this ugly expression"
			fr := self fileSystem referenceTo:
				      (inputFile arguments at: 'path') uri asFileReference
					      pathString.
			
			"Since we are just checking that a file exist it does not matter when we check.
			We do not have to wait until we walk through all the files."
			
			(visited includes: fr path pathString) ifFalse: [
				[
				doc := Microdown parseFile: fr.
				worklist addFirst: doc ]
					on: FileDoesNotExistException
					do: [ unexistingFiles add: inputFile ] ] ] in MicFileCollector>>visitRoot:
OrderedCollection>>do:
MicFileCollector>>visitRoot:
MicRootBlock>>accept:
MicFileCollector(MicrodownVisitor)>>visit:
MicReferenceChecker>>checkProject:
ClapMicrodownBookReferenceCheckerCommand>>execute
[ :args |
			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].
			(self with: args) execute ] in ClapMicrodownBookReferenceCheckerCommand class>>commandSpecification
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
ClapCommand(ClapParameter)>>valueFor:with:
[ super valueFor: aMatch with: arg ] in ClapCommand>>valueFor:with:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
ClapNamedMatch(ClapCompositeMatch)>>matchedSubcommand:ifNone:
ClapCommand>>valueFor:with:
ClapNamedMatch(ClapExpression)>>value:
[ :sub | sub value: arg ] in ClapRoot(ClapCommand)>>valueFor:with:
FullBlockClosure(BlockClosure)>>cull:
[ :cmdMatch | foundBlock cull: cmdMatch ] in ClapCompositeMatch>>matchedSubcommand:ifNone:
FullBlockClosure(BlockClosure)>>cull:
[ :each |
			(aBlock value: each)
				ifTrue: [ ^ foundBlock cull: each ] ] in OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
ClapCompositeMatch>>matchedSubcommand:ifNone:
ClapRoot(ClapCommand)>>valueFor:with:
ClapCompositeMatch(ClapExpression)>>value:
[ :m |
				m value: self.
				self exitSuccess ] in [
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ]
			ifMismatch: [ self noneMatched ]
	] in ClapContext>>executeToExit:
FullBlockClosure(BlockClosure)>>cull:
ClapCompositeMatch(ClapSubExpression)>>ifMatch:ifMismatch:
ClapContext>>ifMatch:ifMismatch:
[
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ]
			ifMismatch: [ self noneMatched ]
	] in ClapContext>>executeToExit:
FullBlockClosure(BlockClosure)>>on:do:
ClapContext>>executeToExit:
[
		ClapContext withPragmaCommands
			beObeyingExits;
			setStdio: Stdio;
			arguments: self arguments;
			executeToExit: [ :exit | self handleExit: exit ]
	] in ClapCommandLineHandler>>activate
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE

4 August 2024 10:38:00.263625 am

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 74b785ff-50d8-0d00-86f4-c64e0df24b96 Jun 28 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 74b785ff-50d8-0d00-86f4-c64e0df24b96 Jun 28 2024
v10.3.0 - Commit: ce151716 - Date: 2024-06-28 10:12:41 +0200

Image: Pharo12.0.0SNAPSHOT [Build information: Pharo-12.0.0+SNAPSHOT.build.1526.sha.404d3af7531f656b5c294762c79011c10bea1ef3 (64 Bit)]

ClapMicrodownBookReferenceCheckerCommand(Object)>>halt
	Receiver: a ClapMicrodownBookReferenceCheckerCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		arguments: 	a ClapNamedMatch
		project: 	nil


ClapMicrodownBookReferenceCheckerCommand>>execute
	Receiver: a ClapMicrodownBookReferenceCheckerCommand
	Arguments and temporary variables: 
		file: 	File @ index.md
		checker: 	nil
	Receiver's instance variables: 
		arguments: 	a ClapNamedMatch
		project: 	nil


[ :args |
			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].
			(self with: args) execute ] in ClapMicrodownBookReferenceCheckerCommand class>>commandSpecification
	Receiver: ClapMicrodownBookReferenceCheckerCommand
	Arguments and temporary variables: 
		args: 	a ClapNamedMatch
	Receiver's instance variables: 
		superclass: 	ClapPillarCommand
		methodDict: 	a MethodDictionary(#execute->ClapMicrodownBookReferenceCheckerC[..]
		format: 	65538
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (execution) - 2 selector(s))
		subclasses: 	nil
		name: 	#ClapMicrodownBookReferenceCheckerCommand
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	7449745
		packageTag: 	a PackageTag(Uncategorized)


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :args |
			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].
			(se[..]
	Arguments and temporary variables: 
		anArg: 	a ClapNamedMatch
	Receiver's instance variables: 
		outerContext: 	ClapMicrodownBookReferenceCheckerCommand class>>commandSpecif[..]
		compiledBlock: 	a CompiledBlock: [ :args |
			args at: #helpFlag ifPresent: [..]
		numArgs: 	1
		receiver: 	ClapMicrodownBookReferenceCheckerCommand


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ :args |
			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].
			(se[..]
	Arguments and temporary variables: 
		firstArg: 	a ClapNamedMatch
		secondArg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		outerContext: 	ClapMicrodownBookReferenceCheckerCommand class>>commandSpecif[..]
		compiledBlock: 	a CompiledBlock: [ :args |
			args at: #helpFlag ifPresent: [..]
		numArgs: 	1
		receiver: 	ClapMicrodownBookReferenceCheckerCommand


ClapCommand(ClapParameter)>>valueFor:with:
	Receiver: a ClapCommand(referenceCheck)
	Arguments and temporary variables: 
		aMatch: 	a ClapNamedMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		identifier: 	#referenceCheck
		canonicalName: 	nil
		description: 	'Check the duplicated or unknown references'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help | help val[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #requestedFile[..]
		positionals: 	an OrderedCollection(a ClapPositional(requestedFile))
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help))
		subcommands: 	an OrderedCollection()


[ super valueFor: aMatch with: arg ] in ClapCommand>>valueFor:with:
	Receiver: a ClapCommand(referenceCheck)
	Arguments and temporary variables: 
		aMatch: 	a ClapNamedMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		identifier: 	#referenceCheck
		canonicalName: 	nil
		description: 	'Check the duplicated or unknown references'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help | help val[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #requestedFile[..]
		positionals: 	an OrderedCollection(a ClapPositional(requestedFile))
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help))
		subcommands: 	an OrderedCollection()


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(a ClapWordMatch)
	Arguments and temporary variables: 
		aBlock: 	[ :child | specification subcommands includes: child specification ]
		foundBlock: 	[ :cmdMatch | foundBlock cull: cmdMatch ]
		exceptionBlock: 	[ super valueFor: aMatch with: arg ]
	Receiver's instance variables: 
		array: 	an Array(a ClapWordMatch nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


ClapNamedMatch(ClapCompositeMatch)>>matchedSubcommand:ifNone:
	Receiver: a ClapNamedMatch
	Arguments and temporary variables: 
		foundBlock: 	[ :sub | sub value: arg ]
		noneBlock: 	[ super valueFor: aMatch with: arg ]
	Receiver's instance variables: 
		specification: 	a ClapCommand(referenceCheck)
		parent: 	a ClapCompositeMatch
		startIndex: 	1
		children: 	an OrderedCollection(a ClapWordMatch)
		keyword: 	'referenceCheck'


ClapCommand>>valueFor:with:
	Receiver: a ClapCommand(referenceCheck)
	Arguments and temporary variables: 
		aMatch: 	a ClapNamedMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		identifier: 	#referenceCheck
		canonicalName: 	nil
		description: 	'Check the duplicated or unknown references'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help | help val[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #requestedFile[..]
		positionals: 	an OrderedCollection(a ClapPositional(requestedFile))
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help))
		subcommands: 	an OrderedCollection()


ClapNamedMatch(ClapExpression)>>value:
	Receiver: a ClapNamedMatch
	Arguments and temporary variables: 
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		specification: 	a ClapCommand(referenceCheck)
		parent: 	a ClapCompositeMatch
		startIndex: 	1
		children: 	an OrderedCollection(a ClapWordMatch)
		keyword: 	'referenceCheck'


[ :sub | sub value: arg ] in ClapRoot(ClapCommand)>>valueFor:with:
	Receiver: a ClapRoot(clap)
	Arguments and temporary variables: 
		aMatch: 	a ClapCompositeMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
		sub: 	a ClapNamedMatch
	Receiver's instance variables: 
		identifier: 	#clap
		canonicalName: 	nil
		description: 	'Entry point for commands implemented with Clap'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help |
				help[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #helpCommand->[..]
		positionals: 	an OrderedCollection()
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help) a ClapFlag(save) a ClapFlag(no[..]
		subcommands: 	an OrderedCollection(a ClapCommand(help) a ClapCommand(image) [..]


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :sub | sub value: arg ]
	Arguments and temporary variables: 
		anArg: 	a ClapNamedMatch
	Receiver's instance variables: 
		outerContext: 	ClapRoot(ClapCommand)>>valueFor:with:
		compiledBlock: 	a CompiledBlock: [ :sub | sub value: arg ]
		numArgs: 	1
		receiver: 	a ClapRoot(clap)


[ :cmdMatch | foundBlock cull: cmdMatch ] in ClapCompositeMatch>>matchedSubcommand:ifNone:
	Receiver: a ClapCompositeMatch
	Arguments and temporary variables: 
		foundBlock: 	[ :sub | sub value: arg ]
		noneBlock: 	[ super valueFor: aMatch with: arg ]
		cmdMatch: 	a ClapNamedMatch
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		parent: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
		startIndex: 	1
		children: 	an OrderedCollection(a ClapNamedMatch)


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :cmdMatch | foundBlock cull: cmdMatch ]
	Arguments and temporary variables: 
		anArg: 	a ClapNamedMatch
	Receiver's instance variables: 
		outerContext: 	ClapCompositeMatch>>matchedSubcommand:ifNone:
		compiledBlock: 	a CompiledBlock: [ :cmdMatch | foundBlock cull: cmdMatch ]
		numArgs: 	1
		receiver: 	a ClapCompositeMatch


[ :each |
			(aBlock value: each)
				ifTrue: [ ^ foundBlock cull: each ] ] in OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(a ClapNamedMatch)
	Arguments and temporary variables: 
		aBlock: 	[ :child | specification subcommands includes: child specification ]
		foundBlock: 	[ :cmdMatch | foundBlock cull: cmdMatch ]
		exceptionBlock: 	[ super valueFor: aMatch with: arg ]
		each: 	a ClapNamedMatch
	Receiver's instance variables: 
		array: 	an Array(a ClapNamedMatch nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


OrderedCollection>>do:
	Receiver: an OrderedCollection(a ClapNamedMatch)
	Arguments and temporary variables: 
		aBlock: 	[ :each |
			(aBlock value: each)
				ifTrue: [ ^ foundBlock cull: [..]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a ClapNamedMatch nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(a ClapNamedMatch)
	Arguments and temporary variables: 
		aBlock: 	[ :child | specification subcommands includes: child specification ]
		foundBlock: 	[ :cmdMatch | foundBlock cull: cmdMatch ]
		exceptionBlock: 	[ super valueFor: aMatch with: arg ]
	Receiver's instance variables: 
		array: 	an Array(a ClapNamedMatch nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


ClapCompositeMatch>>matchedSubcommand:ifNone:
	Receiver: a ClapCompositeMatch
	Arguments and temporary variables: 
		foundBlock: 	[ :sub | sub value: arg ]
		noneBlock: 	[ super valueFor: aMatch with: arg ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		parent: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
		startIndex: 	1
		children: 	an OrderedCollection(a ClapNamedMatch)


ClapRoot(ClapCommand)>>valueFor:with:
	Receiver: a ClapRoot(clap)
	Arguments and temporary variables: 
		aMatch: 	a ClapCompositeMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		identifier: 	#clap
		canonicalName: 	nil
		description: 	'Entry point for commands implemented with Clap'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help |
				help[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #helpCommand->[..]
		positionals: 	an OrderedCollection()
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help) a ClapFlag(save) a ClapFlag(no[..]
		subcommands: 	an OrderedCollection(a ClapCommand(help) a ClapCommand(image) [..]


ClapCompositeMatch(ClapExpression)>>value:
	Receiver: a ClapCompositeMatch
	Arguments and temporary variables: 
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		parent: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
		startIndex: 	1
		children: 	an OrderedCollection(a ClapNamedMatch)


[ :m |
				m value: self.
				self exitSuccess ] in [
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ]
			ifMismatch: [ self noneMatched ]
	] in ClapContext>>executeToExit:
	Receiver: a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Arguments and temporary variables: 
		exitBlock: 	[ :exit | self handleExit: exit ]
		m: 	a ClapCompositeMatch
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		arguments: 	an OrderedCollection('referenceCheck' 'index.md')
		obeyingExits: 	true
		stdio: 	Stdio
		match: 	a ClapCompositeMatch
		leftovers: 	an OrderedCollection()
		session: 	a WorkingSession
		exitException: 	nil


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :m |
				m value: self.
				self exitSuccess ]
	Arguments and temporary variables: 
		anArg: 	a ClapCompositeMatch
	Receiver's instance variables: 
		outerContext: 	[
		self rememberSession;
			ifMatch: [ :m |
				m value: sel[..]
		compiledBlock: 	a CompiledBlock: [ :m |
				m value: self.
				self exitSucc[..]
		numArgs: 	1
		receiver: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))


ClapCompositeMatch(ClapSubExpression)>>ifMatch:ifMismatch:
	Receiver: a ClapCompositeMatch
	Arguments and temporary variables: 
		matchBlock: 	[ :m |
				m value: self.
				self exitSuccess ]
		mismatchBlock: 	[ self noneMatched ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		parent: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
		startIndex: 	1
		children: 	an OrderedCollection(a ClapNamedMatch)


ClapContext>>ifMatch:ifMismatch:
	Receiver: a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Arguments and temporary variables: 
		matchBlock: 	[ :m |
				m value: self.
				self exitSuccess ]
		failBlock: 	[ self noneMatched ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		arguments: 	an OrderedCollection('referenceCheck' 'index.md')
		obeyingExits: 	true
		stdio: 	Stdio
		match: 	a ClapCompositeMatch
		leftovers: 	an OrderedCollection()
		session: 	a WorkingSession
		exitException: 	nil


[
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ]
			ifMismatch: [ self noneMatched ]
	] in ClapContext>>executeToExit:
	Receiver: a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Arguments and temporary variables: 
		exitBlock: 	[ :exit | self handleExit: exit ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		arguments: 	an OrderedCollection('referenceCheck' 'index.md')
		obeyingExits: 	true
		stdio: 	Stdio
		match: 	a ClapCompositeMatch
		leftovers: 	an OrderedCollection()
		session: 	a WorkingSession
		exitException: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ][..]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exception |
			exitException := exception.
			exitBlock v[..]
	Receiver's instance variables: 
		outerContext: 	ClapContext>>executeToExit:
		compiledBlock: 	a CompiledBlock: [
		self rememberSession;
			ifMatch: [ :m [..]
		numArgs: 	0
		receiver: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))


ClapContext>>executeToExit:
	Receiver: a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Arguments and temporary variables: 
		exitBlock: 	[ :exit | self handleExit: exit ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		arguments: 	an OrderedCollection('referenceCheck' 'index.md')
		obeyingExits: 	true
		stdio: 	Stdio
		match: 	a ClapCompositeMatch
		leftovers: 	an OrderedCollection()
		session: 	a WorkingSession
		exitException: 	nil


[
		ClapContext withPragmaCommands
			beObeyingExits;
			setStdio: Stdio;
			arguments: self arguments;
			executeToExit: [ :exit | self handleExit: exit ]
	] in ClapCommandLineHandler>>activate
	Receiver: a ClapCommandLineHandler
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
	Receiver: [
		ClapContext withPragmaCommands
			beObeyingExits;
			setStdio: Stdio;
			arguments[..]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		outerContext: 	ClapCommandLineHandler>>activate
		compiledBlock: 	a CompiledBlock: [
		ClapContext withPragmaCommands
			beObe[..]
		numArgs: 	0
		receiver: 	a ClapCommandLineHandler



--- The full stack ---
ClapMicrodownBookReferenceCheckerCommand(Object)>>halt
ClapMicrodownBookReferenceCheckerCommand>>execute
[ :args |
			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].
			(self with: args) execute ] in ClapMicrodownBookReferenceCheckerCommand class>>commandSpecification
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
ClapCommand(ClapParameter)>>valueFor:with:
[ super valueFor: aMatch with: arg ] in ClapCommand>>valueFor:with:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
ClapNamedMatch(ClapCompositeMatch)>>matchedSubcommand:ifNone:
ClapCommand>>valueFor:with:
ClapNamedMatch(ClapExpression)>>value:
[ :sub | sub value: arg ] in ClapRoot(ClapCommand)>>valueFor:with:
FullBlockClosure(BlockClosure)>>cull:
[ :cmdMatch | foundBlock cull: cmdMatch ] in ClapCompositeMatch>>matchedSubcommand:ifNone:
FullBlockClosure(BlockClosure)>>cull:
[ :each |
			(aBlock value: each)
				ifTrue: [ ^ foundBlock cull: each ] ] in OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
ClapCompositeMatch>>matchedSubcommand:ifNone:
ClapRoot(ClapCommand)>>valueFor:with:
ClapCompositeMatch(ClapExpression)>>value:
[ :m |
				m value: self.
				self exitSuccess ] in [
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ]
			ifMismatch: [ self noneMatched ]
	] in ClapContext>>executeToExit:
FullBlockClosure(BlockClosure)>>cull:
ClapCompositeMatch(ClapSubExpression)>>ifMatch:ifMismatch:
ClapContext>>ifMatch:ifMismatch:
[
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ]
			ifMismatch: [ self noneMatched ]
	] in ClapContext>>executeToExit:
FullBlockClosure(BlockClosure)>>on:do:
ClapContext>>executeToExit:
[
		ClapContext withPragmaCommands
			beObeyingExits;
			setStdio: Stdio;
			arguments: self arguments;
			executeToExit: [ :exit | self handleExit: exit ]
	] in ClapCommandLineHandler>>activate
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Message not understood: FileReference >> #referenceTo:
4 August 2024 10:38:06.936244 am

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 74b785ff-50d8-0d00-86f4-c64e0df24b96 Jun 28 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 74b785ff-50d8-0d00-86f4-c64e0df24b96 Jun 28 2024
v10.3.0 - Commit: ce151716 - Date: 2024-06-28 10:12:41 +0200

Image: Pharo12.0.0SNAPSHOT [Build information: Pharo-12.0.0+SNAPSHOT.build.1526.sha.404d3af7531f656b5c294762c79011c10bea1ef3 (64 Bit)]

FileReference(Object)>>doesNotUnderstand: #referenceTo:
	Receiver: File @ /Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/PharoBooks2/Booklet-Gra[..]
	Arguments and temporary variables: 
		aMessage: 	referenceTo: '/Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Wri[..]
		exception: 	Instance of FileReference did not understand #referenceTo:
		resumeValue: 	nil
	Receiver's instance variables: 
		path: 	Path / 'Users' / 'ducasse' / 'Workspace' / 'FirstCircle' / 'MyBooks' [..]
		filesystem: 	a FileSystem


[ :file |
		               fileSystem referenceTo: file ] in MicReferenceChecker>>checkProject:
	Receiver: a MicReferenceChecker
	Arguments and temporary variables: 
		aFileReference: 	File @ index.md
		mainMic: 	a MicRootBlock
		collector: 	a MicFileCollector
		listOfFiles: 	nil
		file: 	'/Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/PharoBooks2/[..]
	Receiver's instance variables: 
		references: 	an OrderedCollection()
		anchors: 	an OrderedCollection()
		duplicatedAnchors: 	an OrderedCollection()
		results: 	an OrderedCollection()
		fileSystem: 	File @ /Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/[..]


[:each | each ifNotNil: [newSet add: (aBlock value: each enclosedElement)]] in Set>>collect:
	Receiver: a Set('/Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/PharoBooks2/Booklet-Gra[..]
	Arguments and temporary variables: 
		aBlock: 	[ :file |
		               fileSystem referenceTo: file ]
		newSet: 	a Set()
		each: 	'/Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/PharoBooks2/[..]
	Receiver's instance variables: 
		tally: 	20
		array: 	#(nil nil nil nil nil '/Users/ducasse/Workspace/FirstCircle/MyBooks/[..]


Array(SequenceableCollection)>>do:
	Receiver: #(nil nil nil nil nil '/Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/PharoBo[..]
	Arguments and temporary variables: 
		aBlock: 	[:each | each ifNotNil: [newSet add: (aBlock value: each enclosedEl[..]
		index: 	6
	Receiver's instance variables: 
#(nil nil nil nil nil '/Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/PharoBo[..]

Set>>collect:
	Receiver: a Set('/Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/PharoBooks2/Booklet-Gra[..]
	Arguments and temporary variables: 
		aBlock: 	[ :file |
		               fileSystem referenceTo: file ]
		newSet: 	a Set()
	Receiver's instance variables: 
		tally: 	20
		array: 	#(nil nil nil nil nil '/Users/ducasse/Workspace/FirstCircle/MyBooks/[..]


MicReferenceChecker>>checkProject:
	Receiver: a MicReferenceChecker
	Arguments and temporary variables: 
		aFileReference: 	File @ index.md
		mainMic: 	a MicRootBlock
		collector: 	a MicFileCollector
		listOfFiles: 	nil
	Receiver's instance variables: 
		references: 	an OrderedCollection()
		anchors: 	an OrderedCollection()
		duplicatedAnchors: 	an OrderedCollection()
		results: 	an OrderedCollection()
		fileSystem: 	File @ /Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/[..]


ClapMicrodownBookReferenceCheckerCommand>>execute
	Receiver: a ClapMicrodownBookReferenceCheckerCommand
	Arguments and temporary variables: 
		file: 	File @ index.md
		checker: 	a MicReferenceChecker
	Receiver's instance variables: 
		arguments: 	a ClapNamedMatch
		project: 	nil


[ :args |
			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].
			(self with: args) execute ] in ClapMicrodownBookReferenceCheckerCommand class>>commandSpecification
	Receiver: ClapMicrodownBookReferenceCheckerCommand
	Arguments and temporary variables: 
		args: 	a ClapNamedMatch
	Receiver's instance variables: 
		superclass: 	ClapPillarCommand
		methodDict: 	a MethodDictionary(#execute->ClapMicrodownBookReferenceCheckerC[..]
		format: 	65538
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (execution) - 2 selector(s))
		subclasses: 	nil
		name: 	#ClapMicrodownBookReferenceCheckerCommand
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	7449745
		packageTag: 	a PackageTag(Uncategorized)


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :args |
			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].
			(se[..]
	Arguments and temporary variables: 
		anArg: 	a ClapNamedMatch
	Receiver's instance variables: 
		outerContext: 	ClapMicrodownBookReferenceCheckerCommand class>>commandSpecif[..]
		compiledBlock: 	a CompiledBlock: [ :args |
			args at: #helpFlag ifPresent: [..]
		numArgs: 	1
		receiver: 	ClapMicrodownBookReferenceCheckerCommand


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ :args |
			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].
			(se[..]
	Arguments and temporary variables: 
		firstArg: 	a ClapNamedMatch
		secondArg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		outerContext: 	ClapMicrodownBookReferenceCheckerCommand class>>commandSpecif[..]
		compiledBlock: 	a CompiledBlock: [ :args |
			args at: #helpFlag ifPresent: [..]
		numArgs: 	1
		receiver: 	ClapMicrodownBookReferenceCheckerCommand


ClapCommand(ClapParameter)>>valueFor:with:
	Receiver: a ClapCommand(referenceCheck)
	Arguments and temporary variables: 
		aMatch: 	a ClapNamedMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		identifier: 	#referenceCheck
		canonicalName: 	nil
		description: 	'Check the duplicated or unknown references'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help | help val[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #requestedFile[..]
		positionals: 	an OrderedCollection(a ClapPositional(requestedFile))
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help))
		subcommands: 	an OrderedCollection()


[ super valueFor: aMatch with: arg ] in ClapCommand>>valueFor:with:
	Receiver: a ClapCommand(referenceCheck)
	Arguments and temporary variables: 
		aMatch: 	a ClapNamedMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		identifier: 	#referenceCheck
		canonicalName: 	nil
		description: 	'Check the duplicated or unknown references'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help | help val[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #requestedFile[..]
		positionals: 	an OrderedCollection(a ClapPositional(requestedFile))
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help))
		subcommands: 	an OrderedCollection()


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(a ClapWordMatch)
	Arguments and temporary variables: 
		aBlock: 	[ :child | specification subcommands includes: child specification ]
		foundBlock: 	[ :cmdMatch | foundBlock cull: cmdMatch ]
		exceptionBlock: 	[ super valueFor: aMatch with: arg ]
	Receiver's instance variables: 
		array: 	an Array(a ClapWordMatch nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


ClapNamedMatch(ClapCompositeMatch)>>matchedSubcommand:ifNone:
	Receiver: a ClapNamedMatch
	Arguments and temporary variables: 
		foundBlock: 	[ :sub | sub value: arg ]
		noneBlock: 	[ super valueFor: aMatch with: arg ]
	Receiver's instance variables: 
		specification: 	a ClapCommand(referenceCheck)
		parent: 	a ClapCompositeMatch
		startIndex: 	1
		children: 	an OrderedCollection(a ClapWordMatch)
		keyword: 	'referenceCheck'


ClapCommand>>valueFor:with:
	Receiver: a ClapCommand(referenceCheck)
	Arguments and temporary variables: 
		aMatch: 	a ClapNamedMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		identifier: 	#referenceCheck
		canonicalName: 	nil
		description: 	'Check the duplicated or unknown references'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help | help val[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #requestedFile[..]
		positionals: 	an OrderedCollection(a ClapPositional(requestedFile))
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help))
		subcommands: 	an OrderedCollection()


ClapNamedMatch(ClapExpression)>>value:
	Receiver: a ClapNamedMatch
	Arguments and temporary variables: 
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		specification: 	a ClapCommand(referenceCheck)
		parent: 	a ClapCompositeMatch
		startIndex: 	1
		children: 	an OrderedCollection(a ClapWordMatch)
		keyword: 	'referenceCheck'


[ :sub | sub value: arg ] in ClapRoot(ClapCommand)>>valueFor:with:
	Receiver: a ClapRoot(clap)
	Arguments and temporary variables: 
		aMatch: 	a ClapCompositeMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
		sub: 	a ClapNamedMatch
	Receiver's instance variables: 
		identifier: 	#clap
		canonicalName: 	nil
		description: 	'Entry point for commands implemented with Clap'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help |
				help[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #helpCommand->[..]
		positionals: 	an OrderedCollection()
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help) a ClapFlag(save) a ClapFlag(no[..]
		subcommands: 	an OrderedCollection(a ClapCommand(help) a ClapCommand(image) [..]


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :sub | sub value: arg ]
	Arguments and temporary variables: 
		anArg: 	a ClapNamedMatch
	Receiver's instance variables: 
		outerContext: 	ClapRoot(ClapCommand)>>valueFor:with:
		compiledBlock: 	a CompiledBlock: [ :sub | sub value: arg ]
		numArgs: 	1
		receiver: 	a ClapRoot(clap)


[ :cmdMatch | foundBlock cull: cmdMatch ] in ClapCompositeMatch>>matchedSubcommand:ifNone:
	Receiver: a ClapCompositeMatch
	Arguments and temporary variables: 
		foundBlock: 	[ :sub | sub value: arg ]
		noneBlock: 	[ super valueFor: aMatch with: arg ]
		cmdMatch: 	a ClapNamedMatch
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		parent: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
		startIndex: 	1
		children: 	an OrderedCollection(a ClapNamedMatch)


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :cmdMatch | foundBlock cull: cmdMatch ]
	Arguments and temporary variables: 
		anArg: 	a ClapNamedMatch
	Receiver's instance variables: 
		outerContext: 	ClapCompositeMatch>>matchedSubcommand:ifNone:
		compiledBlock: 	a CompiledBlock: [ :cmdMatch | foundBlock cull: cmdMatch ]
		numArgs: 	1
		receiver: 	a ClapCompositeMatch


[ :each |
			(aBlock value: each)
				ifTrue: [ ^ foundBlock cull: each ] ] in OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(a ClapNamedMatch)
	Arguments and temporary variables: 
		aBlock: 	[ :child | specification subcommands includes: child specification ]
		foundBlock: 	[ :cmdMatch | foundBlock cull: cmdMatch ]
		exceptionBlock: 	[ super valueFor: aMatch with: arg ]
		each: 	a ClapNamedMatch
	Receiver's instance variables: 
		array: 	an Array(a ClapNamedMatch nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


OrderedCollection>>do:
	Receiver: an OrderedCollection(a ClapNamedMatch)
	Arguments and temporary variables: 
		aBlock: 	[ :each |
			(aBlock value: each)
				ifTrue: [ ^ foundBlock cull: [..]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a ClapNamedMatch nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(a ClapNamedMatch)
	Arguments and temporary variables: 
		aBlock: 	[ :child | specification subcommands includes: child specification ]
		foundBlock: 	[ :cmdMatch | foundBlock cull: cmdMatch ]
		exceptionBlock: 	[ super valueFor: aMatch with: arg ]
	Receiver's instance variables: 
		array: 	an Array(a ClapNamedMatch nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


ClapCompositeMatch>>matchedSubcommand:ifNone:
	Receiver: a ClapCompositeMatch
	Arguments and temporary variables: 
		foundBlock: 	[ :sub | sub value: arg ]
		noneBlock: 	[ super valueFor: aMatch with: arg ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		parent: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
		startIndex: 	1
		children: 	an OrderedCollection(a ClapNamedMatch)


ClapRoot(ClapCommand)>>valueFor:with:
	Receiver: a ClapRoot(clap)
	Arguments and temporary variables: 
		aMatch: 	a ClapCompositeMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		identifier: 	#clap
		canonicalName: 	nil
		description: 	'Entry point for commands implemented with Clap'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help |
				help[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #helpCommand->[..]
		positionals: 	an OrderedCollection()
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help) a ClapFlag(save) a ClapFlag(no[..]
		subcommands: 	an OrderedCollection(a ClapCommand(help) a ClapCommand(image) [..]


ClapCompositeMatch(ClapExpression)>>value:
	Receiver: a ClapCompositeMatch
	Arguments and temporary variables: 
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		parent: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
		startIndex: 	1
		children: 	an OrderedCollection(a ClapNamedMatch)


[ :m |
				m value: self.
				self exitSuccess ] in [
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ]
			ifMismatch: [ self noneMatched ]
	] in ClapContext>>executeToExit:
	Receiver: a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Arguments and temporary variables: 
		exitBlock: 	[ :exit | self handleExit: exit ]
		m: 	a ClapCompositeMatch
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		arguments: 	an OrderedCollection('referenceCheck' 'index.md')
		obeyingExits: 	true
		stdio: 	Stdio
		match: 	a ClapCompositeMatch
		leftovers: 	an OrderedCollection()
		session: 	a WorkingSession
		exitException: 	nil


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :m |
				m value: self.
				self exitSuccess ]
	Arguments and temporary variables: 
		anArg: 	a ClapCompositeMatch
	Receiver's instance variables: 
		outerContext: 	[
		self rememberSession;
			ifMatch: [ :m |
				m value: sel[..]
		compiledBlock: 	a CompiledBlock: [ :m |
				m value: self.
				self exitSucc[..]
		numArgs: 	1
		receiver: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))


ClapCompositeMatch(ClapSubExpression)>>ifMatch:ifMismatch:
	Receiver: a ClapCompositeMatch
	Arguments and temporary variables: 
		matchBlock: 	[ :m |
				m value: self.
				self exitSuccess ]
		mismatchBlock: 	[ self noneMatched ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		parent: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
		startIndex: 	1
		children: 	an OrderedCollection(a ClapNamedMatch)


ClapContext>>ifMatch:ifMismatch:
	Receiver: a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Arguments and temporary variables: 
		matchBlock: 	[ :m |
				m value: self.
				self exitSuccess ]
		failBlock: 	[ self noneMatched ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		arguments: 	an OrderedCollection('referenceCheck' 'index.md')
		obeyingExits: 	true
		stdio: 	Stdio
		match: 	a ClapCompositeMatch
		leftovers: 	an OrderedCollection()
		session: 	a WorkingSession
		exitException: 	nil


[
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ]
			ifMismatch: [ self noneMatched ]
	] in ClapContext>>executeToExit:
	Receiver: a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Arguments and temporary variables: 
		exitBlock: 	[ :exit | self handleExit: exit ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		arguments: 	an OrderedCollection('referenceCheck' 'index.md')
		obeyingExits: 	true
		stdio: 	Stdio
		match: 	a ClapCompositeMatch
		leftovers: 	an OrderedCollection()
		session: 	a WorkingSession
		exitException: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ][..]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exception |
			exitException := exception.
			exitBlock v[..]
	Receiver's instance variables: 
		outerContext: 	ClapContext>>executeToExit:
		compiledBlock: 	a CompiledBlock: [
		self rememberSession;
			ifMatch: [ :m [..]
		numArgs: 	0
		receiver: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))


ClapContext>>executeToExit:
	Receiver: a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Arguments and temporary variables: 
		exitBlock: 	[ :exit | self handleExit: exit ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		arguments: 	an OrderedCollection('referenceCheck' 'index.md')
		obeyingExits: 	true
		stdio: 	Stdio
		match: 	a ClapCompositeMatch
		leftovers: 	an OrderedCollection()
		session: 	a WorkingSession
		exitException: 	nil


[
		ClapContext withPragmaCommands
			beObeyingExits;
			setStdio: Stdio;
			arguments: self arguments;
			executeToExit: [ :exit | self handleExit: exit ]
	] in ClapCommandLineHandler>>activate
	Receiver: a ClapCommandLineHandler
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
	Receiver: [
		ClapContext withPragmaCommands
			beObeyingExits;
			setStdio: Stdio;
			arguments[..]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		outerContext: 	ClapCommandLineHandler>>activate
		compiledBlock: 	a CompiledBlock: [
		ClapContext withPragmaCommands
			beObe[..]
		numArgs: 	0
		receiver: 	a ClapCommandLineHandler



--- The full stack ---
FileReference(Object)>>doesNotUnderstand: #referenceTo:
[ :file |
		               fileSystem referenceTo: file ] in MicReferenceChecker>>checkProject:
[:each | each ifNotNil: [newSet add: (aBlock value: each enclosedElement)]] in Set>>collect:
Array(SequenceableCollection)>>do:
Set>>collect:
MicReferenceChecker>>checkProject:
ClapMicrodownBookReferenceCheckerCommand>>execute
[ :args |
			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].
			(self with: args) execute ] in ClapMicrodownBookReferenceCheckerCommand class>>commandSpecification
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
ClapCommand(ClapParameter)>>valueFor:with:
[ super valueFor: aMatch with: arg ] in ClapCommand>>valueFor:with:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
ClapNamedMatch(ClapCompositeMatch)>>matchedSubcommand:ifNone:
ClapCommand>>valueFor:with:
ClapNamedMatch(ClapExpression)>>value:
[ :sub | sub value: arg ] in ClapRoot(ClapCommand)>>valueFor:with:
FullBlockClosure(BlockClosure)>>cull:
[ :cmdMatch | foundBlock cull: cmdMatch ] in ClapCompositeMatch>>matchedSubcommand:ifNone:
FullBlockClosure(BlockClosure)>>cull:
[ :each |
			(aBlock value: each)
				ifTrue: [ ^ foundBlock cull: each ] ] in OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
ClapCompositeMatch>>matchedSubcommand:ifNone:
ClapRoot(ClapCommand)>>valueFor:with:
ClapCompositeMatch(ClapExpression)>>value:
[ :m |
				m value: self.
				self exitSuccess ] in [
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ]
			ifMismatch: [ self noneMatched ]
	] in ClapContext>>executeToExit:
FullBlockClosure(BlockClosure)>>cull:
ClapCompositeMatch(ClapSubExpression)>>ifMatch:ifMismatch:
ClapContext>>ifMatch:ifMismatch:
[
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ]
			ifMismatch: [ self noneMatched ]
	] in ClapContext>>executeToExit:
FullBlockClosure(BlockClosure)>>on:do:
ClapContext>>executeToExit:
[
		ClapContext withPragmaCommands
			beObeyingExits;
			setStdio: Stdio;
			arguments: self arguments;
			executeToExit: [ :exit | self handleExit: exit ]
	] in ClapCommandLineHandler>>activate
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE

4 August 2024 10:38:43.8096 am

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 74b785ff-50d8-0d00-86f4-c64e0df24b96 Jun 28 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 74b785ff-50d8-0d00-86f4-c64e0df24b96 Jun 28 2024
v10.3.0 - Commit: ce151716 - Date: 2024-06-28 10:12:41 +0200

Image: Pharo12.0.0SNAPSHOT [Build information: Pharo-12.0.0+SNAPSHOT.build.1526.sha.404d3af7531f656b5c294762c79011c10bea1ef3 (64 Bit)]

ClapMicrodownBookReferenceCheckerCommand(Object)>>halt
	Receiver: a ClapMicrodownBookReferenceCheckerCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		arguments: 	a ClapNamedMatch
		project: 	nil


ClapMicrodownBookReferenceCheckerCommand>>execute
	Receiver: a ClapMicrodownBookReferenceCheckerCommand
	Arguments and temporary variables: 
		file: 	File @ index.md
		checker: 	nil
	Receiver's instance variables: 
		arguments: 	a ClapNamedMatch
		project: 	nil


[ :args |
			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].
			(self with: args) execute ] in ClapMicrodownBookReferenceCheckerCommand class>>commandSpecification
	Receiver: ClapMicrodownBookReferenceCheckerCommand
	Arguments and temporary variables: 
		args: 	a ClapNamedMatch
	Receiver's instance variables: 
		superclass: 	ClapPillarCommand
		methodDict: 	a MethodDictionary(#execute->ClapMicrodownBookReferenceCheckerC[..]
		format: 	65538
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (execution) - 2 selector(s))
		subclasses: 	nil
		name: 	#ClapMicrodownBookReferenceCheckerCommand
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	7449745
		packageTag: 	a PackageTag(Uncategorized)


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :args |
			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].
			(se[..]
	Arguments and temporary variables: 
		anArg: 	a ClapNamedMatch
	Receiver's instance variables: 
		outerContext: 	ClapMicrodownBookReferenceCheckerCommand class>>commandSpecif[..]
		compiledBlock: 	a CompiledBlock: [ :args |
			args at: #helpFlag ifPresent: [..]
		numArgs: 	1
		receiver: 	ClapMicrodownBookReferenceCheckerCommand


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ :args |
			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].
			(se[..]
	Arguments and temporary variables: 
		firstArg: 	a ClapNamedMatch
		secondArg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		outerContext: 	ClapMicrodownBookReferenceCheckerCommand class>>commandSpecif[..]
		compiledBlock: 	a CompiledBlock: [ :args |
			args at: #helpFlag ifPresent: [..]
		numArgs: 	1
		receiver: 	ClapMicrodownBookReferenceCheckerCommand


ClapCommand(ClapParameter)>>valueFor:with:
	Receiver: a ClapCommand(referenceCheck)
	Arguments and temporary variables: 
		aMatch: 	a ClapNamedMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		identifier: 	#referenceCheck
		canonicalName: 	nil
		description: 	'Check the duplicated or unknown references'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help | help val[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #requestedFile[..]
		positionals: 	an OrderedCollection(a ClapPositional(requestedFile))
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help))
		subcommands: 	an OrderedCollection()


[ super valueFor: aMatch with: arg ] in ClapCommand>>valueFor:with:
	Receiver: a ClapCommand(referenceCheck)
	Arguments and temporary variables: 
		aMatch: 	a ClapNamedMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		identifier: 	#referenceCheck
		canonicalName: 	nil
		description: 	'Check the duplicated or unknown references'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help | help val[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #requestedFile[..]
		positionals: 	an OrderedCollection(a ClapPositional(requestedFile))
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help))
		subcommands: 	an OrderedCollection()


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(a ClapWordMatch)
	Arguments and temporary variables: 
		aBlock: 	[ :child | specification subcommands includes: child specification ]
		foundBlock: 	[ :cmdMatch | foundBlock cull: cmdMatch ]
		exceptionBlock: 	[ super valueFor: aMatch with: arg ]
	Receiver's instance variables: 
		array: 	an Array(a ClapWordMatch nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


ClapNamedMatch(ClapCompositeMatch)>>matchedSubcommand:ifNone:
	Receiver: a ClapNamedMatch
	Arguments and temporary variables: 
		foundBlock: 	[ :sub | sub value: arg ]
		noneBlock: 	[ super valueFor: aMatch with: arg ]
	Receiver's instance variables: 
		specification: 	a ClapCommand(referenceCheck)
		parent: 	a ClapCompositeMatch
		startIndex: 	1
		children: 	an OrderedCollection(a ClapWordMatch)
		keyword: 	'referenceCheck'


ClapCommand>>valueFor:with:
	Receiver: a ClapCommand(referenceCheck)
	Arguments and temporary variables: 
		aMatch: 	a ClapNamedMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		identifier: 	#referenceCheck
		canonicalName: 	nil
		description: 	'Check the duplicated or unknown references'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help | help val[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #requestedFile[..]
		positionals: 	an OrderedCollection(a ClapPositional(requestedFile))
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help))
		subcommands: 	an OrderedCollection()


ClapNamedMatch(ClapExpression)>>value:
	Receiver: a ClapNamedMatch
	Arguments and temporary variables: 
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		specification: 	a ClapCommand(referenceCheck)
		parent: 	a ClapCompositeMatch
		startIndex: 	1
		children: 	an OrderedCollection(a ClapWordMatch)
		keyword: 	'referenceCheck'


[ :sub | sub value: arg ] in ClapRoot(ClapCommand)>>valueFor:with:
	Receiver: a ClapRoot(clap)
	Arguments and temporary variables: 
		aMatch: 	a ClapCompositeMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
		sub: 	a ClapNamedMatch
	Receiver's instance variables: 
		identifier: 	#clap
		canonicalName: 	nil
		description: 	'Entry point for commands implemented with Clap'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help |
				help[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #helpCommand->[..]
		positionals: 	an OrderedCollection()
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help) a ClapFlag(save) a ClapFlag(no[..]
		subcommands: 	an OrderedCollection(a ClapCommand(help) a ClapCommand(image) [..]


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :sub | sub value: arg ]
	Arguments and temporary variables: 
		anArg: 	a ClapNamedMatch
	Receiver's instance variables: 
		outerContext: 	ClapRoot(ClapCommand)>>valueFor:with:
		compiledBlock: 	a CompiledBlock: [ :sub | sub value: arg ]
		numArgs: 	1
		receiver: 	a ClapRoot(clap)


[ :cmdMatch | foundBlock cull: cmdMatch ] in ClapCompositeMatch>>matchedSubcommand:ifNone:
	Receiver: a ClapCompositeMatch
	Arguments and temporary variables: 
		foundBlock: 	[ :sub | sub value: arg ]
		noneBlock: 	[ super valueFor: aMatch with: arg ]
		cmdMatch: 	a ClapNamedMatch
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		parent: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
		startIndex: 	1
		children: 	an OrderedCollection(a ClapNamedMatch)


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :cmdMatch | foundBlock cull: cmdMatch ]
	Arguments and temporary variables: 
		anArg: 	a ClapNamedMatch
	Receiver's instance variables: 
		outerContext: 	ClapCompositeMatch>>matchedSubcommand:ifNone:
		compiledBlock: 	a CompiledBlock: [ :cmdMatch | foundBlock cull: cmdMatch ]
		numArgs: 	1
		receiver: 	a ClapCompositeMatch


[ :each |
			(aBlock value: each)
				ifTrue: [ ^ foundBlock cull: each ] ] in OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(a ClapNamedMatch)
	Arguments and temporary variables: 
		aBlock: 	[ :child | specification subcommands includes: child specification ]
		foundBlock: 	[ :cmdMatch | foundBlock cull: cmdMatch ]
		exceptionBlock: 	[ super valueFor: aMatch with: arg ]
		each: 	a ClapNamedMatch
	Receiver's instance variables: 
		array: 	an Array(a ClapNamedMatch nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


OrderedCollection>>do:
	Receiver: an OrderedCollection(a ClapNamedMatch)
	Arguments and temporary variables: 
		aBlock: 	[ :each |
			(aBlock value: each)
				ifTrue: [ ^ foundBlock cull: [..]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a ClapNamedMatch nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(a ClapNamedMatch)
	Arguments and temporary variables: 
		aBlock: 	[ :child | specification subcommands includes: child specification ]
		foundBlock: 	[ :cmdMatch | foundBlock cull: cmdMatch ]
		exceptionBlock: 	[ super valueFor: aMatch with: arg ]
	Receiver's instance variables: 
		array: 	an Array(a ClapNamedMatch nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


ClapCompositeMatch>>matchedSubcommand:ifNone:
	Receiver: a ClapCompositeMatch
	Arguments and temporary variables: 
		foundBlock: 	[ :sub | sub value: arg ]
		noneBlock: 	[ super valueFor: aMatch with: arg ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		parent: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
		startIndex: 	1
		children: 	an OrderedCollection(a ClapNamedMatch)


ClapRoot(ClapCommand)>>valueFor:with:
	Receiver: a ClapRoot(clap)
	Arguments and temporary variables: 
		aMatch: 	a ClapCompositeMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		identifier: 	#clap
		canonicalName: 	nil
		description: 	'Entry point for commands implemented with Clap'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help |
				help[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #helpCommand->[..]
		positionals: 	an OrderedCollection()
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help) a ClapFlag(save) a ClapFlag(no[..]
		subcommands: 	an OrderedCollection(a ClapCommand(help) a ClapCommand(image) [..]


ClapCompositeMatch(ClapExpression)>>value:
	Receiver: a ClapCompositeMatch
	Arguments and temporary variables: 
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		parent: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
		startIndex: 	1
		children: 	an OrderedCollection(a ClapNamedMatch)


[ :m |
				m value: self.
				self exitSuccess ] in [
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ]
			ifMismatch: [ self noneMatched ]
	] in ClapContext>>executeToExit:
	Receiver: a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Arguments and temporary variables: 
		exitBlock: 	[ :exit | self handleExit: exit ]
		m: 	a ClapCompositeMatch
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		arguments: 	an OrderedCollection('referenceCheck' 'index.md')
		obeyingExits: 	true
		stdio: 	Stdio
		match: 	a ClapCompositeMatch
		leftovers: 	an OrderedCollection()
		session: 	a WorkingSession
		exitException: 	nil


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :m |
				m value: self.
				self exitSuccess ]
	Arguments and temporary variables: 
		anArg: 	a ClapCompositeMatch
	Receiver's instance variables: 
		outerContext: 	[
		self rememberSession;
			ifMatch: [ :m |
				m value: sel[..]
		compiledBlock: 	a CompiledBlock: [ :m |
				m value: self.
				self exitSucc[..]
		numArgs: 	1
		receiver: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))


ClapCompositeMatch(ClapSubExpression)>>ifMatch:ifMismatch:
	Receiver: a ClapCompositeMatch
	Arguments and temporary variables: 
		matchBlock: 	[ :m |
				m value: self.
				self exitSuccess ]
		mismatchBlock: 	[ self noneMatched ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		parent: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
		startIndex: 	1
		children: 	an OrderedCollection(a ClapNamedMatch)


ClapContext>>ifMatch:ifMismatch:
	Receiver: a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Arguments and temporary variables: 
		matchBlock: 	[ :m |
				m value: self.
				self exitSuccess ]
		failBlock: 	[ self noneMatched ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		arguments: 	an OrderedCollection('referenceCheck' 'index.md')
		obeyingExits: 	true
		stdio: 	Stdio
		match: 	a ClapCompositeMatch
		leftovers: 	an OrderedCollection()
		session: 	a WorkingSession
		exitException: 	nil


[
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ]
			ifMismatch: [ self noneMatched ]
	] in ClapContext>>executeToExit:
	Receiver: a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Arguments and temporary variables: 
		exitBlock: 	[ :exit | self handleExit: exit ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		arguments: 	an OrderedCollection('referenceCheck' 'index.md')
		obeyingExits: 	true
		stdio: 	Stdio
		match: 	a ClapCompositeMatch
		leftovers: 	an OrderedCollection()
		session: 	a WorkingSession
		exitException: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ][..]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exception |
			exitException := exception.
			exitBlock v[..]
	Receiver's instance variables: 
		outerContext: 	ClapContext>>executeToExit:
		compiledBlock: 	a CompiledBlock: [
		self rememberSession;
			ifMatch: [ :m [..]
		numArgs: 	0
		receiver: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))


ClapContext>>executeToExit:
	Receiver: a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Arguments and temporary variables: 
		exitBlock: 	[ :exit | self handleExit: exit ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		arguments: 	an OrderedCollection('referenceCheck' 'index.md')
		obeyingExits: 	true
		stdio: 	Stdio
		match: 	a ClapCompositeMatch
		leftovers: 	an OrderedCollection()
		session: 	a WorkingSession
		exitException: 	nil


[
		ClapContext withPragmaCommands
			beObeyingExits;
			setStdio: Stdio;
			arguments: self arguments;
			executeToExit: [ :exit | self handleExit: exit ]
	] in ClapCommandLineHandler>>activate
	Receiver: a ClapCommandLineHandler
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
	Receiver: [
		ClapContext withPragmaCommands
			beObeyingExits;
			setStdio: Stdio;
			arguments[..]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		outerContext: 	ClapCommandLineHandler>>activate
		compiledBlock: 	a CompiledBlock: [
		ClapContext withPragmaCommands
			beObe[..]
		numArgs: 	0
		receiver: 	a ClapCommandLineHandler



--- The full stack ---
ClapMicrodownBookReferenceCheckerCommand(Object)>>halt
ClapMicrodownBookReferenceCheckerCommand>>execute
[ :args |
			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].
			(self with: args) execute ] in ClapMicrodownBookReferenceCheckerCommand class>>commandSpecification
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
ClapCommand(ClapParameter)>>valueFor:with:
[ super valueFor: aMatch with: arg ] in ClapCommand>>valueFor:with:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
ClapNamedMatch(ClapCompositeMatch)>>matchedSubcommand:ifNone:
ClapCommand>>valueFor:with:
ClapNamedMatch(ClapExpression)>>value:
[ :sub | sub value: arg ] in ClapRoot(ClapCommand)>>valueFor:with:
FullBlockClosure(BlockClosure)>>cull:
[ :cmdMatch | foundBlock cull: cmdMatch ] in ClapCompositeMatch>>matchedSubcommand:ifNone:
FullBlockClosure(BlockClosure)>>cull:
[ :each |
			(aBlock value: each)
				ifTrue: [ ^ foundBlock cull: each ] ] in OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
ClapCompositeMatch>>matchedSubcommand:ifNone:
ClapRoot(ClapCommand)>>valueFor:with:
ClapCompositeMatch(ClapExpression)>>value:
[ :m |
				m value: self.
				self exitSuccess ] in [
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ]
			ifMismatch: [ self noneMatched ]
	] in ClapContext>>executeToExit:
FullBlockClosure(BlockClosure)>>cull:
ClapCompositeMatch(ClapSubExpression)>>ifMatch:ifMismatch:
ClapContext>>ifMatch:ifMismatch:
[
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ]
			ifMismatch: [ self noneMatched ]
	] in ClapContext>>executeToExit:
FullBlockClosure(BlockClosure)>>on:do:
ClapContext>>executeToExit:
[
		ClapContext withPragmaCommands
			beObeyingExits;
			setStdio: Stdio;
			arguments: self arguments;
			executeToExit: [ :exit | self handleExit: exit ]
	] in ClapCommandLineHandler>>activate
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE

4 August 2024 10:40:47.302574 am

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 74b785ff-50d8-0d00-86f4-c64e0df24b96 Jun 28 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 74b785ff-50d8-0d00-86f4-c64e0df24b96 Jun 28 2024
v10.3.0 - Commit: ce151716 - Date: 2024-06-28 10:12:41 +0200

Image: Pharo12.0.0SNAPSHOT [Build information: Pharo-12.0.0+SNAPSHOT.build.1526.sha.404d3af7531f656b5c294762c79011c10bea1ef3 (64 Bit)]

ClapMicrodownBookReferenceCheckerCommand(Object)>>halt
	Receiver: a ClapMicrodownBookReferenceCheckerCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		arguments: 	a ClapNamedMatch
		project: 	nil


ClapMicrodownBookReferenceCheckerCommand>>execute
	Receiver: a ClapMicrodownBookReferenceCheckerCommand
	Arguments and temporary variables: 
		file: 	File @ index.md
		checker: 	nil
	Receiver's instance variables: 
		arguments: 	a ClapNamedMatch
		project: 	nil


[ :args |
			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].
			(self with: args) execute ] in ClapMicrodownBookReferenceCheckerCommand class>>commandSpecification
	Receiver: ClapMicrodownBookReferenceCheckerCommand
	Arguments and temporary variables: 
		args: 	a ClapNamedMatch
	Receiver's instance variables: 
		superclass: 	ClapPillarCommand
		methodDict: 	a MethodDictionary(#execute->ClapMicrodownBookReferenceCheckerC[..]
		format: 	65538
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (execution) - 2 selector(s))
		subclasses: 	nil
		name: 	#ClapMicrodownBookReferenceCheckerCommand
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	7449745
		packageTag: 	a PackageTag(Uncategorized)


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :args |
			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].
			(se[..]
	Arguments and temporary variables: 
		anArg: 	a ClapNamedMatch
	Receiver's instance variables: 
		outerContext: 	ClapMicrodownBookReferenceCheckerCommand class>>commandSpecif[..]
		compiledBlock: 	a CompiledBlock: [ :args |
			args at: #helpFlag ifPresent: [..]
		numArgs: 	1
		receiver: 	ClapMicrodownBookReferenceCheckerCommand


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ :args |
			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].
			(se[..]
	Arguments and temporary variables: 
		firstArg: 	a ClapNamedMatch
		secondArg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		outerContext: 	ClapMicrodownBookReferenceCheckerCommand class>>commandSpecif[..]
		compiledBlock: 	a CompiledBlock: [ :args |
			args at: #helpFlag ifPresent: [..]
		numArgs: 	1
		receiver: 	ClapMicrodownBookReferenceCheckerCommand


ClapCommand(ClapParameter)>>valueFor:with:
	Receiver: a ClapCommand(referenceCheck)
	Arguments and temporary variables: 
		aMatch: 	a ClapNamedMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		identifier: 	#referenceCheck
		canonicalName: 	nil
		description: 	'Check the duplicated or unknown references'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help | help val[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #requestedFile[..]
		positionals: 	an OrderedCollection(a ClapPositional(requestedFile))
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help))
		subcommands: 	an OrderedCollection()


[ super valueFor: aMatch with: arg ] in ClapCommand>>valueFor:with:
	Receiver: a ClapCommand(referenceCheck)
	Arguments and temporary variables: 
		aMatch: 	a ClapNamedMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		identifier: 	#referenceCheck
		canonicalName: 	nil
		description: 	'Check the duplicated or unknown references'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help | help val[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #requestedFile[..]
		positionals: 	an OrderedCollection(a ClapPositional(requestedFile))
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help))
		subcommands: 	an OrderedCollection()


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(a ClapWordMatch)
	Arguments and temporary variables: 
		aBlock: 	[ :child | specification subcommands includes: child specification ]
		foundBlock: 	[ :cmdMatch | foundBlock cull: cmdMatch ]
		exceptionBlock: 	[ super valueFor: aMatch with: arg ]
	Receiver's instance variables: 
		array: 	an Array(a ClapWordMatch nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


ClapNamedMatch(ClapCompositeMatch)>>matchedSubcommand:ifNone:
	Receiver: a ClapNamedMatch
	Arguments and temporary variables: 
		foundBlock: 	[ :sub | sub value: arg ]
		noneBlock: 	[ super valueFor: aMatch with: arg ]
	Receiver's instance variables: 
		specification: 	a ClapCommand(referenceCheck)
		parent: 	a ClapCompositeMatch
		startIndex: 	1
		children: 	an OrderedCollection(a ClapWordMatch)
		keyword: 	'referenceCheck'


ClapCommand>>valueFor:with:
	Receiver: a ClapCommand(referenceCheck)
	Arguments and temporary variables: 
		aMatch: 	a ClapNamedMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		identifier: 	#referenceCheck
		canonicalName: 	nil
		description: 	'Check the duplicated or unknown references'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help | help val[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #requestedFile[..]
		positionals: 	an OrderedCollection(a ClapPositional(requestedFile))
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help))
		subcommands: 	an OrderedCollection()


ClapNamedMatch(ClapExpression)>>value:
	Receiver: a ClapNamedMatch
	Arguments and temporary variables: 
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		specification: 	a ClapCommand(referenceCheck)
		parent: 	a ClapCompositeMatch
		startIndex: 	1
		children: 	an OrderedCollection(a ClapWordMatch)
		keyword: 	'referenceCheck'


[ :sub | sub value: arg ] in ClapRoot(ClapCommand)>>valueFor:with:
	Receiver: a ClapRoot(clap)
	Arguments and temporary variables: 
		aMatch: 	a ClapCompositeMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
		sub: 	a ClapNamedMatch
	Receiver's instance variables: 
		identifier: 	#clap
		canonicalName: 	nil
		description: 	'Entry point for commands implemented with Clap'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help |
				help[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #helpCommand->[..]
		positionals: 	an OrderedCollection()
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help) a ClapFlag(save) a ClapFlag(no[..]
		subcommands: 	an OrderedCollection(a ClapCommand(help) a ClapCommand(image) [..]


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :sub | sub value: arg ]
	Arguments and temporary variables: 
		anArg: 	a ClapNamedMatch
	Receiver's instance variables: 
		outerContext: 	ClapRoot(ClapCommand)>>valueFor:with:
		compiledBlock: 	a CompiledBlock: [ :sub | sub value: arg ]
		numArgs: 	1
		receiver: 	a ClapRoot(clap)


[ :cmdMatch | foundBlock cull: cmdMatch ] in ClapCompositeMatch>>matchedSubcommand:ifNone:
	Receiver: a ClapCompositeMatch
	Arguments and temporary variables: 
		foundBlock: 	[ :sub | sub value: arg ]
		noneBlock: 	[ super valueFor: aMatch with: arg ]
		cmdMatch: 	a ClapNamedMatch
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		parent: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
		startIndex: 	1
		children: 	an OrderedCollection(a ClapNamedMatch)


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :cmdMatch | foundBlock cull: cmdMatch ]
	Arguments and temporary variables: 
		anArg: 	a ClapNamedMatch
	Receiver's instance variables: 
		outerContext: 	ClapCompositeMatch>>matchedSubcommand:ifNone:
		compiledBlock: 	a CompiledBlock: [ :cmdMatch | foundBlock cull: cmdMatch ]
		numArgs: 	1
		receiver: 	a ClapCompositeMatch


[ :each |
			(aBlock value: each)
				ifTrue: [ ^ foundBlock cull: each ] ] in OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(a ClapNamedMatch)
	Arguments and temporary variables: 
		aBlock: 	[ :child | specification subcommands includes: child specification ]
		foundBlock: 	[ :cmdMatch | foundBlock cull: cmdMatch ]
		exceptionBlock: 	[ super valueFor: aMatch with: arg ]
		each: 	a ClapNamedMatch
	Receiver's instance variables: 
		array: 	an Array(a ClapNamedMatch nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


OrderedCollection>>do:
	Receiver: an OrderedCollection(a ClapNamedMatch)
	Arguments and temporary variables: 
		aBlock: 	[ :each |
			(aBlock value: each)
				ifTrue: [ ^ foundBlock cull: [..]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a ClapNamedMatch nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(a ClapNamedMatch)
	Arguments and temporary variables: 
		aBlock: 	[ :child | specification subcommands includes: child specification ]
		foundBlock: 	[ :cmdMatch | foundBlock cull: cmdMatch ]
		exceptionBlock: 	[ super valueFor: aMatch with: arg ]
	Receiver's instance variables: 
		array: 	an Array(a ClapNamedMatch nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


ClapCompositeMatch>>matchedSubcommand:ifNone:
	Receiver: a ClapCompositeMatch
	Arguments and temporary variables: 
		foundBlock: 	[ :sub | sub value: arg ]
		noneBlock: 	[ super valueFor: aMatch with: arg ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		parent: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
		startIndex: 	1
		children: 	an OrderedCollection(a ClapNamedMatch)


ClapRoot(ClapCommand)>>valueFor:with:
	Receiver: a ClapRoot(clap)
	Arguments and temporary variables: 
		aMatch: 	a ClapCompositeMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		identifier: 	#clap
		canonicalName: 	nil
		description: 	'Entry point for commands implemented with Clap'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help |
				help[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #helpCommand->[..]
		positionals: 	an OrderedCollection()
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help) a ClapFlag(save) a ClapFlag(no[..]
		subcommands: 	an OrderedCollection(a ClapCommand(help) a ClapCommand(image) [..]


ClapCompositeMatch(ClapExpression)>>value:
	Receiver: a ClapCompositeMatch
	Arguments and temporary variables: 
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		parent: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
		startIndex: 	1
		children: 	an OrderedCollection(a ClapNamedMatch)


[ :m |
				m value: self.
				self exitSuccess ] in [
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ]
			ifMismatch: [ self noneMatched ]
	] in ClapContext>>executeToExit:
	Receiver: a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Arguments and temporary variables: 
		exitBlock: 	[ :exit | self handleExit: exit ]
		m: 	a ClapCompositeMatch
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		arguments: 	an OrderedCollection('referenceCheck' 'index.md')
		obeyingExits: 	true
		stdio: 	Stdio
		match: 	a ClapCompositeMatch
		leftovers: 	an OrderedCollection()
		session: 	a WorkingSession
		exitException: 	nil


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :m |
				m value: self.
				self exitSuccess ]
	Arguments and temporary variables: 
		anArg: 	a ClapCompositeMatch
	Receiver's instance variables: 
		outerContext: 	[
		self rememberSession;
			ifMatch: [ :m |
				m value: sel[..]
		compiledBlock: 	a CompiledBlock: [ :m |
				m value: self.
				self exitSucc[..]
		numArgs: 	1
		receiver: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))


ClapCompositeMatch(ClapSubExpression)>>ifMatch:ifMismatch:
	Receiver: a ClapCompositeMatch
	Arguments and temporary variables: 
		matchBlock: 	[ :m |
				m value: self.
				self exitSuccess ]
		mismatchBlock: 	[ self noneMatched ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		parent: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
		startIndex: 	1
		children: 	an OrderedCollection(a ClapNamedMatch)


ClapContext>>ifMatch:ifMismatch:
	Receiver: a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Arguments and temporary variables: 
		matchBlock: 	[ :m |
				m value: self.
				self exitSuccess ]
		failBlock: 	[ self noneMatched ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		arguments: 	an OrderedCollection('referenceCheck' 'index.md')
		obeyingExits: 	true
		stdio: 	Stdio
		match: 	a ClapCompositeMatch
		leftovers: 	an OrderedCollection()
		session: 	a WorkingSession
		exitException: 	nil


[
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ]
			ifMismatch: [ self noneMatched ]
	] in ClapContext>>executeToExit:
	Receiver: a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Arguments and temporary variables: 
		exitBlock: 	[ :exit | self handleExit: exit ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		arguments: 	an OrderedCollection('referenceCheck' 'index.md')
		obeyingExits: 	true
		stdio: 	Stdio
		match: 	a ClapCompositeMatch
		leftovers: 	an OrderedCollection()
		session: 	a WorkingSession
		exitException: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ][..]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exception |
			exitException := exception.
			exitBlock v[..]
	Receiver's instance variables: 
		outerContext: 	ClapContext>>executeToExit:
		compiledBlock: 	a CompiledBlock: [
		self rememberSession;
			ifMatch: [ :m [..]
		numArgs: 	0
		receiver: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))


ClapContext>>executeToExit:
	Receiver: a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Arguments and temporary variables: 
		exitBlock: 	[ :exit | self handleExit: exit ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		arguments: 	an OrderedCollection('referenceCheck' 'index.md')
		obeyingExits: 	true
		stdio: 	Stdio
		match: 	a ClapCompositeMatch
		leftovers: 	an OrderedCollection()
		session: 	a WorkingSession
		exitException: 	nil


[
		ClapContext withPragmaCommands
			beObeyingExits;
			setStdio: Stdio;
			arguments: self arguments;
			executeToExit: [ :exit | self handleExit: exit ]
	] in ClapCommandLineHandler>>activate
	Receiver: a ClapCommandLineHandler
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
	Receiver: [
		ClapContext withPragmaCommands
			beObeyingExits;
			setStdio: Stdio;
			arguments[..]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		outerContext: 	ClapCommandLineHandler>>activate
		compiledBlock: 	a CompiledBlock: [
		ClapContext withPragmaCommands
			beObe[..]
		numArgs: 	0
		receiver: 	a ClapCommandLineHandler



--- The full stack ---
ClapMicrodownBookReferenceCheckerCommand(Object)>>halt
ClapMicrodownBookReferenceCheckerCommand>>execute
[ :args |
			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].
			(self with: args) execute ] in ClapMicrodownBookReferenceCheckerCommand class>>commandSpecification
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
ClapCommand(ClapParameter)>>valueFor:with:
[ super valueFor: aMatch with: arg ] in ClapCommand>>valueFor:with:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
ClapNamedMatch(ClapCompositeMatch)>>matchedSubcommand:ifNone:
ClapCommand>>valueFor:with:
ClapNamedMatch(ClapExpression)>>value:
[ :sub | sub value: arg ] in ClapRoot(ClapCommand)>>valueFor:with:
FullBlockClosure(BlockClosure)>>cull:
[ :cmdMatch | foundBlock cull: cmdMatch ] in ClapCompositeMatch>>matchedSubcommand:ifNone:
FullBlockClosure(BlockClosure)>>cull:
[ :each |
			(aBlock value: each)
				ifTrue: [ ^ foundBlock cull: each ] ] in OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
ClapCompositeMatch>>matchedSubcommand:ifNone:
ClapRoot(ClapCommand)>>valueFor:with:
ClapCompositeMatch(ClapExpression)>>value:
[ :m |
				m value: self.
				self exitSuccess ] in [
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ]
			ifMismatch: [ self noneMatched ]
	] in ClapContext>>executeToExit:
FullBlockClosure(BlockClosure)>>cull:
ClapCompositeMatch(ClapSubExpression)>>ifMatch:ifMismatch:
ClapContext>>ifMatch:ifMismatch:
[
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ]
			ifMismatch: [ self noneMatched ]
	] in ClapContext>>executeToExit:
FullBlockClosure(BlockClosure)>>on:do:
ClapContext>>executeToExit:
[
		ClapContext withPragmaCommands
			beObeyingExits;
			setStdio: Stdio;
			arguments: self arguments;
			executeToExit: [ :exit | self handleExit: exit ]
	] in ClapCommandLineHandler>>activate
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Message not understood: FileReference >> #referenceTo:
4 August 2024 10:40:53.042735 am

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 74b785ff-50d8-0d00-86f4-c64e0df24b96 Jun 28 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 74b785ff-50d8-0d00-86f4-c64e0df24b96 Jun 28 2024
v10.3.0 - Commit: ce151716 - Date: 2024-06-28 10:12:41 +0200

Image: Pharo12.0.0SNAPSHOT [Build information: Pharo-12.0.0+SNAPSHOT.build.1526.sha.404d3af7531f656b5c294762c79011c10bea1ef3 (64 Bit)]

FileReference(Object)>>doesNotUnderstand: #referenceTo:
	Receiver: File @ /Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/PharoBooks2/Booklet-Gra[..]
	Arguments and temporary variables: 
		aMessage: 	referenceTo: '/Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Wri[..]
		exception: 	Instance of FileReference did not understand #referenceTo:
		resumeValue: 	nil
	Receiver's instance variables: 
		path: 	Path / 'Users' / 'ducasse' / 'Workspace' / 'FirstCircle' / 'MyBooks' [..]
		filesystem: 	a FileSystem


[ :file |
		               fileSystem referenceTo: file ] in MicReferenceChecker>>checkProject:
	Receiver: a MicReferenceChecker
	Arguments and temporary variables: 
		aFileReference: 	File @ index.md
		mainMic: 	a MicRootBlock
		collector: 	a MicFileCollector
		listOfFiles: 	nil
		file: 	'/Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/PharoBooks2/[..]
	Receiver's instance variables: 
		references: 	an OrderedCollection()
		anchors: 	an OrderedCollection()
		duplicatedAnchors: 	an OrderedCollection()
		results: 	an OrderedCollection()
		fileSystem: 	File @ /Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/[..]


[:each | each ifNotNil: [newSet add: (aBlock value: each enclosedElement)]] in Set>>collect:
	Receiver: a Set('/Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/PharoBooks2/Booklet-Gra[..]
	Arguments and temporary variables: 
		aBlock: 	[ :file |
		               fileSystem referenceTo: file ]
		newSet: 	a Set()
		each: 	'/Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/PharoBooks2/[..]
	Receiver's instance variables: 
		tally: 	20
		array: 	#(nil nil nil nil nil '/Users/ducasse/Workspace/FirstCircle/MyBooks/[..]


Array(SequenceableCollection)>>do:
	Receiver: #(nil nil nil nil nil '/Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/PharoBo[..]
	Arguments and temporary variables: 
		aBlock: 	[:each | each ifNotNil: [newSet add: (aBlock value: each enclosedEl[..]
		index: 	6
	Receiver's instance variables: 
#(nil nil nil nil nil '/Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/PharoBo[..]

Set>>collect:
	Receiver: a Set('/Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/PharoBooks2/Booklet-Gra[..]
	Arguments and temporary variables: 
		aBlock: 	[ :file |
		               fileSystem referenceTo: file ]
		newSet: 	a Set()
	Receiver's instance variables: 
		tally: 	20
		array: 	#(nil nil nil nil nil '/Users/ducasse/Workspace/FirstCircle/MyBooks/[..]


MicReferenceChecker>>checkProject:
	Receiver: a MicReferenceChecker
	Arguments and temporary variables: 
		aFileReference: 	File @ index.md
		mainMic: 	a MicRootBlock
		collector: 	a MicFileCollector
		listOfFiles: 	nil
	Receiver's instance variables: 
		references: 	an OrderedCollection()
		anchors: 	an OrderedCollection()
		duplicatedAnchors: 	an OrderedCollection()
		results: 	an OrderedCollection()
		fileSystem: 	File @ /Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/[..]


ClapMicrodownBookReferenceCheckerCommand>>execute
	Receiver: a ClapMicrodownBookReferenceCheckerCommand
	Arguments and temporary variables: 
		file: 	File @ index.md
		checker: 	a MicReferenceChecker
	Receiver's instance variables: 
		arguments: 	a ClapNamedMatch
		project: 	nil


[ :args |
			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].
			(self with: args) execute ] in ClapMicrodownBookReferenceCheckerCommand class>>commandSpecification
	Receiver: ClapMicrodownBookReferenceCheckerCommand
	Arguments and temporary variables: 
		args: 	a ClapNamedMatch
	Receiver's instance variables: 
		superclass: 	ClapPillarCommand
		methodDict: 	a MethodDictionary(#execute->ClapMicrodownBookReferenceCheckerC[..]
		format: 	65538
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (execution) - 2 selector(s))
		subclasses: 	nil
		name: 	#ClapMicrodownBookReferenceCheckerCommand
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	7449745
		packageTag: 	a PackageTag(Uncategorized)


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :args |
			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].
			(se[..]
	Arguments and temporary variables: 
		anArg: 	a ClapNamedMatch
	Receiver's instance variables: 
		outerContext: 	ClapMicrodownBookReferenceCheckerCommand class>>commandSpecif[..]
		compiledBlock: 	a CompiledBlock: [ :args |
			args at: #helpFlag ifPresent: [..]
		numArgs: 	1
		receiver: 	ClapMicrodownBookReferenceCheckerCommand


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ :args |
			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].
			(se[..]
	Arguments and temporary variables: 
		firstArg: 	a ClapNamedMatch
		secondArg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		outerContext: 	ClapMicrodownBookReferenceCheckerCommand class>>commandSpecif[..]
		compiledBlock: 	a CompiledBlock: [ :args |
			args at: #helpFlag ifPresent: [..]
		numArgs: 	1
		receiver: 	ClapMicrodownBookReferenceCheckerCommand


ClapCommand(ClapParameter)>>valueFor:with:
	Receiver: a ClapCommand(referenceCheck)
	Arguments and temporary variables: 
		aMatch: 	a ClapNamedMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		identifier: 	#referenceCheck
		canonicalName: 	nil
		description: 	'Check the duplicated or unknown references'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help | help val[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #requestedFile[..]
		positionals: 	an OrderedCollection(a ClapPositional(requestedFile))
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help))
		subcommands: 	an OrderedCollection()


[ super valueFor: aMatch with: arg ] in ClapCommand>>valueFor:with:
	Receiver: a ClapCommand(referenceCheck)
	Arguments and temporary variables: 
		aMatch: 	a ClapNamedMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		identifier: 	#referenceCheck
		canonicalName: 	nil
		description: 	'Check the duplicated or unknown references'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help | help val[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #requestedFile[..]
		positionals: 	an OrderedCollection(a ClapPositional(requestedFile))
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help))
		subcommands: 	an OrderedCollection()


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(a ClapWordMatch)
	Arguments and temporary variables: 
		aBlock: 	[ :child | specification subcommands includes: child specification ]
		foundBlock: 	[ :cmdMatch | foundBlock cull: cmdMatch ]
		exceptionBlock: 	[ super valueFor: aMatch with: arg ]
	Receiver's instance variables: 
		array: 	an Array(a ClapWordMatch nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


ClapNamedMatch(ClapCompositeMatch)>>matchedSubcommand:ifNone:
	Receiver: a ClapNamedMatch
	Arguments and temporary variables: 
		foundBlock: 	[ :sub | sub value: arg ]
		noneBlock: 	[ super valueFor: aMatch with: arg ]
	Receiver's instance variables: 
		specification: 	a ClapCommand(referenceCheck)
		parent: 	a ClapCompositeMatch
		startIndex: 	1
		children: 	an OrderedCollection(a ClapWordMatch)
		keyword: 	'referenceCheck'


ClapCommand>>valueFor:with:
	Receiver: a ClapCommand(referenceCheck)
	Arguments and temporary variables: 
		aMatch: 	a ClapNamedMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		identifier: 	#referenceCheck
		canonicalName: 	nil
		description: 	'Check the duplicated or unknown references'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help | help val[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #requestedFile[..]
		positionals: 	an OrderedCollection(a ClapPositional(requestedFile))
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help))
		subcommands: 	an OrderedCollection()


ClapNamedMatch(ClapExpression)>>value:
	Receiver: a ClapNamedMatch
	Arguments and temporary variables: 
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		specification: 	a ClapCommand(referenceCheck)
		parent: 	a ClapCompositeMatch
		startIndex: 	1
		children: 	an OrderedCollection(a ClapWordMatch)
		keyword: 	'referenceCheck'


[ :sub | sub value: arg ] in ClapRoot(ClapCommand)>>valueFor:with:
	Receiver: a ClapRoot(clap)
	Arguments and temporary variables: 
		aMatch: 	a ClapCompositeMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
		sub: 	a ClapNamedMatch
	Receiver's instance variables: 
		identifier: 	#clap
		canonicalName: 	nil
		description: 	'Entry point for commands implemented with Clap'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help |
				help[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #helpCommand->[..]
		positionals: 	an OrderedCollection()
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help) a ClapFlag(save) a ClapFlag(no[..]
		subcommands: 	an OrderedCollection(a ClapCommand(help) a ClapCommand(image) [..]


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :sub | sub value: arg ]
	Arguments and temporary variables: 
		anArg: 	a ClapNamedMatch
	Receiver's instance variables: 
		outerContext: 	ClapRoot(ClapCommand)>>valueFor:with:
		compiledBlock: 	a CompiledBlock: [ :sub | sub value: arg ]
		numArgs: 	1
		receiver: 	a ClapRoot(clap)


[ :cmdMatch | foundBlock cull: cmdMatch ] in ClapCompositeMatch>>matchedSubcommand:ifNone:
	Receiver: a ClapCompositeMatch
	Arguments and temporary variables: 
		foundBlock: 	[ :sub | sub value: arg ]
		noneBlock: 	[ super valueFor: aMatch with: arg ]
		cmdMatch: 	a ClapNamedMatch
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		parent: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
		startIndex: 	1
		children: 	an OrderedCollection(a ClapNamedMatch)


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :cmdMatch | foundBlock cull: cmdMatch ]
	Arguments and temporary variables: 
		anArg: 	a ClapNamedMatch
	Receiver's instance variables: 
		outerContext: 	ClapCompositeMatch>>matchedSubcommand:ifNone:
		compiledBlock: 	a CompiledBlock: [ :cmdMatch | foundBlock cull: cmdMatch ]
		numArgs: 	1
		receiver: 	a ClapCompositeMatch


[ :each |
			(aBlock value: each)
				ifTrue: [ ^ foundBlock cull: each ] ] in OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(a ClapNamedMatch)
	Arguments and temporary variables: 
		aBlock: 	[ :child | specification subcommands includes: child specification ]
		foundBlock: 	[ :cmdMatch | foundBlock cull: cmdMatch ]
		exceptionBlock: 	[ super valueFor: aMatch with: arg ]
		each: 	a ClapNamedMatch
	Receiver's instance variables: 
		array: 	an Array(a ClapNamedMatch nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


OrderedCollection>>do:
	Receiver: an OrderedCollection(a ClapNamedMatch)
	Arguments and temporary variables: 
		aBlock: 	[ :each |
			(aBlock value: each)
				ifTrue: [ ^ foundBlock cull: [..]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a ClapNamedMatch nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(a ClapNamedMatch)
	Arguments and temporary variables: 
		aBlock: 	[ :child | specification subcommands includes: child specification ]
		foundBlock: 	[ :cmdMatch | foundBlock cull: cmdMatch ]
		exceptionBlock: 	[ super valueFor: aMatch with: arg ]
	Receiver's instance variables: 
		array: 	an Array(a ClapNamedMatch nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


ClapCompositeMatch>>matchedSubcommand:ifNone:
	Receiver: a ClapCompositeMatch
	Arguments and temporary variables: 
		foundBlock: 	[ :sub | sub value: arg ]
		noneBlock: 	[ super valueFor: aMatch with: arg ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		parent: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
		startIndex: 	1
		children: 	an OrderedCollection(a ClapNamedMatch)


ClapRoot(ClapCommand)>>valueFor:with:
	Receiver: a ClapRoot(clap)
	Arguments and temporary variables: 
		aMatch: 	a ClapCompositeMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		identifier: 	#clap
		canonicalName: 	nil
		description: 	'Entry point for commands implemented with Clap'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help |
				help[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #helpCommand->[..]
		positionals: 	an OrderedCollection()
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help) a ClapFlag(save) a ClapFlag(no[..]
		subcommands: 	an OrderedCollection(a ClapCommand(help) a ClapCommand(image) [..]


ClapCompositeMatch(ClapExpression)>>value:
	Receiver: a ClapCompositeMatch
	Arguments and temporary variables: 
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		parent: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
		startIndex: 	1
		children: 	an OrderedCollection(a ClapNamedMatch)


[ :m |
				m value: self.
				self exitSuccess ] in [
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ]
			ifMismatch: [ self noneMatched ]
	] in ClapContext>>executeToExit:
	Receiver: a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Arguments and temporary variables: 
		exitBlock: 	[ :exit | self handleExit: exit ]
		m: 	a ClapCompositeMatch
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		arguments: 	an OrderedCollection('referenceCheck' 'index.md')
		obeyingExits: 	true
		stdio: 	Stdio
		match: 	a ClapCompositeMatch
		leftovers: 	an OrderedCollection()
		session: 	a WorkingSession
		exitException: 	nil


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :m |
				m value: self.
				self exitSuccess ]
	Arguments and temporary variables: 
		anArg: 	a ClapCompositeMatch
	Receiver's instance variables: 
		outerContext: 	[
		self rememberSession;
			ifMatch: [ :m |
				m value: sel[..]
		compiledBlock: 	a CompiledBlock: [ :m |
				m value: self.
				self exitSucc[..]
		numArgs: 	1
		receiver: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))


ClapCompositeMatch(ClapSubExpression)>>ifMatch:ifMismatch:
	Receiver: a ClapCompositeMatch
	Arguments and temporary variables: 
		matchBlock: 	[ :m |
				m value: self.
				self exitSuccess ]
		mismatchBlock: 	[ self noneMatched ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		parent: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
		startIndex: 	1
		children: 	an OrderedCollection(a ClapNamedMatch)


ClapContext>>ifMatch:ifMismatch:
	Receiver: a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Arguments and temporary variables: 
		matchBlock: 	[ :m |
				m value: self.
				self exitSuccess ]
		failBlock: 	[ self noneMatched ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		arguments: 	an OrderedCollection('referenceCheck' 'index.md')
		obeyingExits: 	true
		stdio: 	Stdio
		match: 	a ClapCompositeMatch
		leftovers: 	an OrderedCollection()
		session: 	a WorkingSession
		exitException: 	nil


[
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ]
			ifMismatch: [ self noneMatched ]
	] in ClapContext>>executeToExit:
	Receiver: a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Arguments and temporary variables: 
		exitBlock: 	[ :exit | self handleExit: exit ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		arguments: 	an OrderedCollection('referenceCheck' 'index.md')
		obeyingExits: 	true
		stdio: 	Stdio
		match: 	a ClapCompositeMatch
		leftovers: 	an OrderedCollection()
		session: 	a WorkingSession
		exitException: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ][..]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exception |
			exitException := exception.
			exitBlock v[..]
	Receiver's instance variables: 
		outerContext: 	ClapContext>>executeToExit:
		compiledBlock: 	a CompiledBlock: [
		self rememberSession;
			ifMatch: [ :m [..]
		numArgs: 	0
		receiver: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))


ClapContext>>executeToExit:
	Receiver: a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Arguments and temporary variables: 
		exitBlock: 	[ :exit | self handleExit: exit ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		arguments: 	an OrderedCollection('referenceCheck' 'index.md')
		obeyingExits: 	true
		stdio: 	Stdio
		match: 	a ClapCompositeMatch
		leftovers: 	an OrderedCollection()
		session: 	a WorkingSession
		exitException: 	nil


[
		ClapContext withPragmaCommands
			beObeyingExits;
			setStdio: Stdio;
			arguments: self arguments;
			executeToExit: [ :exit | self handleExit: exit ]
	] in ClapCommandLineHandler>>activate
	Receiver: a ClapCommandLineHandler
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
	Receiver: [
		ClapContext withPragmaCommands
			beObeyingExits;
			setStdio: Stdio;
			arguments[..]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		outerContext: 	ClapCommandLineHandler>>activate
		compiledBlock: 	a CompiledBlock: [
		ClapContext withPragmaCommands
			beObe[..]
		numArgs: 	0
		receiver: 	a ClapCommandLineHandler



--- The full stack ---
FileReference(Object)>>doesNotUnderstand: #referenceTo:
[ :file |
		               fileSystem referenceTo: file ] in MicReferenceChecker>>checkProject:
[:each | each ifNotNil: [newSet add: (aBlock value: each enclosedElement)]] in Set>>collect:
Array(SequenceableCollection)>>do:
Set>>collect:
MicReferenceChecker>>checkProject:
ClapMicrodownBookReferenceCheckerCommand>>execute
[ :args |
			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].
			(self with: args) execute ] in ClapMicrodownBookReferenceCheckerCommand class>>commandSpecification
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
ClapCommand(ClapParameter)>>valueFor:with:
[ super valueFor: aMatch with: arg ] in ClapCommand>>valueFor:with:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
ClapNamedMatch(ClapCompositeMatch)>>matchedSubcommand:ifNone:
ClapCommand>>valueFor:with:
ClapNamedMatch(ClapExpression)>>value:
[ :sub | sub value: arg ] in ClapRoot(ClapCommand)>>valueFor:with:
FullBlockClosure(BlockClosure)>>cull:
[ :cmdMatch | foundBlock cull: cmdMatch ] in ClapCompositeMatch>>matchedSubcommand:ifNone:
FullBlockClosure(BlockClosure)>>cull:
[ :each |
			(aBlock value: each)
				ifTrue: [ ^ foundBlock cull: each ] ] in OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
ClapCompositeMatch>>matchedSubcommand:ifNone:
ClapRoot(ClapCommand)>>valueFor:with:
ClapCompositeMatch(ClapExpression)>>value:
[ :m |
				m value: self.
				self exitSuccess ] in [
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ]
			ifMismatch: [ self noneMatched ]
	] in ClapContext>>executeToExit:
FullBlockClosure(BlockClosure)>>cull:
ClapCompositeMatch(ClapSubExpression)>>ifMatch:ifMismatch:
ClapContext>>ifMatch:ifMismatch:
[
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ]
			ifMismatch: [ self noneMatched ]
	] in ClapContext>>executeToExit:
FullBlockClosure(BlockClosure)>>on:do:
ClapContext>>executeToExit:
[
		ClapContext withPragmaCommands
			beObeyingExits;
			setStdio: Stdio;
			arguments: self arguments;
			executeToExit: [ :exit | self handleExit: exit ]
	] in ClapCommandLineHandler>>activate
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE

4 August 2024 10:43:36.159113 am

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 74b785ff-50d8-0d00-86f4-c64e0df24b96 Jun 28 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 74b785ff-50d8-0d00-86f4-c64e0df24b96 Jun 28 2024
v10.3.0 - Commit: ce151716 - Date: 2024-06-28 10:12:41 +0200

Image: Pharo12.0.0SNAPSHOT [Build information: Pharo-12.0.0+SNAPSHOT.build.1526.sha.404d3af7531f656b5c294762c79011c10bea1ef3 (64 Bit)]

ClapMicrodownBookReferenceCheckerCommand(Object)>>halt
	Receiver: a ClapMicrodownBookReferenceCheckerCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		arguments: 	a ClapNamedMatch
		project: 	nil


ClapMicrodownBookReferenceCheckerCommand>>execute
	Receiver: a ClapMicrodownBookReferenceCheckerCommand
	Arguments and temporary variables: 
		file: 	File @ index.md
		checker: 	nil
	Receiver's instance variables: 
		arguments: 	a ClapNamedMatch
		project: 	nil


[ :args |
			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].
			(self with: args) execute ] in ClapMicrodownBookReferenceCheckerCommand class>>commandSpecification
	Receiver: ClapMicrodownBookReferenceCheckerCommand
	Arguments and temporary variables: 
		args: 	a ClapNamedMatch
	Receiver's instance variables: 
		superclass: 	ClapPillarCommand
		methodDict: 	a MethodDictionary(#execute->ClapMicrodownBookReferenceCheckerC[..]
		format: 	65538
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (execution) - 2 selector(s))
		subclasses: 	nil
		name: 	#ClapMicrodownBookReferenceCheckerCommand
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	7449745
		packageTag: 	a PackageTag(Uncategorized)


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :args |
			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].
			(se[..]
	Arguments and temporary variables: 
		anArg: 	a ClapNamedMatch
	Receiver's instance variables: 
		outerContext: 	ClapMicrodownBookReferenceCheckerCommand class>>commandSpecif[..]
		compiledBlock: 	a CompiledBlock: [ :args |
			args at: #helpFlag ifPresent: [..]
		numArgs: 	1
		receiver: 	ClapMicrodownBookReferenceCheckerCommand


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ :args |
			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].
			(se[..]
	Arguments and temporary variables: 
		firstArg: 	a ClapNamedMatch
		secondArg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		outerContext: 	ClapMicrodownBookReferenceCheckerCommand class>>commandSpecif[..]
		compiledBlock: 	a CompiledBlock: [ :args |
			args at: #helpFlag ifPresent: [..]
		numArgs: 	1
		receiver: 	ClapMicrodownBookReferenceCheckerCommand


ClapCommand(ClapParameter)>>valueFor:with:
	Receiver: a ClapCommand(referenceCheck)
	Arguments and temporary variables: 
		aMatch: 	a ClapNamedMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		identifier: 	#referenceCheck
		canonicalName: 	nil
		description: 	'Check the duplicated or unknown references'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help | help val[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #requestedFile[..]
		positionals: 	an OrderedCollection(a ClapPositional(requestedFile))
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help))
		subcommands: 	an OrderedCollection()


[ super valueFor: aMatch with: arg ] in ClapCommand>>valueFor:with:
	Receiver: a ClapCommand(referenceCheck)
	Arguments and temporary variables: 
		aMatch: 	a ClapNamedMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		identifier: 	#referenceCheck
		canonicalName: 	nil
		description: 	'Check the duplicated or unknown references'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help | help val[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #requestedFile[..]
		positionals: 	an OrderedCollection(a ClapPositional(requestedFile))
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help))
		subcommands: 	an OrderedCollection()


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(a ClapWordMatch)
	Arguments and temporary variables: 
		aBlock: 	[ :child | specification subcommands includes: child specification ]
		foundBlock: 	[ :cmdMatch | foundBlock cull: cmdMatch ]
		exceptionBlock: 	[ super valueFor: aMatch with: arg ]
	Receiver's instance variables: 
		array: 	an Array(a ClapWordMatch nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


ClapNamedMatch(ClapCompositeMatch)>>matchedSubcommand:ifNone:
	Receiver: a ClapNamedMatch
	Arguments and temporary variables: 
		foundBlock: 	[ :sub | sub value: arg ]
		noneBlock: 	[ super valueFor: aMatch with: arg ]
	Receiver's instance variables: 
		specification: 	a ClapCommand(referenceCheck)
		parent: 	a ClapCompositeMatch
		startIndex: 	1
		children: 	an OrderedCollection(a ClapWordMatch)
		keyword: 	'referenceCheck'


ClapCommand>>valueFor:with:
	Receiver: a ClapCommand(referenceCheck)
	Arguments and temporary variables: 
		aMatch: 	a ClapNamedMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		identifier: 	#referenceCheck
		canonicalName: 	nil
		description: 	'Check the duplicated or unknown references'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help | help val[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #requestedFile[..]
		positionals: 	an OrderedCollection(a ClapPositional(requestedFile))
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help))
		subcommands: 	an OrderedCollection()


ClapNamedMatch(ClapExpression)>>value:
	Receiver: a ClapNamedMatch
	Arguments and temporary variables: 
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		specification: 	a ClapCommand(referenceCheck)
		parent: 	a ClapCompositeMatch
		startIndex: 	1
		children: 	an OrderedCollection(a ClapWordMatch)
		keyword: 	'referenceCheck'


[ :sub | sub value: arg ] in ClapRoot(ClapCommand)>>valueFor:with:
	Receiver: a ClapRoot(clap)
	Arguments and temporary variables: 
		aMatch: 	a ClapCompositeMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
		sub: 	a ClapNamedMatch
	Receiver's instance variables: 
		identifier: 	#clap
		canonicalName: 	nil
		description: 	'Entry point for commands implemented with Clap'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help |
				help[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #helpCommand->[..]
		positionals: 	an OrderedCollection()
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help) a ClapFlag(save) a ClapFlag(no[..]
		subcommands: 	an OrderedCollection(a ClapCommand(help) a ClapCommand(image) [..]


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :sub | sub value: arg ]
	Arguments and temporary variables: 
		anArg: 	a ClapNamedMatch
	Receiver's instance variables: 
		outerContext: 	ClapRoot(ClapCommand)>>valueFor:with:
		compiledBlock: 	a CompiledBlock: [ :sub | sub value: arg ]
		numArgs: 	1
		receiver: 	a ClapRoot(clap)


[ :cmdMatch | foundBlock cull: cmdMatch ] in ClapCompositeMatch>>matchedSubcommand:ifNone:
	Receiver: a ClapCompositeMatch
	Arguments and temporary variables: 
		foundBlock: 	[ :sub | sub value: arg ]
		noneBlock: 	[ super valueFor: aMatch with: arg ]
		cmdMatch: 	a ClapNamedMatch
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		parent: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
		startIndex: 	1
		children: 	an OrderedCollection(a ClapNamedMatch)


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :cmdMatch | foundBlock cull: cmdMatch ]
	Arguments and temporary variables: 
		anArg: 	a ClapNamedMatch
	Receiver's instance variables: 
		outerContext: 	ClapCompositeMatch>>matchedSubcommand:ifNone:
		compiledBlock: 	a CompiledBlock: [ :cmdMatch | foundBlock cull: cmdMatch ]
		numArgs: 	1
		receiver: 	a ClapCompositeMatch


[ :each |
			(aBlock value: each)
				ifTrue: [ ^ foundBlock cull: each ] ] in OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(a ClapNamedMatch)
	Arguments and temporary variables: 
		aBlock: 	[ :child | specification subcommands includes: child specification ]
		foundBlock: 	[ :cmdMatch | foundBlock cull: cmdMatch ]
		exceptionBlock: 	[ super valueFor: aMatch with: arg ]
		each: 	a ClapNamedMatch
	Receiver's instance variables: 
		array: 	an Array(a ClapNamedMatch nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


OrderedCollection>>do:
	Receiver: an OrderedCollection(a ClapNamedMatch)
	Arguments and temporary variables: 
		aBlock: 	[ :each |
			(aBlock value: each)
				ifTrue: [ ^ foundBlock cull: [..]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a ClapNamedMatch nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(a ClapNamedMatch)
	Arguments and temporary variables: 
		aBlock: 	[ :child | specification subcommands includes: child specification ]
		foundBlock: 	[ :cmdMatch | foundBlock cull: cmdMatch ]
		exceptionBlock: 	[ super valueFor: aMatch with: arg ]
	Receiver's instance variables: 
		array: 	an Array(a ClapNamedMatch nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


ClapCompositeMatch>>matchedSubcommand:ifNone:
	Receiver: a ClapCompositeMatch
	Arguments and temporary variables: 
		foundBlock: 	[ :sub | sub value: arg ]
		noneBlock: 	[ super valueFor: aMatch with: arg ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		parent: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
		startIndex: 	1
		children: 	an OrderedCollection(a ClapNamedMatch)


ClapRoot(ClapCommand)>>valueFor:with:
	Receiver: a ClapRoot(clap)
	Arguments and temporary variables: 
		aMatch: 	a ClapCompositeMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		identifier: 	#clap
		canonicalName: 	nil
		description: 	'Entry point for commands implemented with Clap'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help |
				help[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #helpCommand->[..]
		positionals: 	an OrderedCollection()
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help) a ClapFlag(save) a ClapFlag(no[..]
		subcommands: 	an OrderedCollection(a ClapCommand(help) a ClapCommand(image) [..]


ClapCompositeMatch(ClapExpression)>>value:
	Receiver: a ClapCompositeMatch
	Arguments and temporary variables: 
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		parent: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
		startIndex: 	1
		children: 	an OrderedCollection(a ClapNamedMatch)


[ :m |
				m value: self.
				self exitSuccess ] in [
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ]
			ifMismatch: [ self noneMatched ]
	] in ClapContext>>executeToExit:
	Receiver: a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Arguments and temporary variables: 
		exitBlock: 	[ :exit | self handleExit: exit ]
		m: 	a ClapCompositeMatch
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		arguments: 	an OrderedCollection('referenceCheck' 'index.md')
		obeyingExits: 	true
		stdio: 	Stdio
		match: 	a ClapCompositeMatch
		leftovers: 	an OrderedCollection()
		session: 	a WorkingSession
		exitException: 	nil


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :m |
				m value: self.
				self exitSuccess ]
	Arguments and temporary variables: 
		anArg: 	a ClapCompositeMatch
	Receiver's instance variables: 
		outerContext: 	[
		self rememberSession;
			ifMatch: [ :m |
				m value: sel[..]
		compiledBlock: 	a CompiledBlock: [ :m |
				m value: self.
				self exitSucc[..]
		numArgs: 	1
		receiver: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))


ClapCompositeMatch(ClapSubExpression)>>ifMatch:ifMismatch:
	Receiver: a ClapCompositeMatch
	Arguments and temporary variables: 
		matchBlock: 	[ :m |
				m value: self.
				self exitSuccess ]
		mismatchBlock: 	[ self noneMatched ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		parent: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
		startIndex: 	1
		children: 	an OrderedCollection(a ClapNamedMatch)


ClapContext>>ifMatch:ifMismatch:
	Receiver: a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Arguments and temporary variables: 
		matchBlock: 	[ :m |
				m value: self.
				self exitSuccess ]
		failBlock: 	[ self noneMatched ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		arguments: 	an OrderedCollection('referenceCheck' 'index.md')
		obeyingExits: 	true
		stdio: 	Stdio
		match: 	a ClapCompositeMatch
		leftovers: 	an OrderedCollection()
		session: 	a WorkingSession
		exitException: 	nil


[
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ]
			ifMismatch: [ self noneMatched ]
	] in ClapContext>>executeToExit:
	Receiver: a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Arguments and temporary variables: 
		exitBlock: 	[ :exit | self handleExit: exit ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		arguments: 	an OrderedCollection('referenceCheck' 'index.md')
		obeyingExits: 	true
		stdio: 	Stdio
		match: 	a ClapCompositeMatch
		leftovers: 	an OrderedCollection()
		session: 	a WorkingSession
		exitException: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ][..]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exception |
			exitException := exception.
			exitBlock v[..]
	Receiver's instance variables: 
		outerContext: 	ClapContext>>executeToExit:
		compiledBlock: 	a CompiledBlock: [
		self rememberSession;
			ifMatch: [ :m [..]
		numArgs: 	0
		receiver: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))


ClapContext>>executeToExit:
	Receiver: a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Arguments and temporary variables: 
		exitBlock: 	[ :exit | self handleExit: exit ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		arguments: 	an OrderedCollection('referenceCheck' 'index.md')
		obeyingExits: 	true
		stdio: 	Stdio
		match: 	a ClapCompositeMatch
		leftovers: 	an OrderedCollection()
		session: 	a WorkingSession
		exitException: 	nil


[
		ClapContext withPragmaCommands
			beObeyingExits;
			setStdio: Stdio;
			arguments: self arguments;
			executeToExit: [ :exit | self handleExit: exit ]
	] in ClapCommandLineHandler>>activate
	Receiver: a ClapCommandLineHandler
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
	Receiver: [
		ClapContext withPragmaCommands
			beObeyingExits;
			setStdio: Stdio;
			arguments[..]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		outerContext: 	ClapCommandLineHandler>>activate
		compiledBlock: 	a CompiledBlock: [
		ClapContext withPragmaCommands
			beObe[..]
		numArgs: 	0
		receiver: 	a ClapCommandLineHandler



--- The full stack ---
ClapMicrodownBookReferenceCheckerCommand(Object)>>halt
ClapMicrodownBookReferenceCheckerCommand>>execute
[ :args |
			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].
			(self with: args) execute ] in ClapMicrodownBookReferenceCheckerCommand class>>commandSpecification
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
ClapCommand(ClapParameter)>>valueFor:with:
[ super valueFor: aMatch with: arg ] in ClapCommand>>valueFor:with:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
ClapNamedMatch(ClapCompositeMatch)>>matchedSubcommand:ifNone:
ClapCommand>>valueFor:with:
ClapNamedMatch(ClapExpression)>>value:
[ :sub | sub value: arg ] in ClapRoot(ClapCommand)>>valueFor:with:
FullBlockClosure(BlockClosure)>>cull:
[ :cmdMatch | foundBlock cull: cmdMatch ] in ClapCompositeMatch>>matchedSubcommand:ifNone:
FullBlockClosure(BlockClosure)>>cull:
[ :each |
			(aBlock value: each)
				ifTrue: [ ^ foundBlock cull: each ] ] in OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
ClapCompositeMatch>>matchedSubcommand:ifNone:
ClapRoot(ClapCommand)>>valueFor:with:
ClapCompositeMatch(ClapExpression)>>value:
[ :m |
				m value: self.
				self exitSuccess ] in [
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ]
			ifMismatch: [ self noneMatched ]
	] in ClapContext>>executeToExit:
FullBlockClosure(BlockClosure)>>cull:
ClapCompositeMatch(ClapSubExpression)>>ifMatch:ifMismatch:
ClapContext>>ifMatch:ifMismatch:
[
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ]
			ifMismatch: [ self noneMatched ]
	] in ClapContext>>executeToExit:
FullBlockClosure(BlockClosure)>>on:do:
ClapContext>>executeToExit:
[
		ClapContext withPragmaCommands
			beObeyingExits;
			setStdio: Stdio;
			arguments: self arguments;
			executeToExit: [ :exit | self handleExit: exit ]
	] in ClapCommandLineHandler>>activate
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE

4 August 2024 10:43:50.879993 am

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 74b785ff-50d8-0d00-86f4-c64e0df24b96 Jun 28 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 74b785ff-50d8-0d00-86f4-c64e0df24b96 Jun 28 2024
v10.3.0 - Commit: ce151716 - Date: 2024-06-28 10:12:41 +0200

Image: Pharo12.0.0SNAPSHOT [Build information: Pharo-12.0.0+SNAPSHOT.build.1526.sha.404d3af7531f656b5c294762c79011c10bea1ef3 (64 Bit)]

ClapMicrodownBookReferenceCheckerCommand(Object)>>halt
	Receiver: a ClapMicrodownBookReferenceCheckerCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		arguments: 	a ClapNamedMatch
		project: 	nil


ClapMicrodownBookReferenceCheckerCommand>>execute
	Receiver: a ClapMicrodownBookReferenceCheckerCommand
	Arguments and temporary variables: 
		file: 	File @ index.md
		checker: 	nil
	Receiver's instance variables: 
		arguments: 	a ClapNamedMatch
		project: 	nil


[ :args |
			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].
			(self with: args) execute ] in ClapMicrodownBookReferenceCheckerCommand class>>commandSpecification
	Receiver: ClapMicrodownBookReferenceCheckerCommand
	Arguments and temporary variables: 
		args: 	a ClapNamedMatch
	Receiver's instance variables: 
		superclass: 	ClapPillarCommand
		methodDict: 	a MethodDictionary(#execute->ClapMicrodownBookReferenceCheckerC[..]
		format: 	65538
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (execution) - 2 selector(s))
		subclasses: 	nil
		name: 	#ClapMicrodownBookReferenceCheckerCommand
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	7449745
		packageTag: 	a PackageTag(Uncategorized)


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :args |
			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].
			(se[..]
	Arguments and temporary variables: 
		anArg: 	a ClapNamedMatch
	Receiver's instance variables: 
		outerContext: 	ClapMicrodownBookReferenceCheckerCommand class>>commandSpecif[..]
		compiledBlock: 	a CompiledBlock: [ :args |
			args at: #helpFlag ifPresent: [..]
		numArgs: 	1
		receiver: 	ClapMicrodownBookReferenceCheckerCommand


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ :args |
			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].
			(se[..]
	Arguments and temporary variables: 
		firstArg: 	a ClapNamedMatch
		secondArg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		outerContext: 	ClapMicrodownBookReferenceCheckerCommand class>>commandSpecif[..]
		compiledBlock: 	a CompiledBlock: [ :args |
			args at: #helpFlag ifPresent: [..]
		numArgs: 	1
		receiver: 	ClapMicrodownBookReferenceCheckerCommand


ClapCommand(ClapParameter)>>valueFor:with:
	Receiver: a ClapCommand(referenceCheck)
	Arguments and temporary variables: 
		aMatch: 	a ClapNamedMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		identifier: 	#referenceCheck
		canonicalName: 	nil
		description: 	'Check the duplicated or unknown references'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help | help val[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #requestedFile[..]
		positionals: 	an OrderedCollection(a ClapPositional(requestedFile))
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help))
		subcommands: 	an OrderedCollection()


[ super valueFor: aMatch with: arg ] in ClapCommand>>valueFor:with:
	Receiver: a ClapCommand(referenceCheck)
	Arguments and temporary variables: 
		aMatch: 	a ClapNamedMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		identifier: 	#referenceCheck
		canonicalName: 	nil
		description: 	'Check the duplicated or unknown references'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help | help val[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #requestedFile[..]
		positionals: 	an OrderedCollection(a ClapPositional(requestedFile))
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help))
		subcommands: 	an OrderedCollection()


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(a ClapWordMatch)
	Arguments and temporary variables: 
		aBlock: 	[ :child | specification subcommands includes: child specification ]
		foundBlock: 	[ :cmdMatch | foundBlock cull: cmdMatch ]
		exceptionBlock: 	[ super valueFor: aMatch with: arg ]
	Receiver's instance variables: 
		array: 	an Array(a ClapWordMatch nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


ClapNamedMatch(ClapCompositeMatch)>>matchedSubcommand:ifNone:
	Receiver: a ClapNamedMatch
	Arguments and temporary variables: 
		foundBlock: 	[ :sub | sub value: arg ]
		noneBlock: 	[ super valueFor: aMatch with: arg ]
	Receiver's instance variables: 
		specification: 	a ClapCommand(referenceCheck)
		parent: 	a ClapCompositeMatch
		startIndex: 	1
		children: 	an OrderedCollection(a ClapWordMatch)
		keyword: 	'referenceCheck'


ClapCommand>>valueFor:with:
	Receiver: a ClapCommand(referenceCheck)
	Arguments and temporary variables: 
		aMatch: 	a ClapNamedMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		identifier: 	#referenceCheck
		canonicalName: 	nil
		description: 	'Check the duplicated or unknown references'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help | help val[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #requestedFile[..]
		positionals: 	an OrderedCollection(a ClapPositional(requestedFile))
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help))
		subcommands: 	an OrderedCollection()


ClapNamedMatch(ClapExpression)>>value:
	Receiver: a ClapNamedMatch
	Arguments and temporary variables: 
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		specification: 	a ClapCommand(referenceCheck)
		parent: 	a ClapCompositeMatch
		startIndex: 	1
		children: 	an OrderedCollection(a ClapWordMatch)
		keyword: 	'referenceCheck'


[ :sub | sub value: arg ] in ClapRoot(ClapCommand)>>valueFor:with:
	Receiver: a ClapRoot(clap)
	Arguments and temporary variables: 
		aMatch: 	a ClapCompositeMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
		sub: 	a ClapNamedMatch
	Receiver's instance variables: 
		identifier: 	#clap
		canonicalName: 	nil
		description: 	'Entry point for commands implemented with Clap'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help |
				help[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #helpCommand->[..]
		positionals: 	an OrderedCollection()
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help) a ClapFlag(save) a ClapFlag(no[..]
		subcommands: 	an OrderedCollection(a ClapCommand(help) a ClapCommand(image) [..]


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :sub | sub value: arg ]
	Arguments and temporary variables: 
		anArg: 	a ClapNamedMatch
	Receiver's instance variables: 
		outerContext: 	ClapRoot(ClapCommand)>>valueFor:with:
		compiledBlock: 	a CompiledBlock: [ :sub | sub value: arg ]
		numArgs: 	1
		receiver: 	a ClapRoot(clap)


[ :cmdMatch | foundBlock cull: cmdMatch ] in ClapCompositeMatch>>matchedSubcommand:ifNone:
	Receiver: a ClapCompositeMatch
	Arguments and temporary variables: 
		foundBlock: 	[ :sub | sub value: arg ]
		noneBlock: 	[ super valueFor: aMatch with: arg ]
		cmdMatch: 	a ClapNamedMatch
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		parent: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
		startIndex: 	1
		children: 	an OrderedCollection(a ClapNamedMatch)


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :cmdMatch | foundBlock cull: cmdMatch ]
	Arguments and temporary variables: 
		anArg: 	a ClapNamedMatch
	Receiver's instance variables: 
		outerContext: 	ClapCompositeMatch>>matchedSubcommand:ifNone:
		compiledBlock: 	a CompiledBlock: [ :cmdMatch | foundBlock cull: cmdMatch ]
		numArgs: 	1
		receiver: 	a ClapCompositeMatch


[ :each |
			(aBlock value: each)
				ifTrue: [ ^ foundBlock cull: each ] ] in OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(a ClapNamedMatch)
	Arguments and temporary variables: 
		aBlock: 	[ :child | specification subcommands includes: child specification ]
		foundBlock: 	[ :cmdMatch | foundBlock cull: cmdMatch ]
		exceptionBlock: 	[ super valueFor: aMatch with: arg ]
		each: 	a ClapNamedMatch
	Receiver's instance variables: 
		array: 	an Array(a ClapNamedMatch nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


OrderedCollection>>do:
	Receiver: an OrderedCollection(a ClapNamedMatch)
	Arguments and temporary variables: 
		aBlock: 	[ :each |
			(aBlock value: each)
				ifTrue: [ ^ foundBlock cull: [..]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a ClapNamedMatch nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(a ClapNamedMatch)
	Arguments and temporary variables: 
		aBlock: 	[ :child | specification subcommands includes: child specification ]
		foundBlock: 	[ :cmdMatch | foundBlock cull: cmdMatch ]
		exceptionBlock: 	[ super valueFor: aMatch with: arg ]
	Receiver's instance variables: 
		array: 	an Array(a ClapNamedMatch nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


ClapCompositeMatch>>matchedSubcommand:ifNone:
	Receiver: a ClapCompositeMatch
	Arguments and temporary variables: 
		foundBlock: 	[ :sub | sub value: arg ]
		noneBlock: 	[ super valueFor: aMatch with: arg ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		parent: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
		startIndex: 	1
		children: 	an OrderedCollection(a ClapNamedMatch)


ClapRoot(ClapCommand)>>valueFor:with:
	Receiver: a ClapRoot(clap)
	Arguments and temporary variables: 
		aMatch: 	a ClapCompositeMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		identifier: 	#clap
		canonicalName: 	nil
		description: 	'Entry point for commands implemented with Clap'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help |
				help[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #helpCommand->[..]
		positionals: 	an OrderedCollection()
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help) a ClapFlag(save) a ClapFlag(no[..]
		subcommands: 	an OrderedCollection(a ClapCommand(help) a ClapCommand(image) [..]


ClapCompositeMatch(ClapExpression)>>value:
	Receiver: a ClapCompositeMatch
	Arguments and temporary variables: 
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		parent: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
		startIndex: 	1
		children: 	an OrderedCollection(a ClapNamedMatch)


[ :m |
				m value: self.
				self exitSuccess ] in [
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ]
			ifMismatch: [ self noneMatched ]
	] in ClapContext>>executeToExit:
	Receiver: a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Arguments and temporary variables: 
		exitBlock: 	[ :exit | self handleExit: exit ]
		m: 	a ClapCompositeMatch
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		arguments: 	an OrderedCollection('referenceCheck' 'index.md')
		obeyingExits: 	true
		stdio: 	Stdio
		match: 	a ClapCompositeMatch
		leftovers: 	an OrderedCollection()
		session: 	a WorkingSession
		exitException: 	nil


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :m |
				m value: self.
				self exitSuccess ]
	Arguments and temporary variables: 
		anArg: 	a ClapCompositeMatch
	Receiver's instance variables: 
		outerContext: 	[
		self rememberSession;
			ifMatch: [ :m |
				m value: sel[..]
		compiledBlock: 	a CompiledBlock: [ :m |
				m value: self.
				self exitSucc[..]
		numArgs: 	1
		receiver: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))


ClapCompositeMatch(ClapSubExpression)>>ifMatch:ifMismatch:
	Receiver: a ClapCompositeMatch
	Arguments and temporary variables: 
		matchBlock: 	[ :m |
				m value: self.
				self exitSuccess ]
		mismatchBlock: 	[ self noneMatched ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		parent: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
		startIndex: 	1
		children: 	an OrderedCollection(a ClapNamedMatch)


ClapContext>>ifMatch:ifMismatch:
	Receiver: a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Arguments and temporary variables: 
		matchBlock: 	[ :m |
				m value: self.
				self exitSuccess ]
		failBlock: 	[ self noneMatched ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		arguments: 	an OrderedCollection('referenceCheck' 'index.md')
		obeyingExits: 	true
		stdio: 	Stdio
		match: 	a ClapCompositeMatch
		leftovers: 	an OrderedCollection()
		session: 	a WorkingSession
		exitException: 	nil


[
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ]
			ifMismatch: [ self noneMatched ]
	] in ClapContext>>executeToExit:
	Receiver: a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Arguments and temporary variables: 
		exitBlock: 	[ :exit | self handleExit: exit ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		arguments: 	an OrderedCollection('referenceCheck' 'index.md')
		obeyingExits: 	true
		stdio: 	Stdio
		match: 	a ClapCompositeMatch
		leftovers: 	an OrderedCollection()
		session: 	a WorkingSession
		exitException: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ][..]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exception |
			exitException := exception.
			exitBlock v[..]
	Receiver's instance variables: 
		outerContext: 	ClapContext>>executeToExit:
		compiledBlock: 	a CompiledBlock: [
		self rememberSession;
			ifMatch: [ :m [..]
		numArgs: 	0
		receiver: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))


ClapContext>>executeToExit:
	Receiver: a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Arguments and temporary variables: 
		exitBlock: 	[ :exit | self handleExit: exit ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		arguments: 	an OrderedCollection('referenceCheck' 'index.md')
		obeyingExits: 	true
		stdio: 	Stdio
		match: 	a ClapCompositeMatch
		leftovers: 	an OrderedCollection()
		session: 	a WorkingSession
		exitException: 	nil


[
		ClapContext withPragmaCommands
			beObeyingExits;
			setStdio: Stdio;
			arguments: self arguments;
			executeToExit: [ :exit | self handleExit: exit ]
	] in ClapCommandLineHandler>>activate
	Receiver: a ClapCommandLineHandler
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
	Receiver: [
		ClapContext withPragmaCommands
			beObeyingExits;
			setStdio: Stdio;
			arguments[..]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		outerContext: 	ClapCommandLineHandler>>activate
		compiledBlock: 	a CompiledBlock: [
		ClapContext withPragmaCommands
			beObe[..]
		numArgs: 	0
		receiver: 	a ClapCommandLineHandler



--- The full stack ---
ClapMicrodownBookReferenceCheckerCommand(Object)>>halt
ClapMicrodownBookReferenceCheckerCommand>>execute
[ :args |
			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].
			(self with: args) execute ] in ClapMicrodownBookReferenceCheckerCommand class>>commandSpecification
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
ClapCommand(ClapParameter)>>valueFor:with:
[ super valueFor: aMatch with: arg ] in ClapCommand>>valueFor:with:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
ClapNamedMatch(ClapCompositeMatch)>>matchedSubcommand:ifNone:
ClapCommand>>valueFor:with:
ClapNamedMatch(ClapExpression)>>value:
[ :sub | sub value: arg ] in ClapRoot(ClapCommand)>>valueFor:with:
FullBlockClosure(BlockClosure)>>cull:
[ :cmdMatch | foundBlock cull: cmdMatch ] in ClapCompositeMatch>>matchedSubcommand:ifNone:
FullBlockClosure(BlockClosure)>>cull:
[ :each |
			(aBlock value: each)
				ifTrue: [ ^ foundBlock cull: each ] ] in OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
ClapCompositeMatch>>matchedSubcommand:ifNone:
ClapRoot(ClapCommand)>>valueFor:with:
ClapCompositeMatch(ClapExpression)>>value:
[ :m |
				m value: self.
				self exitSuccess ] in [
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ]
			ifMismatch: [ self noneMatched ]
	] in ClapContext>>executeToExit:
FullBlockClosure(BlockClosure)>>cull:
ClapCompositeMatch(ClapSubExpression)>>ifMatch:ifMismatch:
ClapContext>>ifMatch:ifMismatch:
[
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ]
			ifMismatch: [ self noneMatched ]
	] in ClapContext>>executeToExit:
FullBlockClosure(BlockClosure)>>on:do:
ClapContext>>executeToExit:
[
		ClapContext withPragmaCommands
			beObeyingExits;
			setStdio: Stdio;
			arguments: self arguments;
			executeToExit: [ :exit | self handleExit: exit ]
	] in ClapCommandLineHandler>>activate
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE

4 August 2024 10:44:14.270039 am

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 74b785ff-50d8-0d00-86f4-c64e0df24b96 Jun 28 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 74b785ff-50d8-0d00-86f4-c64e0df24b96 Jun 28 2024
v10.3.0 - Commit: ce151716 - Date: 2024-06-28 10:12:41 +0200

Image: Pharo12.0.0SNAPSHOT [Build information: Pharo-12.0.0+SNAPSHOT.build.1526.sha.404d3af7531f656b5c294762c79011c10bea1ef3 (64 Bit)]

ClapMicrodownBookReferenceCheckerCommand(Object)>>halt
	Receiver: a ClapMicrodownBookReferenceCheckerCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		arguments: 	a ClapNamedMatch
		project: 	nil


ClapMicrodownBookReferenceCheckerCommand>>execute
	Receiver: a ClapMicrodownBookReferenceCheckerCommand
	Arguments and temporary variables: 
		file: 	File @ index.md
		checker: 	nil
	Receiver's instance variables: 
		arguments: 	a ClapNamedMatch
		project: 	nil


[ :args |
			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].
			(self with: args) execute ] in ClapMicrodownBookReferenceCheckerCommand class>>commandSpecification
	Receiver: ClapMicrodownBookReferenceCheckerCommand
	Arguments and temporary variables: 
		args: 	a ClapNamedMatch
	Receiver's instance variables: 
		superclass: 	ClapPillarCommand
		methodDict: 	a MethodDictionary(#execute->ClapMicrodownBookReferenceCheckerC[..]
		format: 	65538
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (execution) - 2 selector(s))
		subclasses: 	nil
		name: 	#ClapMicrodownBookReferenceCheckerCommand
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	7449745
		packageTag: 	a PackageTag(Uncategorized)


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :args |
			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].
			(se[..]
	Arguments and temporary variables: 
		anArg: 	a ClapNamedMatch
	Receiver's instance variables: 
		outerContext: 	ClapMicrodownBookReferenceCheckerCommand class>>commandSpecif[..]
		compiledBlock: 	a CompiledBlock: [ :args |
			args at: #helpFlag ifPresent: [..]
		numArgs: 	1
		receiver: 	ClapMicrodownBookReferenceCheckerCommand


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ :args |
			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].
			(se[..]
	Arguments and temporary variables: 
		firstArg: 	a ClapNamedMatch
		secondArg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		outerContext: 	ClapMicrodownBookReferenceCheckerCommand class>>commandSpecif[..]
		compiledBlock: 	a CompiledBlock: [ :args |
			args at: #helpFlag ifPresent: [..]
		numArgs: 	1
		receiver: 	ClapMicrodownBookReferenceCheckerCommand


ClapCommand(ClapParameter)>>valueFor:with:
	Receiver: a ClapCommand(referenceCheck)
	Arguments and temporary variables: 
		aMatch: 	a ClapNamedMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		identifier: 	#referenceCheck
		canonicalName: 	nil
		description: 	'Check the duplicated or unknown references'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help | help val[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #requestedFile[..]
		positionals: 	an OrderedCollection(a ClapPositional(requestedFile))
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help))
		subcommands: 	an OrderedCollection()


[ super valueFor: aMatch with: arg ] in ClapCommand>>valueFor:with:
	Receiver: a ClapCommand(referenceCheck)
	Arguments and temporary variables: 
		aMatch: 	a ClapNamedMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		identifier: 	#referenceCheck
		canonicalName: 	nil
		description: 	'Check the duplicated or unknown references'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help | help val[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #requestedFile[..]
		positionals: 	an OrderedCollection(a ClapPositional(requestedFile))
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help))
		subcommands: 	an OrderedCollection()


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(a ClapWordMatch)
	Arguments and temporary variables: 
		aBlock: 	[ :child | specification subcommands includes: child specification ]
		foundBlock: 	[ :cmdMatch | foundBlock cull: cmdMatch ]
		exceptionBlock: 	[ super valueFor: aMatch with: arg ]
	Receiver's instance variables: 
		array: 	an Array(a ClapWordMatch nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


ClapNamedMatch(ClapCompositeMatch)>>matchedSubcommand:ifNone:
	Receiver: a ClapNamedMatch
	Arguments and temporary variables: 
		foundBlock: 	[ :sub | sub value: arg ]
		noneBlock: 	[ super valueFor: aMatch with: arg ]
	Receiver's instance variables: 
		specification: 	a ClapCommand(referenceCheck)
		parent: 	a ClapCompositeMatch
		startIndex: 	1
		children: 	an OrderedCollection(a ClapWordMatch)
		keyword: 	'referenceCheck'


ClapCommand>>valueFor:with:
	Receiver: a ClapCommand(referenceCheck)
	Arguments and temporary variables: 
		aMatch: 	a ClapNamedMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		identifier: 	#referenceCheck
		canonicalName: 	nil
		description: 	'Check the duplicated or unknown references'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help | help val[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #requestedFile[..]
		positionals: 	an OrderedCollection(a ClapPositional(requestedFile))
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help))
		subcommands: 	an OrderedCollection()


ClapNamedMatch(ClapExpression)>>value:
	Receiver: a ClapNamedMatch
	Arguments and temporary variables: 
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		specification: 	a ClapCommand(referenceCheck)
		parent: 	a ClapCompositeMatch
		startIndex: 	1
		children: 	an OrderedCollection(a ClapWordMatch)
		keyword: 	'referenceCheck'


[ :sub | sub value: arg ] in ClapRoot(ClapCommand)>>valueFor:with:
	Receiver: a ClapRoot(clap)
	Arguments and temporary variables: 
		aMatch: 	a ClapCompositeMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
		sub: 	a ClapNamedMatch
	Receiver's instance variables: 
		identifier: 	#clap
		canonicalName: 	nil
		description: 	'Entry point for commands implemented with Clap'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help |
				help[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #helpCommand->[..]
		positionals: 	an OrderedCollection()
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help) a ClapFlag(save) a ClapFlag(no[..]
		subcommands: 	an OrderedCollection(a ClapCommand(help) a ClapCommand(image) [..]


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :sub | sub value: arg ]
	Arguments and temporary variables: 
		anArg: 	a ClapNamedMatch
	Receiver's instance variables: 
		outerContext: 	ClapRoot(ClapCommand)>>valueFor:with:
		compiledBlock: 	a CompiledBlock: [ :sub | sub value: arg ]
		numArgs: 	1
		receiver: 	a ClapRoot(clap)


[ :cmdMatch | foundBlock cull: cmdMatch ] in ClapCompositeMatch>>matchedSubcommand:ifNone:
	Receiver: a ClapCompositeMatch
	Arguments and temporary variables: 
		foundBlock: 	[ :sub | sub value: arg ]
		noneBlock: 	[ super valueFor: aMatch with: arg ]
		cmdMatch: 	a ClapNamedMatch
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		parent: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
		startIndex: 	1
		children: 	an OrderedCollection(a ClapNamedMatch)


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :cmdMatch | foundBlock cull: cmdMatch ]
	Arguments and temporary variables: 
		anArg: 	a ClapNamedMatch
	Receiver's instance variables: 
		outerContext: 	ClapCompositeMatch>>matchedSubcommand:ifNone:
		compiledBlock: 	a CompiledBlock: [ :cmdMatch | foundBlock cull: cmdMatch ]
		numArgs: 	1
		receiver: 	a ClapCompositeMatch


[ :each |
			(aBlock value: each)
				ifTrue: [ ^ foundBlock cull: each ] ] in OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(a ClapNamedMatch)
	Arguments and temporary variables: 
		aBlock: 	[ :child | specification subcommands includes: child specification ]
		foundBlock: 	[ :cmdMatch | foundBlock cull: cmdMatch ]
		exceptionBlock: 	[ super valueFor: aMatch with: arg ]
		each: 	a ClapNamedMatch
	Receiver's instance variables: 
		array: 	an Array(a ClapNamedMatch nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


OrderedCollection>>do:
	Receiver: an OrderedCollection(a ClapNamedMatch)
	Arguments and temporary variables: 
		aBlock: 	[ :each |
			(aBlock value: each)
				ifTrue: [ ^ foundBlock cull: [..]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a ClapNamedMatch nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(a ClapNamedMatch)
	Arguments and temporary variables: 
		aBlock: 	[ :child | specification subcommands includes: child specification ]
		foundBlock: 	[ :cmdMatch | foundBlock cull: cmdMatch ]
		exceptionBlock: 	[ super valueFor: aMatch with: arg ]
	Receiver's instance variables: 
		array: 	an Array(a ClapNamedMatch nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


ClapCompositeMatch>>matchedSubcommand:ifNone:
	Receiver: a ClapCompositeMatch
	Arguments and temporary variables: 
		foundBlock: 	[ :sub | sub value: arg ]
		noneBlock: 	[ super valueFor: aMatch with: arg ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		parent: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
		startIndex: 	1
		children: 	an OrderedCollection(a ClapNamedMatch)


ClapRoot(ClapCommand)>>valueFor:with:
	Receiver: a ClapRoot(clap)
	Arguments and temporary variables: 
		aMatch: 	a ClapCompositeMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		identifier: 	#clap
		canonicalName: 	nil
		description: 	'Entry point for commands implemented with Clap'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help |
				help[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #helpCommand->[..]
		positionals: 	an OrderedCollection()
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help) a ClapFlag(save) a ClapFlag(no[..]
		subcommands: 	an OrderedCollection(a ClapCommand(help) a ClapCommand(image) [..]


ClapCompositeMatch(ClapExpression)>>value:
	Receiver: a ClapCompositeMatch
	Arguments and temporary variables: 
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		parent: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
		startIndex: 	1
		children: 	an OrderedCollection(a ClapNamedMatch)


[ :m |
				m value: self.
				self exitSuccess ] in [
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ]
			ifMismatch: [ self noneMatched ]
	] in ClapContext>>executeToExit:
	Receiver: a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Arguments and temporary variables: 
		exitBlock: 	[ :exit | self handleExit: exit ]
		m: 	a ClapCompositeMatch
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		arguments: 	an OrderedCollection('referenceCheck' 'index.md')
		obeyingExits: 	true
		stdio: 	Stdio
		match: 	a ClapCompositeMatch
		leftovers: 	an OrderedCollection()
		session: 	a WorkingSession
		exitException: 	nil


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :m |
				m value: self.
				self exitSuccess ]
	Arguments and temporary variables: 
		anArg: 	a ClapCompositeMatch
	Receiver's instance variables: 
		outerContext: 	[
		self rememberSession;
			ifMatch: [ :m |
				m value: sel[..]
		compiledBlock: 	a CompiledBlock: [ :m |
				m value: self.
				self exitSucc[..]
		numArgs: 	1
		receiver: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))


ClapCompositeMatch(ClapSubExpression)>>ifMatch:ifMismatch:
	Receiver: a ClapCompositeMatch
	Arguments and temporary variables: 
		matchBlock: 	[ :m |
				m value: self.
				self exitSuccess ]
		mismatchBlock: 	[ self noneMatched ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		parent: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
		startIndex: 	1
		children: 	an OrderedCollection(a ClapNamedMatch)


ClapContext>>ifMatch:ifMismatch:
	Receiver: a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Arguments and temporary variables: 
		matchBlock: 	[ :m |
				m value: self.
				self exitSuccess ]
		failBlock: 	[ self noneMatched ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		arguments: 	an OrderedCollection('referenceCheck' 'index.md')
		obeyingExits: 	true
		stdio: 	Stdio
		match: 	a ClapCompositeMatch
		leftovers: 	an OrderedCollection()
		session: 	a WorkingSession
		exitException: 	nil


[
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ]
			ifMismatch: [ self noneMatched ]
	] in ClapContext>>executeToExit:
	Receiver: a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Arguments and temporary variables: 
		exitBlock: 	[ :exit | self handleExit: exit ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		arguments: 	an OrderedCollection('referenceCheck' 'index.md')
		obeyingExits: 	true
		stdio: 	Stdio
		match: 	a ClapCompositeMatch
		leftovers: 	an OrderedCollection()
		session: 	a WorkingSession
		exitException: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ][..]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exception |
			exitException := exception.
			exitBlock v[..]
	Receiver's instance variables: 
		outerContext: 	ClapContext>>executeToExit:
		compiledBlock: 	a CompiledBlock: [
		self rememberSession;
			ifMatch: [ :m [..]
		numArgs: 	0
		receiver: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))


ClapContext>>executeToExit:
	Receiver: a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Arguments and temporary variables: 
		exitBlock: 	[ :exit | self handleExit: exit ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		arguments: 	an OrderedCollection('referenceCheck' 'index.md')
		obeyingExits: 	true
		stdio: 	Stdio
		match: 	a ClapCompositeMatch
		leftovers: 	an OrderedCollection()
		session: 	a WorkingSession
		exitException: 	nil


[
		ClapContext withPragmaCommands
			beObeyingExits;
			setStdio: Stdio;
			arguments: self arguments;
			executeToExit: [ :exit | self handleExit: exit ]
	] in ClapCommandLineHandler>>activate
	Receiver: a ClapCommandLineHandler
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
	Receiver: [
		ClapContext withPragmaCommands
			beObeyingExits;
			setStdio: Stdio;
			arguments[..]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		outerContext: 	ClapCommandLineHandler>>activate
		compiledBlock: 	a CompiledBlock: [
		ClapContext withPragmaCommands
			beObe[..]
		numArgs: 	0
		receiver: 	a ClapCommandLineHandler



--- The full stack ---
ClapMicrodownBookReferenceCheckerCommand(Object)>>halt
ClapMicrodownBookReferenceCheckerCommand>>execute
[ :args |
			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].
			(self with: args) execute ] in ClapMicrodownBookReferenceCheckerCommand class>>commandSpecification
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
ClapCommand(ClapParameter)>>valueFor:with:
[ super valueFor: aMatch with: arg ] in ClapCommand>>valueFor:with:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
ClapNamedMatch(ClapCompositeMatch)>>matchedSubcommand:ifNone:
ClapCommand>>valueFor:with:
ClapNamedMatch(ClapExpression)>>value:
[ :sub | sub value: arg ] in ClapRoot(ClapCommand)>>valueFor:with:
FullBlockClosure(BlockClosure)>>cull:
[ :cmdMatch | foundBlock cull: cmdMatch ] in ClapCompositeMatch>>matchedSubcommand:ifNone:
FullBlockClosure(BlockClosure)>>cull:
[ :each |
			(aBlock value: each)
				ifTrue: [ ^ foundBlock cull: each ] ] in OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
ClapCompositeMatch>>matchedSubcommand:ifNone:
ClapRoot(ClapCommand)>>valueFor:with:
ClapCompositeMatch(ClapExpression)>>value:
[ :m |
				m value: self.
				self exitSuccess ] in [
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ]
			ifMismatch: [ self noneMatched ]
	] in ClapContext>>executeToExit:
FullBlockClosure(BlockClosure)>>cull:
ClapCompositeMatch(ClapSubExpression)>>ifMatch:ifMismatch:
ClapContext>>ifMatch:ifMismatch:
[
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ]
			ifMismatch: [ self noneMatched ]
	] in ClapContext>>executeToExit:
FullBlockClosure(BlockClosure)>>on:do:
ClapContext>>executeToExit:
[
		ClapContext withPragmaCommands
			beObeyingExits;
			setStdio: Stdio;
			arguments: self arguments;
			executeToExit: [ :exit | self handleExit: exit ]
	] in ClapCommandLineHandler>>activate
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE

4 August 2024 10:54:16.473062 am

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 74b785ff-50d8-0d00-86f4-c64e0df24b96 Jun 28 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 74b785ff-50d8-0d00-86f4-c64e0df24b96 Jun 28 2024
v10.3.0 - Commit: ce151716 - Date: 2024-06-28 10:12:41 +0200

Image: Pharo12.0.0SNAPSHOT [Build information: Pharo-12.0.0+SNAPSHOT.build.1526.sha.404d3af7531f656b5c294762c79011c10bea1ef3 (64 Bit)]

ClapMicrodownBookReferenceCheckerCommand(Object)>>halt
	Receiver: a ClapMicrodownBookReferenceCheckerCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		arguments: 	a ClapNamedMatch
		project: 	nil


ClapMicrodownBookReferenceCheckerCommand>>execute
	Receiver: a ClapMicrodownBookReferenceCheckerCommand
	Arguments and temporary variables: 
		file: 	File @ index.md
		checker: 	nil
	Receiver's instance variables: 
		arguments: 	a ClapNamedMatch
		project: 	nil


[ :args |
			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].
			(self with: args) execute ] in ClapMicrodownBookReferenceCheckerCommand class>>commandSpecification
	Receiver: ClapMicrodownBookReferenceCheckerCommand
	Arguments and temporary variables: 
		args: 	a ClapNamedMatch
	Receiver's instance variables: 
		superclass: 	ClapPillarCommand
		methodDict: 	a MethodDictionary(#execute->ClapMicrodownBookReferenceCheckerC[..]
		format: 	65538
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (execution) - 2 selector(s))
		subclasses: 	nil
		name: 	#ClapMicrodownBookReferenceCheckerCommand
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	7449745
		packageTag: 	a PackageTag(Uncategorized)


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :args |
			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].
			(se[..]
	Arguments and temporary variables: 
		anArg: 	a ClapNamedMatch
	Receiver's instance variables: 
		outerContext: 	ClapMicrodownBookReferenceCheckerCommand class>>commandSpecif[..]
		compiledBlock: 	a CompiledBlock: [ :args |
			args at: #helpFlag ifPresent: [..]
		numArgs: 	1
		receiver: 	ClapMicrodownBookReferenceCheckerCommand


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ :args |
			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].
			(se[..]
	Arguments and temporary variables: 
		firstArg: 	a ClapNamedMatch
		secondArg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		outerContext: 	ClapMicrodownBookReferenceCheckerCommand class>>commandSpecif[..]
		compiledBlock: 	a CompiledBlock: [ :args |
			args at: #helpFlag ifPresent: [..]
		numArgs: 	1
		receiver: 	ClapMicrodownBookReferenceCheckerCommand


ClapCommand(ClapParameter)>>valueFor:with:
	Receiver: a ClapCommand(referenceCheck)
	Arguments and temporary variables: 
		aMatch: 	a ClapNamedMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		identifier: 	#referenceCheck
		canonicalName: 	nil
		description: 	'Check the duplicated or unknown references'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help | help val[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #requestedFile[..]
		positionals: 	an OrderedCollection(a ClapPositional(requestedFile))
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help))
		subcommands: 	an OrderedCollection()


[ super valueFor: aMatch with: arg ] in ClapCommand>>valueFor:with:
	Receiver: a ClapCommand(referenceCheck)
	Arguments and temporary variables: 
		aMatch: 	a ClapNamedMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		identifier: 	#referenceCheck
		canonicalName: 	nil
		description: 	'Check the duplicated or unknown references'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help | help val[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #requestedFile[..]
		positionals: 	an OrderedCollection(a ClapPositional(requestedFile))
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help))
		subcommands: 	an OrderedCollection()


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(a ClapWordMatch)
	Arguments and temporary variables: 
		aBlock: 	[ :child | specification subcommands includes: child specification ]
		foundBlock: 	[ :cmdMatch | foundBlock cull: cmdMatch ]
		exceptionBlock: 	[ super valueFor: aMatch with: arg ]
	Receiver's instance variables: 
		array: 	an Array(a ClapWordMatch nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


ClapNamedMatch(ClapCompositeMatch)>>matchedSubcommand:ifNone:
	Receiver: a ClapNamedMatch
	Arguments and temporary variables: 
		foundBlock: 	[ :sub | sub value: arg ]
		noneBlock: 	[ super valueFor: aMatch with: arg ]
	Receiver's instance variables: 
		specification: 	a ClapCommand(referenceCheck)
		parent: 	a ClapCompositeMatch
		startIndex: 	1
		children: 	an OrderedCollection(a ClapWordMatch)
		keyword: 	'referenceCheck'


ClapCommand>>valueFor:with:
	Receiver: a ClapCommand(referenceCheck)
	Arguments and temporary variables: 
		aMatch: 	a ClapNamedMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		identifier: 	#referenceCheck
		canonicalName: 	nil
		description: 	'Check the duplicated or unknown references'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help | help val[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #requestedFile[..]
		positionals: 	an OrderedCollection(a ClapPositional(requestedFile))
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help))
		subcommands: 	an OrderedCollection()


ClapNamedMatch(ClapExpression)>>value:
	Receiver: a ClapNamedMatch
	Arguments and temporary variables: 
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		specification: 	a ClapCommand(referenceCheck)
		parent: 	a ClapCompositeMatch
		startIndex: 	1
		children: 	an OrderedCollection(a ClapWordMatch)
		keyword: 	'referenceCheck'


[ :sub | sub value: arg ] in ClapRoot(ClapCommand)>>valueFor:with:
	Receiver: a ClapRoot(clap)
	Arguments and temporary variables: 
		aMatch: 	a ClapCompositeMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
		sub: 	a ClapNamedMatch
	Receiver's instance variables: 
		identifier: 	#clap
		canonicalName: 	nil
		description: 	'Entry point for commands implemented with Clap'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help |
				help[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #helpCommand->[..]
		positionals: 	an OrderedCollection()
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help) a ClapFlag(save) a ClapFlag(no[..]
		subcommands: 	an OrderedCollection(a ClapCommand(help) a ClapCommand(image) [..]


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :sub | sub value: arg ]
	Arguments and temporary variables: 
		anArg: 	a ClapNamedMatch
	Receiver's instance variables: 
		outerContext: 	ClapRoot(ClapCommand)>>valueFor:with:
		compiledBlock: 	a CompiledBlock: [ :sub | sub value: arg ]
		numArgs: 	1
		receiver: 	a ClapRoot(clap)


[ :cmdMatch | foundBlock cull: cmdMatch ] in ClapCompositeMatch>>matchedSubcommand:ifNone:
	Receiver: a ClapCompositeMatch
	Arguments and temporary variables: 
		foundBlock: 	[ :sub | sub value: arg ]
		noneBlock: 	[ super valueFor: aMatch with: arg ]
		cmdMatch: 	a ClapNamedMatch
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		parent: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
		startIndex: 	1
		children: 	an OrderedCollection(a ClapNamedMatch)


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :cmdMatch | foundBlock cull: cmdMatch ]
	Arguments and temporary variables: 
		anArg: 	a ClapNamedMatch
	Receiver's instance variables: 
		outerContext: 	ClapCompositeMatch>>matchedSubcommand:ifNone:
		compiledBlock: 	a CompiledBlock: [ :cmdMatch | foundBlock cull: cmdMatch ]
		numArgs: 	1
		receiver: 	a ClapCompositeMatch


[ :each |
			(aBlock value: each)
				ifTrue: [ ^ foundBlock cull: each ] ] in OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(a ClapNamedMatch)
	Arguments and temporary variables: 
		aBlock: 	[ :child | specification subcommands includes: child specification ]
		foundBlock: 	[ :cmdMatch | foundBlock cull: cmdMatch ]
		exceptionBlock: 	[ super valueFor: aMatch with: arg ]
		each: 	a ClapNamedMatch
	Receiver's instance variables: 
		array: 	an Array(a ClapNamedMatch nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


OrderedCollection>>do:
	Receiver: an OrderedCollection(a ClapNamedMatch)
	Arguments and temporary variables: 
		aBlock: 	[ :each |
			(aBlock value: each)
				ifTrue: [ ^ foundBlock cull: [..]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a ClapNamedMatch nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(a ClapNamedMatch)
	Arguments and temporary variables: 
		aBlock: 	[ :child | specification subcommands includes: child specification ]
		foundBlock: 	[ :cmdMatch | foundBlock cull: cmdMatch ]
		exceptionBlock: 	[ super valueFor: aMatch with: arg ]
	Receiver's instance variables: 
		array: 	an Array(a ClapNamedMatch nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


ClapCompositeMatch>>matchedSubcommand:ifNone:
	Receiver: a ClapCompositeMatch
	Arguments and temporary variables: 
		foundBlock: 	[ :sub | sub value: arg ]
		noneBlock: 	[ super valueFor: aMatch with: arg ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		parent: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
		startIndex: 	1
		children: 	an OrderedCollection(a ClapNamedMatch)


ClapRoot(ClapCommand)>>valueFor:with:
	Receiver: a ClapRoot(clap)
	Arguments and temporary variables: 
		aMatch: 	a ClapCompositeMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		identifier: 	#clap
		canonicalName: 	nil
		description: 	'Entry point for commands implemented with Clap'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help |
				help[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #helpCommand->[..]
		positionals: 	an OrderedCollection()
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help) a ClapFlag(save) a ClapFlag(no[..]
		subcommands: 	an OrderedCollection(a ClapCommand(help) a ClapCommand(image) [..]


ClapCompositeMatch(ClapExpression)>>value:
	Receiver: a ClapCompositeMatch
	Arguments and temporary variables: 
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		parent: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
		startIndex: 	1
		children: 	an OrderedCollection(a ClapNamedMatch)


[ :m |
				m value: self.
				self exitSuccess ] in [
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ]
			ifMismatch: [ self noneMatched ]
	] in ClapContext>>executeToExit:
	Receiver: a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Arguments and temporary variables: 
		exitBlock: 	[ :exit | self handleExit: exit ]
		m: 	a ClapCompositeMatch
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		arguments: 	an OrderedCollection('referenceCheck' 'index.md')
		obeyingExits: 	true
		stdio: 	Stdio
		match: 	a ClapCompositeMatch
		leftovers: 	an OrderedCollection()
		session: 	a WorkingSession
		exitException: 	nil


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :m |
				m value: self.
				self exitSuccess ]
	Arguments and temporary variables: 
		anArg: 	a ClapCompositeMatch
	Receiver's instance variables: 
		outerContext: 	[
		self rememberSession;
			ifMatch: [ :m |
				m value: sel[..]
		compiledBlock: 	a CompiledBlock: [ :m |
				m value: self.
				self exitSucc[..]
		numArgs: 	1
		receiver: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))


ClapCompositeMatch(ClapSubExpression)>>ifMatch:ifMismatch:
	Receiver: a ClapCompositeMatch
	Arguments and temporary variables: 
		matchBlock: 	[ :m |
				m value: self.
				self exitSuccess ]
		mismatchBlock: 	[ self noneMatched ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		parent: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
		startIndex: 	1
		children: 	an OrderedCollection(a ClapNamedMatch)


ClapContext>>ifMatch:ifMismatch:
	Receiver: a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Arguments and temporary variables: 
		matchBlock: 	[ :m |
				m value: self.
				self exitSuccess ]
		failBlock: 	[ self noneMatched ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		arguments: 	an OrderedCollection('referenceCheck' 'index.md')
		obeyingExits: 	true
		stdio: 	Stdio
		match: 	a ClapCompositeMatch
		leftovers: 	an OrderedCollection()
		session: 	a WorkingSession
		exitException: 	nil


[
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ]
			ifMismatch: [ self noneMatched ]
	] in ClapContext>>executeToExit:
	Receiver: a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Arguments and temporary variables: 
		exitBlock: 	[ :exit | self handleExit: exit ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		arguments: 	an OrderedCollection('referenceCheck' 'index.md')
		obeyingExits: 	true
		stdio: 	Stdio
		match: 	a ClapCompositeMatch
		leftovers: 	an OrderedCollection()
		session: 	a WorkingSession
		exitException: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ][..]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exception |
			exitException := exception.
			exitBlock v[..]
	Receiver's instance variables: 
		outerContext: 	ClapContext>>executeToExit:
		compiledBlock: 	a CompiledBlock: [
		self rememberSession;
			ifMatch: [ :m [..]
		numArgs: 	0
		receiver: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))


ClapContext>>executeToExit:
	Receiver: a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Arguments and temporary variables: 
		exitBlock: 	[ :exit | self handleExit: exit ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		arguments: 	an OrderedCollection('referenceCheck' 'index.md')
		obeyingExits: 	true
		stdio: 	Stdio
		match: 	a ClapCompositeMatch
		leftovers: 	an OrderedCollection()
		session: 	a WorkingSession
		exitException: 	nil


[
		ClapContext withPragmaCommands
			beObeyingExits;
			setStdio: Stdio;
			arguments: self arguments;
			executeToExit: [ :exit | self handleExit: exit ]
	] in ClapCommandLineHandler>>activate
	Receiver: a ClapCommandLineHandler
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
	Receiver: [
		ClapContext withPragmaCommands
			beObeyingExits;
			setStdio: Stdio;
			arguments[..]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		outerContext: 	ClapCommandLineHandler>>activate
		compiledBlock: 	a CompiledBlock: [
		ClapContext withPragmaCommands
			beObe[..]
		numArgs: 	0
		receiver: 	a ClapCommandLineHandler



--- The full stack ---
ClapMicrodownBookReferenceCheckerCommand(Object)>>halt
ClapMicrodownBookReferenceCheckerCommand>>execute
[ :args |
			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].
			(self with: args) execute ] in ClapMicrodownBookReferenceCheckerCommand class>>commandSpecification
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
ClapCommand(ClapParameter)>>valueFor:with:
[ super valueFor: aMatch with: arg ] in ClapCommand>>valueFor:with:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
ClapNamedMatch(ClapCompositeMatch)>>matchedSubcommand:ifNone:
ClapCommand>>valueFor:with:
ClapNamedMatch(ClapExpression)>>value:
[ :sub | sub value: arg ] in ClapRoot(ClapCommand)>>valueFor:with:
FullBlockClosure(BlockClosure)>>cull:
[ :cmdMatch | foundBlock cull: cmdMatch ] in ClapCompositeMatch>>matchedSubcommand:ifNone:
FullBlockClosure(BlockClosure)>>cull:
[ :each |
			(aBlock value: each)
				ifTrue: [ ^ foundBlock cull: each ] ] in OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
ClapCompositeMatch>>matchedSubcommand:ifNone:
ClapRoot(ClapCommand)>>valueFor:with:
ClapCompositeMatch(ClapExpression)>>value:
[ :m |
				m value: self.
				self exitSuccess ] in [
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ]
			ifMismatch: [ self noneMatched ]
	] in ClapContext>>executeToExit:
FullBlockClosure(BlockClosure)>>cull:
ClapCompositeMatch(ClapSubExpression)>>ifMatch:ifMismatch:
ClapContext>>ifMatch:ifMismatch:
[
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ]
			ifMismatch: [ self noneMatched ]
	] in ClapContext>>executeToExit:
FullBlockClosure(BlockClosure)>>on:do:
ClapContext>>executeToExit:
[
		ClapContext withPragmaCommands
			beObeyingExits;
			setStdio: Stdio;
			arguments: self arguments;
			executeToExit: [ :exit | self handleExit: exit ]
	] in ClapCommandLineHandler>>activate
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE

4 August 2024 10:57:56.547758 am

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 74b785ff-50d8-0d00-86f4-c64e0df24b96 Jun 28 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 74b785ff-50d8-0d00-86f4-c64e0df24b96 Jun 28 2024
v10.3.0 - Commit: ce151716 - Date: 2024-06-28 10:12:41 +0200

Image: Pharo12.0.0SNAPSHOT [Build information: Pharo-12.0.0+SNAPSHOT.build.1526.sha.404d3af7531f656b5c294762c79011c10bea1ef3 (64 Bit)]

ClapMicrodownBookReferenceCheckerCommand(Object)>>halt
	Receiver: a ClapMicrodownBookReferenceCheckerCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		arguments: 	a ClapNamedMatch
		project: 	nil


ClapMicrodownBookReferenceCheckerCommand>>execute
	Receiver: a ClapMicrodownBookReferenceCheckerCommand
	Arguments and temporary variables: 
		file: 	File @ index.md
		checker: 	nil
	Receiver's instance variables: 
		arguments: 	a ClapNamedMatch
		project: 	nil


[ :args |
			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].
			(self with: args) execute ] in ClapMicrodownBookReferenceCheckerCommand class>>commandSpecification
	Receiver: ClapMicrodownBookReferenceCheckerCommand
	Arguments and temporary variables: 
		args: 	a ClapNamedMatch
	Receiver's instance variables: 
		superclass: 	ClapPillarCommand
		methodDict: 	a MethodDictionary(#execute->ClapMicrodownBookReferenceCheckerC[..]
		format: 	65538
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (execution) - 3 selector(s))
		subclasses: 	nil
		name: 	#ClapMicrodownBookReferenceCheckerCommand
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	7449745
		packageTag: 	a PackageTag(Uncategorized)


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :args |
			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].
			(se[..]
	Arguments and temporary variables: 
		anArg: 	a ClapNamedMatch
	Receiver's instance variables: 
		outerContext: 	ClapMicrodownBookReferenceCheckerCommand class>>commandSpecif[..]
		compiledBlock: 	a CompiledBlock: [ :args |
			args at: #helpFlag ifPresent: [..]
		numArgs: 	1
		receiver: 	ClapMicrodownBookReferenceCheckerCommand


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ :args |
			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].
			(se[..]
	Arguments and temporary variables: 
		firstArg: 	a ClapNamedMatch
		secondArg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		outerContext: 	ClapMicrodownBookReferenceCheckerCommand class>>commandSpecif[..]
		compiledBlock: 	a CompiledBlock: [ :args |
			args at: #helpFlag ifPresent: [..]
		numArgs: 	1
		receiver: 	ClapMicrodownBookReferenceCheckerCommand


ClapCommand(ClapParameter)>>valueFor:with:
	Receiver: a ClapCommand(referenceCheck)
	Arguments and temporary variables: 
		aMatch: 	a ClapNamedMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		identifier: 	#referenceCheck
		canonicalName: 	nil
		description: 	'Check the duplicated or unknown references'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help | help val[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #requestedFile[..]
		positionals: 	an OrderedCollection(a ClapPositional(requestedFile))
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help))
		subcommands: 	an OrderedCollection()


[ super valueFor: aMatch with: arg ] in ClapCommand>>valueFor:with:
	Receiver: a ClapCommand(referenceCheck)
	Arguments and temporary variables: 
		aMatch: 	a ClapNamedMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		identifier: 	#referenceCheck
		canonicalName: 	nil
		description: 	'Check the duplicated or unknown references'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help | help val[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #requestedFile[..]
		positionals: 	an OrderedCollection(a ClapPositional(requestedFile))
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help))
		subcommands: 	an OrderedCollection()


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(a ClapWordMatch)
	Arguments and temporary variables: 
		aBlock: 	[ :child | specification subcommands includes: child specification ]
		foundBlock: 	[ :cmdMatch | foundBlock cull: cmdMatch ]
		exceptionBlock: 	[ super valueFor: aMatch with: arg ]
	Receiver's instance variables: 
		array: 	an Array(a ClapWordMatch nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


ClapNamedMatch(ClapCompositeMatch)>>matchedSubcommand:ifNone:
	Receiver: a ClapNamedMatch
	Arguments and temporary variables: 
		foundBlock: 	[ :sub | sub value: arg ]
		noneBlock: 	[ super valueFor: aMatch with: arg ]
	Receiver's instance variables: 
		specification: 	a ClapCommand(referenceCheck)
		parent: 	a ClapCompositeMatch
		startIndex: 	1
		children: 	an OrderedCollection(a ClapWordMatch)
		keyword: 	'referenceCheck'


ClapCommand>>valueFor:with:
	Receiver: a ClapCommand(referenceCheck)
	Arguments and temporary variables: 
		aMatch: 	a ClapNamedMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		identifier: 	#referenceCheck
		canonicalName: 	nil
		description: 	'Check the duplicated or unknown references'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help | help val[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #requestedFile[..]
		positionals: 	an OrderedCollection(a ClapPositional(requestedFile))
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help))
		subcommands: 	an OrderedCollection()


ClapNamedMatch(ClapExpression)>>value:
	Receiver: a ClapNamedMatch
	Arguments and temporary variables: 
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		specification: 	a ClapCommand(referenceCheck)
		parent: 	a ClapCompositeMatch
		startIndex: 	1
		children: 	an OrderedCollection(a ClapWordMatch)
		keyword: 	'referenceCheck'


[ :sub | sub value: arg ] in ClapRoot(ClapCommand)>>valueFor:with:
	Receiver: a ClapRoot(clap)
	Arguments and temporary variables: 
		aMatch: 	a ClapCompositeMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
		sub: 	a ClapNamedMatch
	Receiver's instance variables: 
		identifier: 	#clap
		canonicalName: 	nil
		description: 	'Entry point for commands implemented with Clap'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help |
				help[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #helpCommand->[..]
		positionals: 	an OrderedCollection()
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help) a ClapFlag(save) a ClapFlag(no[..]
		subcommands: 	an OrderedCollection(a ClapCommand(help) a ClapCommand(image) [..]


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :sub | sub value: arg ]
	Arguments and temporary variables: 
		anArg: 	a ClapNamedMatch
	Receiver's instance variables: 
		outerContext: 	ClapRoot(ClapCommand)>>valueFor:with:
		compiledBlock: 	a CompiledBlock: [ :sub | sub value: arg ]
		numArgs: 	1
		receiver: 	a ClapRoot(clap)


[ :cmdMatch | foundBlock cull: cmdMatch ] in ClapCompositeMatch>>matchedSubcommand:ifNone:
	Receiver: a ClapCompositeMatch
	Arguments and temporary variables: 
		foundBlock: 	[ :sub | sub value: arg ]
		noneBlock: 	[ super valueFor: aMatch with: arg ]
		cmdMatch: 	a ClapNamedMatch
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		parent: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
		startIndex: 	1
		children: 	an OrderedCollection(a ClapNamedMatch)


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :cmdMatch | foundBlock cull: cmdMatch ]
	Arguments and temporary variables: 
		anArg: 	a ClapNamedMatch
	Receiver's instance variables: 
		outerContext: 	ClapCompositeMatch>>matchedSubcommand:ifNone:
		compiledBlock: 	a CompiledBlock: [ :cmdMatch | foundBlock cull: cmdMatch ]
		numArgs: 	1
		receiver: 	a ClapCompositeMatch


[ :each |
			(aBlock value: each)
				ifTrue: [ ^ foundBlock cull: each ] ] in OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(a ClapNamedMatch)
	Arguments and temporary variables: 
		aBlock: 	[ :child | specification subcommands includes: child specification ]
		foundBlock: 	[ :cmdMatch | foundBlock cull: cmdMatch ]
		exceptionBlock: 	[ super valueFor: aMatch with: arg ]
		each: 	a ClapNamedMatch
	Receiver's instance variables: 
		array: 	an Array(a ClapNamedMatch nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


OrderedCollection>>do:
	Receiver: an OrderedCollection(a ClapNamedMatch)
	Arguments and temporary variables: 
		aBlock: 	[ :each |
			(aBlock value: each)
				ifTrue: [ ^ foundBlock cull: [..]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a ClapNamedMatch nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(a ClapNamedMatch)
	Arguments and temporary variables: 
		aBlock: 	[ :child | specification subcommands includes: child specification ]
		foundBlock: 	[ :cmdMatch | foundBlock cull: cmdMatch ]
		exceptionBlock: 	[ super valueFor: aMatch with: arg ]
	Receiver's instance variables: 
		array: 	an Array(a ClapNamedMatch nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


ClapCompositeMatch>>matchedSubcommand:ifNone:
	Receiver: a ClapCompositeMatch
	Arguments and temporary variables: 
		foundBlock: 	[ :sub | sub value: arg ]
		noneBlock: 	[ super valueFor: aMatch with: arg ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		parent: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
		startIndex: 	1
		children: 	an OrderedCollection(a ClapNamedMatch)


ClapRoot(ClapCommand)>>valueFor:with:
	Receiver: a ClapRoot(clap)
	Arguments and temporary variables: 
		aMatch: 	a ClapCompositeMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		identifier: 	#clap
		canonicalName: 	nil
		description: 	'Entry point for commands implemented with Clap'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help |
				help[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #helpCommand->[..]
		positionals: 	an OrderedCollection()
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help) a ClapFlag(save) a ClapFlag(no[..]
		subcommands: 	an OrderedCollection(a ClapCommand(help) a ClapCommand(image) [..]


ClapCompositeMatch(ClapExpression)>>value:
	Receiver: a ClapCompositeMatch
	Arguments and temporary variables: 
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		parent: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
		startIndex: 	1
		children: 	an OrderedCollection(a ClapNamedMatch)


[ :m |
				m value: self.
				self exitSuccess ] in [
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ]
			ifMismatch: [ self noneMatched ]
	] in ClapContext>>executeToExit:
	Receiver: a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Arguments and temporary variables: 
		exitBlock: 	[ :exit | self handleExit: exit ]
		m: 	a ClapCompositeMatch
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		arguments: 	an OrderedCollection('referenceCheck' 'index.md')
		obeyingExits: 	true
		stdio: 	Stdio
		match: 	a ClapCompositeMatch
		leftovers: 	an OrderedCollection()
		session: 	a WorkingSession
		exitException: 	nil


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :m |
				m value: self.
				self exitSuccess ]
	Arguments and temporary variables: 
		anArg: 	a ClapCompositeMatch
	Receiver's instance variables: 
		outerContext: 	[
		self rememberSession;
			ifMatch: [ :m |
				m value: sel[..]
		compiledBlock: 	a CompiledBlock: [ :m |
				m value: self.
				self exitSucc[..]
		numArgs: 	1
		receiver: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))


ClapCompositeMatch(ClapSubExpression)>>ifMatch:ifMismatch:
	Receiver: a ClapCompositeMatch
	Arguments and temporary variables: 
		matchBlock: 	[ :m |
				m value: self.
				self exitSuccess ]
		mismatchBlock: 	[ self noneMatched ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		parent: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
		startIndex: 	1
		children: 	an OrderedCollection(a ClapNamedMatch)


ClapContext>>ifMatch:ifMismatch:
	Receiver: a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Arguments and temporary variables: 
		matchBlock: 	[ :m |
				m value: self.
				self exitSuccess ]
		failBlock: 	[ self noneMatched ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		arguments: 	an OrderedCollection('referenceCheck' 'index.md')
		obeyingExits: 	true
		stdio: 	Stdio
		match: 	a ClapCompositeMatch
		leftovers: 	an OrderedCollection()
		session: 	a WorkingSession
		exitException: 	nil


[
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ]
			ifMismatch: [ self noneMatched ]
	] in ClapContext>>executeToExit:
	Receiver: a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Arguments and temporary variables: 
		exitBlock: 	[ :exit | self handleExit: exit ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		arguments: 	an OrderedCollection('referenceCheck' 'index.md')
		obeyingExits: 	true
		stdio: 	Stdio
		match: 	a ClapCompositeMatch
		leftovers: 	an OrderedCollection()
		session: 	a WorkingSession
		exitException: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ][..]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exception |
			exitException := exception.
			exitBlock v[..]
	Receiver's instance variables: 
		outerContext: 	ClapContext>>executeToExit:
		compiledBlock: 	a CompiledBlock: [
		self rememberSession;
			ifMatch: [ :m [..]
		numArgs: 	0
		receiver: 	a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))


ClapContext>>executeToExit:
	Receiver: a ClapContext(an OrderedCollection('referenceCheck' 'index.md'))
	Arguments and temporary variables: 
		exitBlock: 	[ :exit | self handleExit: exit ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		arguments: 	an OrderedCollection('referenceCheck' 'index.md')
		obeyingExits: 	true
		stdio: 	Stdio
		match: 	a ClapCompositeMatch
		leftovers: 	an OrderedCollection()
		session: 	a WorkingSession
		exitException: 	nil


[
		ClapContext withPragmaCommands
			beObeyingExits;
			setStdio: Stdio;
			arguments: self arguments;
			executeToExit: [ :exit | self handleExit: exit ]
	] in ClapCommandLineHandler>>activate
	Receiver: a ClapCommandLineHandler
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
	Receiver: [
		ClapContext withPragmaCommands
			beObeyingExits;
			setStdio: Stdio;
			arguments[..]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		outerContext: 	ClapCommandLineHandler>>activate
		compiledBlock: 	a CompiledBlock: [
		ClapContext withPragmaCommands
			beObe[..]
		numArgs: 	0
		receiver: 	a ClapCommandLineHandler



--- The full stack ---
ClapMicrodownBookReferenceCheckerCommand(Object)>>halt
ClapMicrodownBookReferenceCheckerCommand>>execute
[ :args |
			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].
			(self with: args) execute ] in ClapMicrodownBookReferenceCheckerCommand class>>commandSpecification
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
ClapCommand(ClapParameter)>>valueFor:with:
[ super valueFor: aMatch with: arg ] in ClapCommand>>valueFor:with:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
ClapNamedMatch(ClapCompositeMatch)>>matchedSubcommand:ifNone:
ClapCommand>>valueFor:with:
ClapNamedMatch(ClapExpression)>>value:
[ :sub | sub value: arg ] in ClapRoot(ClapCommand)>>valueFor:with:
FullBlockClosure(BlockClosure)>>cull:
[ :cmdMatch | foundBlock cull: cmdMatch ] in ClapCompositeMatch>>matchedSubcommand:ifNone:
FullBlockClosure(BlockClosure)>>cull:
[ :each |
			(aBlock value: each)
				ifTrue: [ ^ foundBlock cull: each ] ] in OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
ClapCompositeMatch>>matchedSubcommand:ifNone:
ClapRoot(ClapCommand)>>valueFor:with:
ClapCompositeMatch(ClapExpression)>>value:
[ :m |
				m value: self.
				self exitSuccess ] in [
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ]
			ifMismatch: [ self noneMatched ]
	] in ClapContext>>executeToExit:
FullBlockClosure(BlockClosure)>>cull:
ClapCompositeMatch(ClapSubExpression)>>ifMatch:ifMismatch:
ClapContext>>ifMatch:ifMismatch:
[
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ]
			ifMismatch: [ self noneMatched ]
	] in ClapContext>>executeToExit:
FullBlockClosure(BlockClosure)>>on:do:
ClapContext>>executeToExit:
[
		ClapContext withPragmaCommands
			beObeyingExits;
			setStdio: Stdio;
			arguments: self arguments;
			executeToExit: [ :exit | self handleExit: exit ]
	] in ClapCommandLineHandler>>activate
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE

4 August 2024 10:58:21.211603 am

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 74b785ff-50d8-0d00-86f4-c64e0df24b96 Jun 28 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 74b785ff-50d8-0d00-86f4-c64e0df24b96 Jun 28 2024
v10.3.0 - Commit: ce151716 - Date: 2024-06-28 10:12:41 +0200

Image: Pharo12.0.0SNAPSHOT [Build information: Pharo-12.0.0+SNAPSHOT.build.1526.sha.404d3af7531f656b5c294762c79011c10bea1ef3 (64 Bit)]

ClapMicrodownBookReferenceCheckerCommand(Object)>>halt
	Receiver: a ClapMicrodownBookReferenceCheckerCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		arguments: 	a ClapNamedMatch
		project: 	nil


ClapMicrodownBookReferenceCheckerCommand>>execute
	Receiver: a ClapMicrodownBookReferenceCheckerCommand
	Arguments and temporary variables: 
		file: 	File @ Chapters/bloc/element.md
		checker: 	nil
	Receiver's instance variables: 
		arguments: 	a ClapNamedMatch
		project: 	nil


[ :args |
			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].
			(self with: args) execute ] in ClapMicrodownBookReferenceCheckerCommand class>>commandSpecification
	Receiver: ClapMicrodownBookReferenceCheckerCommand
	Arguments and temporary variables: 
		args: 	a ClapNamedMatch
	Receiver's instance variables: 
		superclass: 	ClapPillarCommand
		methodDict: 	a MethodDictionary(#execute->ClapMicrodownBookReferenceCheckerC[..]
		format: 	65538
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (execution) - 3 selector(s))
		subclasses: 	nil
		name: 	#ClapMicrodownBookReferenceCheckerCommand
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	7449745
		packageTag: 	a PackageTag(Uncategorized)


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :args |
			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].
			(se[..]
	Arguments and temporary variables: 
		anArg: 	a ClapNamedMatch
	Receiver's instance variables: 
		outerContext: 	ClapMicrodownBookReferenceCheckerCommand class>>commandSpecif[..]
		compiledBlock: 	a CompiledBlock: [ :args |
			args at: #helpFlag ifPresent: [..]
		numArgs: 	1
		receiver: 	ClapMicrodownBookReferenceCheckerCommand


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ :args |
			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].
			(se[..]
	Arguments and temporary variables: 
		firstArg: 	a ClapNamedMatch
		secondArg: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bl[..]
	Receiver's instance variables: 
		outerContext: 	ClapMicrodownBookReferenceCheckerCommand class>>commandSpecif[..]
		compiledBlock: 	a CompiledBlock: [ :args |
			args at: #helpFlag ifPresent: [..]
		numArgs: 	1
		receiver: 	ClapMicrodownBookReferenceCheckerCommand


ClapCommand(ClapParameter)>>valueFor:with:
	Receiver: a ClapCommand(referenceCheck)
	Arguments and temporary variables: 
		aMatch: 	a ClapNamedMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/ele[..]
	Receiver's instance variables: 
		identifier: 	#referenceCheck
		canonicalName: 	nil
		description: 	'Check the duplicated or unknown references'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help | help val[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #requestedFile[..]
		positionals: 	an OrderedCollection(a ClapPositional(requestedFile))
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help))
		subcommands: 	an OrderedCollection()


[ super valueFor: aMatch with: arg ] in ClapCommand>>valueFor:with:
	Receiver: a ClapCommand(referenceCheck)
	Arguments and temporary variables: 
		aMatch: 	a ClapNamedMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/ele[..]
	Receiver's instance variables: 
		identifier: 	#referenceCheck
		canonicalName: 	nil
		description: 	'Check the duplicated or unknown references'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help | help val[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #requestedFile[..]
		positionals: 	an OrderedCollection(a ClapPositional(requestedFile))
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help))
		subcommands: 	an OrderedCollection()


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(a ClapWordMatch)
	Arguments and temporary variables: 
		aBlock: 	[ :child | specification subcommands includes: child specification ]
		foundBlock: 	[ :cmdMatch | foundBlock cull: cmdMatch ]
		exceptionBlock: 	[ super valueFor: aMatch with: arg ]
	Receiver's instance variables: 
		array: 	an Array(a ClapWordMatch nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


ClapNamedMatch(ClapCompositeMatch)>>matchedSubcommand:ifNone:
	Receiver: a ClapNamedMatch
	Arguments and temporary variables: 
		foundBlock: 	[ :sub | sub value: arg ]
		noneBlock: 	[ super valueFor: aMatch with: arg ]
	Receiver's instance variables: 
		specification: 	a ClapCommand(referenceCheck)
		parent: 	a ClapCompositeMatch
		startIndex: 	1
		children: 	an OrderedCollection(a ClapWordMatch)
		keyword: 	'referenceCheck'


ClapCommand>>valueFor:with:
	Receiver: a ClapCommand(referenceCheck)
	Arguments and temporary variables: 
		aMatch: 	a ClapNamedMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/ele[..]
	Receiver's instance variables: 
		identifier: 	#referenceCheck
		canonicalName: 	nil
		description: 	'Check the duplicated or unknown references'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help | help val[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #requestedFile[..]
		positionals: 	an OrderedCollection(a ClapPositional(requestedFile))
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help))
		subcommands: 	an OrderedCollection()


ClapNamedMatch(ClapExpression)>>value:
	Receiver: a ClapNamedMatch
	Arguments and temporary variables: 
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/ele[..]
	Receiver's instance variables: 
		specification: 	a ClapCommand(referenceCheck)
		parent: 	a ClapCompositeMatch
		startIndex: 	1
		children: 	an OrderedCollection(a ClapWordMatch)
		keyword: 	'referenceCheck'


[ :sub | sub value: arg ] in ClapRoot(ClapCommand)>>valueFor:with:
	Receiver: a ClapRoot(clap)
	Arguments and temporary variables: 
		aMatch: 	a ClapCompositeMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/ele[..]
		sub: 	a ClapNamedMatch
	Receiver's instance variables: 
		identifier: 	#clap
		canonicalName: 	nil
		description: 	'Entry point for commands implemented with Clap'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help |
				help[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #helpCommand->[..]
		positionals: 	an OrderedCollection()
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help) a ClapFlag(save) a ClapFlag(no[..]
		subcommands: 	an OrderedCollection(a ClapCommand(help) a ClapCommand(image) [..]


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :sub | sub value: arg ]
	Arguments and temporary variables: 
		anArg: 	a ClapNamedMatch
	Receiver's instance variables: 
		outerContext: 	ClapRoot(ClapCommand)>>valueFor:with:
		compiledBlock: 	a CompiledBlock: [ :sub | sub value: arg ]
		numArgs: 	1
		receiver: 	a ClapRoot(clap)


[ :cmdMatch | foundBlock cull: cmdMatch ] in ClapCompositeMatch>>matchedSubcommand:ifNone:
	Receiver: a ClapCompositeMatch
	Arguments and temporary variables: 
		foundBlock: 	[ :sub | sub value: arg ]
		noneBlock: 	[ super valueFor: aMatch with: arg ]
		cmdMatch: 	a ClapNamedMatch
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		parent: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/[..]
		startIndex: 	1
		children: 	an OrderedCollection(a ClapNamedMatch)


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :cmdMatch | foundBlock cull: cmdMatch ]
	Arguments and temporary variables: 
		anArg: 	a ClapNamedMatch
	Receiver's instance variables: 
		outerContext: 	ClapCompositeMatch>>matchedSubcommand:ifNone:
		compiledBlock: 	a CompiledBlock: [ :cmdMatch | foundBlock cull: cmdMatch ]
		numArgs: 	1
		receiver: 	a ClapCompositeMatch


[ :each |
			(aBlock value: each)
				ifTrue: [ ^ foundBlock cull: each ] ] in OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(a ClapNamedMatch)
	Arguments and temporary variables: 
		aBlock: 	[ :child | specification subcommands includes: child specification ]
		foundBlock: 	[ :cmdMatch | foundBlock cull: cmdMatch ]
		exceptionBlock: 	[ super valueFor: aMatch with: arg ]
		each: 	a ClapNamedMatch
	Receiver's instance variables: 
		array: 	an Array(a ClapNamedMatch nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


OrderedCollection>>do:
	Receiver: an OrderedCollection(a ClapNamedMatch)
	Arguments and temporary variables: 
		aBlock: 	[ :each |
			(aBlock value: each)
				ifTrue: [ ^ foundBlock cull: [..]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a ClapNamedMatch nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(a ClapNamedMatch)
	Arguments and temporary variables: 
		aBlock: 	[ :child | specification subcommands includes: child specification ]
		foundBlock: 	[ :cmdMatch | foundBlock cull: cmdMatch ]
		exceptionBlock: 	[ super valueFor: aMatch with: arg ]
	Receiver's instance variables: 
		array: 	an Array(a ClapNamedMatch nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


ClapCompositeMatch>>matchedSubcommand:ifNone:
	Receiver: a ClapCompositeMatch
	Arguments and temporary variables: 
		foundBlock: 	[ :sub | sub value: arg ]
		noneBlock: 	[ super valueFor: aMatch with: arg ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		parent: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/[..]
		startIndex: 	1
		children: 	an OrderedCollection(a ClapNamedMatch)


ClapRoot(ClapCommand)>>valueFor:with:
	Receiver: a ClapRoot(clap)
	Arguments and temporary variables: 
		aMatch: 	a ClapCompositeMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/ele[..]
	Receiver's instance variables: 
		identifier: 	#clap
		canonicalName: 	nil
		description: 	'Entry point for commands implemented with Clap'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help |
				help[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #helpCommand->[..]
		positionals: 	an OrderedCollection()
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help) a ClapFlag(save) a ClapFlag(no[..]
		subcommands: 	an OrderedCollection(a ClapCommand(help) a ClapCommand(image) [..]


ClapCompositeMatch(ClapExpression)>>value:
	Receiver: a ClapCompositeMatch
	Arguments and temporary variables: 
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/ele[..]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		parent: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/[..]
		startIndex: 	1
		children: 	an OrderedCollection(a ClapNamedMatch)


[ :m |
				m value: self.
				self exitSuccess ] in [
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ]
			ifMismatch: [ self noneMatched ]
	] in ClapContext>>executeToExit:
	Receiver: a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/element.md'))
	Arguments and temporary variables: 
		exitBlock: 	[ :exit | self handleExit: exit ]
		m: 	a ClapCompositeMatch
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		arguments: 	an OrderedCollection('referenceCheck' 'Chapters/bloc/element.md')
		obeyingExits: 	true
		stdio: 	Stdio
		match: 	a ClapCompositeMatch
		leftovers: 	an OrderedCollection()
		session: 	a WorkingSession
		exitException: 	nil


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :m |
				m value: self.
				self exitSuccess ]
	Arguments and temporary variables: 
		anArg: 	a ClapCompositeMatch
	Receiver's instance variables: 
		outerContext: 	[
		self rememberSession;
			ifMatch: [ :m |
				m value: sel[..]
		compiledBlock: 	a CompiledBlock: [ :m |
				m value: self.
				self exitSucc[..]
		numArgs: 	1
		receiver: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/blo[..]


ClapCompositeMatch(ClapSubExpression)>>ifMatch:ifMismatch:
	Receiver: a ClapCompositeMatch
	Arguments and temporary variables: 
		matchBlock: 	[ :m |
				m value: self.
				self exitSuccess ]
		mismatchBlock: 	[ self noneMatched ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		parent: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/[..]
		startIndex: 	1
		children: 	an OrderedCollection(a ClapNamedMatch)


ClapContext>>ifMatch:ifMismatch:
	Receiver: a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/element.md'))
	Arguments and temporary variables: 
		matchBlock: 	[ :m |
				m value: self.
				self exitSuccess ]
		failBlock: 	[ self noneMatched ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		arguments: 	an OrderedCollection('referenceCheck' 'Chapters/bloc/element.md')
		obeyingExits: 	true
		stdio: 	Stdio
		match: 	a ClapCompositeMatch
		leftovers: 	an OrderedCollection()
		session: 	a WorkingSession
		exitException: 	nil


[
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ]
			ifMismatch: [ self noneMatched ]
	] in ClapContext>>executeToExit:
	Receiver: a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/element.md'))
	Arguments and temporary variables: 
		exitBlock: 	[ :exit | self handleExit: exit ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		arguments: 	an OrderedCollection('referenceCheck' 'Chapters/bloc/element.md')
		obeyingExits: 	true
		stdio: 	Stdio
		match: 	a ClapCompositeMatch
		leftovers: 	an OrderedCollection()
		session: 	a WorkingSession
		exitException: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ][..]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exception |
			exitException := exception.
			exitBlock v[..]
	Receiver's instance variables: 
		outerContext: 	ClapContext>>executeToExit:
		compiledBlock: 	a CompiledBlock: [
		self rememberSession;
			ifMatch: [ :m [..]
		numArgs: 	0
		receiver: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/blo[..]


ClapContext>>executeToExit:
	Receiver: a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/element.md'))
	Arguments and temporary variables: 
		exitBlock: 	[ :exit | self handleExit: exit ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		arguments: 	an OrderedCollection('referenceCheck' 'Chapters/bloc/element.md')
		obeyingExits: 	true
		stdio: 	Stdio
		match: 	a ClapCompositeMatch
		leftovers: 	an OrderedCollection()
		session: 	a WorkingSession
		exitException: 	nil


[
		ClapContext withPragmaCommands
			beObeyingExits;
			setStdio: Stdio;
			arguments: self arguments;
			executeToExit: [ :exit | self handleExit: exit ]
	] in ClapCommandLineHandler>>activate
	Receiver: a ClapCommandLineHandler
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
	Receiver: [
		ClapContext withPragmaCommands
			beObeyingExits;
			setStdio: Stdio;
			arguments[..]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		outerContext: 	ClapCommandLineHandler>>activate
		compiledBlock: 	a CompiledBlock: [
		ClapContext withPragmaCommands
			beObe[..]
		numArgs: 	0
		receiver: 	a ClapCommandLineHandler



--- The full stack ---
ClapMicrodownBookReferenceCheckerCommand(Object)>>halt
ClapMicrodownBookReferenceCheckerCommand>>execute
[ :args |
			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].
			(self with: args) execute ] in ClapMicrodownBookReferenceCheckerCommand class>>commandSpecification
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
ClapCommand(ClapParameter)>>valueFor:with:
[ super valueFor: aMatch with: arg ] in ClapCommand>>valueFor:with:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
ClapNamedMatch(ClapCompositeMatch)>>matchedSubcommand:ifNone:
ClapCommand>>valueFor:with:
ClapNamedMatch(ClapExpression)>>value:
[ :sub | sub value: arg ] in ClapRoot(ClapCommand)>>valueFor:with:
FullBlockClosure(BlockClosure)>>cull:
[ :cmdMatch | foundBlock cull: cmdMatch ] in ClapCompositeMatch>>matchedSubcommand:ifNone:
FullBlockClosure(BlockClosure)>>cull:
[ :each |
			(aBlock value: each)
				ifTrue: [ ^ foundBlock cull: each ] ] in OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
ClapCompositeMatch>>matchedSubcommand:ifNone:
ClapRoot(ClapCommand)>>valueFor:with:
ClapCompositeMatch(ClapExpression)>>value:
[ :m |
				m value: self.
				self exitSuccess ] in [
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ]
			ifMismatch: [ self noneMatched ]
	] in ClapContext>>executeToExit:
FullBlockClosure(BlockClosure)>>cull:
ClapCompositeMatch(ClapSubExpression)>>ifMatch:ifMismatch:
ClapContext>>ifMatch:ifMismatch:
[
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ]
			ifMismatch: [ self noneMatched ]
	] in ClapContext>>executeToExit:
FullBlockClosure(BlockClosure)>>on:do:
ClapContext>>executeToExit:
[
		ClapContext withPragmaCommands
			beObeyingExits;
			setStdio: Stdio;
			arguments: self arguments;
			executeToExit: [ :exit | self handleExit: exit ]
	] in ClapCommandLineHandler>>activate
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE

4 August 2024 10:58:44.028991 am

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 74b785ff-50d8-0d00-86f4-c64e0df24b96 Jun 28 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 74b785ff-50d8-0d00-86f4-c64e0df24b96 Jun 28 2024
v10.3.0 - Commit: ce151716 - Date: 2024-06-28 10:12:41 +0200

Image: Pharo12.0.0SNAPSHOT [Build information: Pharo-12.0.0+SNAPSHOT.build.1526.sha.404d3af7531f656b5c294762c79011c10bea1ef3 (64 Bit)]

ClapMicrodownBookReferenceCheckerCommand(Object)>>halt
	Receiver: a ClapMicrodownBookReferenceCheckerCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		arguments: 	a ClapNamedMatch
		project: 	nil


ClapMicrodownBookReferenceCheckerCommand>>execute
	Receiver: a ClapMicrodownBookReferenceCheckerCommand
	Arguments and temporary variables: 
		file: 	File @ Chapters/bloc/element.md
		checker: 	nil
	Receiver's instance variables: 
		arguments: 	a ClapNamedMatch
		project: 	nil


[ :args |
			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].
			(self with: args) execute ] in ClapMicrodownBookReferenceCheckerCommand class>>commandSpecification
	Receiver: ClapMicrodownBookReferenceCheckerCommand
	Arguments and temporary variables: 
		args: 	a ClapNamedMatch
	Receiver's instance variables: 
		superclass: 	ClapPillarCommand
		methodDict: 	a MethodDictionary(#execute->ClapMicrodownBookReferenceCheckerC[..]
		format: 	65538
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (execution) - 3 selector(s))
		subclasses: 	nil
		name: 	#ClapMicrodownBookReferenceCheckerCommand
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	7449745
		packageTag: 	a PackageTag(Uncategorized)


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :args |
			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].
			(se[..]
	Arguments and temporary variables: 
		anArg: 	a ClapNamedMatch
	Receiver's instance variables: 
		outerContext: 	ClapMicrodownBookReferenceCheckerCommand class>>commandSpecif[..]
		compiledBlock: 	a CompiledBlock: [ :args |
			args at: #helpFlag ifPresent: [..]
		numArgs: 	1
		receiver: 	ClapMicrodownBookReferenceCheckerCommand


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ :args |
			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].
			(se[..]
	Arguments and temporary variables: 
		firstArg: 	a ClapNamedMatch
		secondArg: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bl[..]
	Receiver's instance variables: 
		outerContext: 	ClapMicrodownBookReferenceCheckerCommand class>>commandSpecif[..]
		compiledBlock: 	a CompiledBlock: [ :args |
			args at: #helpFlag ifPresent: [..]
		numArgs: 	1
		receiver: 	ClapMicrodownBookReferenceCheckerCommand


ClapCommand(ClapParameter)>>valueFor:with:
	Receiver: a ClapCommand(referenceCheck)
	Arguments and temporary variables: 
		aMatch: 	a ClapNamedMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/ele[..]
	Receiver's instance variables: 
		identifier: 	#referenceCheck
		canonicalName: 	nil
		description: 	'Check the duplicated or unknown references'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help | help val[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #requestedFile[..]
		positionals: 	an OrderedCollection(a ClapPositional(requestedFile))
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help))
		subcommands: 	an OrderedCollection()


[ super valueFor: aMatch with: arg ] in ClapCommand>>valueFor:with:
	Receiver: a ClapCommand(referenceCheck)
	Arguments and temporary variables: 
		aMatch: 	a ClapNamedMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/ele[..]
	Receiver's instance variables: 
		identifier: 	#referenceCheck
		canonicalName: 	nil
		description: 	'Check the duplicated or unknown references'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help | help val[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #requestedFile[..]
		positionals: 	an OrderedCollection(a ClapPositional(requestedFile))
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help))
		subcommands: 	an OrderedCollection()


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(a ClapWordMatch)
	Arguments and temporary variables: 
		aBlock: 	[ :child | specification subcommands includes: child specification ]
		foundBlock: 	[ :cmdMatch | foundBlock cull: cmdMatch ]
		exceptionBlock: 	[ super valueFor: aMatch with: arg ]
	Receiver's instance variables: 
		array: 	an Array(a ClapWordMatch nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


ClapNamedMatch(ClapCompositeMatch)>>matchedSubcommand:ifNone:
	Receiver: a ClapNamedMatch
	Arguments and temporary variables: 
		foundBlock: 	[ :sub | sub value: arg ]
		noneBlock: 	[ super valueFor: aMatch with: arg ]
	Receiver's instance variables: 
		specification: 	a ClapCommand(referenceCheck)
		parent: 	a ClapCompositeMatch
		startIndex: 	1
		children: 	an OrderedCollection(a ClapWordMatch)
		keyword: 	'referenceCheck'


ClapCommand>>valueFor:with:
	Receiver: a ClapCommand(referenceCheck)
	Arguments and temporary variables: 
		aMatch: 	a ClapNamedMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/ele[..]
	Receiver's instance variables: 
		identifier: 	#referenceCheck
		canonicalName: 	nil
		description: 	'Check the duplicated or unknown references'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help | help val[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #requestedFile[..]
		positionals: 	an OrderedCollection(a ClapPositional(requestedFile))
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help))
		subcommands: 	an OrderedCollection()


ClapNamedMatch(ClapExpression)>>value:
	Receiver: a ClapNamedMatch
	Arguments and temporary variables: 
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/ele[..]
	Receiver's instance variables: 
		specification: 	a ClapCommand(referenceCheck)
		parent: 	a ClapCompositeMatch
		startIndex: 	1
		children: 	an OrderedCollection(a ClapWordMatch)
		keyword: 	'referenceCheck'


[ :sub | sub value: arg ] in ClapRoot(ClapCommand)>>valueFor:with:
	Receiver: a ClapRoot(clap)
	Arguments and temporary variables: 
		aMatch: 	a ClapCompositeMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/ele[..]
		sub: 	a ClapNamedMatch
	Receiver's instance variables: 
		identifier: 	#clap
		canonicalName: 	nil
		description: 	'Entry point for commands implemented with Clap'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help |
				help[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #helpCommand->[..]
		positionals: 	an OrderedCollection()
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help) a ClapFlag(save) a ClapFlag(no[..]
		subcommands: 	an OrderedCollection(a ClapCommand(help) a ClapCommand(image) [..]


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :sub | sub value: arg ]
	Arguments and temporary variables: 
		anArg: 	a ClapNamedMatch
	Receiver's instance variables: 
		outerContext: 	ClapRoot(ClapCommand)>>valueFor:with:
		compiledBlock: 	a CompiledBlock: [ :sub | sub value: arg ]
		numArgs: 	1
		receiver: 	a ClapRoot(clap)


[ :cmdMatch | foundBlock cull: cmdMatch ] in ClapCompositeMatch>>matchedSubcommand:ifNone:
	Receiver: a ClapCompositeMatch
	Arguments and temporary variables: 
		foundBlock: 	[ :sub | sub value: arg ]
		noneBlock: 	[ super valueFor: aMatch with: arg ]
		cmdMatch: 	a ClapNamedMatch
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		parent: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/[..]
		startIndex: 	1
		children: 	an OrderedCollection(a ClapNamedMatch)


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :cmdMatch | foundBlock cull: cmdMatch ]
	Arguments and temporary variables: 
		anArg: 	a ClapNamedMatch
	Receiver's instance variables: 
		outerContext: 	ClapCompositeMatch>>matchedSubcommand:ifNone:
		compiledBlock: 	a CompiledBlock: [ :cmdMatch | foundBlock cull: cmdMatch ]
		numArgs: 	1
		receiver: 	a ClapCompositeMatch


[ :each |
			(aBlock value: each)
				ifTrue: [ ^ foundBlock cull: each ] ] in OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(a ClapNamedMatch)
	Arguments and temporary variables: 
		aBlock: 	[ :child | specification subcommands includes: child specification ]
		foundBlock: 	[ :cmdMatch | foundBlock cull: cmdMatch ]
		exceptionBlock: 	[ super valueFor: aMatch with: arg ]
		each: 	a ClapNamedMatch
	Receiver's instance variables: 
		array: 	an Array(a ClapNamedMatch nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


OrderedCollection>>do:
	Receiver: an OrderedCollection(a ClapNamedMatch)
	Arguments and temporary variables: 
		aBlock: 	[ :each |
			(aBlock value: each)
				ifTrue: [ ^ foundBlock cull: [..]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a ClapNamedMatch nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(a ClapNamedMatch)
	Arguments and temporary variables: 
		aBlock: 	[ :child | specification subcommands includes: child specification ]
		foundBlock: 	[ :cmdMatch | foundBlock cull: cmdMatch ]
		exceptionBlock: 	[ super valueFor: aMatch with: arg ]
	Receiver's instance variables: 
		array: 	an Array(a ClapNamedMatch nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


ClapCompositeMatch>>matchedSubcommand:ifNone:
	Receiver: a ClapCompositeMatch
	Arguments and temporary variables: 
		foundBlock: 	[ :sub | sub value: arg ]
		noneBlock: 	[ super valueFor: aMatch with: arg ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		parent: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/[..]
		startIndex: 	1
		children: 	an OrderedCollection(a ClapNamedMatch)


ClapRoot(ClapCommand)>>valueFor:with:
	Receiver: a ClapRoot(clap)
	Arguments and temporary variables: 
		aMatch: 	a ClapCompositeMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/ele[..]
	Receiver's instance variables: 
		identifier: 	#clap
		canonicalName: 	nil
		description: 	'Entry point for commands implemented with Clap'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help |
				help[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #helpCommand->[..]
		positionals: 	an OrderedCollection()
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help) a ClapFlag(save) a ClapFlag(no[..]
		subcommands: 	an OrderedCollection(a ClapCommand(help) a ClapCommand(image) [..]


ClapCompositeMatch(ClapExpression)>>value:
	Receiver: a ClapCompositeMatch
	Arguments and temporary variables: 
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/ele[..]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		parent: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/[..]
		startIndex: 	1
		children: 	an OrderedCollection(a ClapNamedMatch)


[ :m |
				m value: self.
				self exitSuccess ] in [
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ]
			ifMismatch: [ self noneMatched ]
	] in ClapContext>>executeToExit:
	Receiver: a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/element.md'))
	Arguments and temporary variables: 
		exitBlock: 	[ :exit | self handleExit: exit ]
		m: 	a ClapCompositeMatch
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		arguments: 	an OrderedCollection('referenceCheck' 'Chapters/bloc/element.md')
		obeyingExits: 	true
		stdio: 	Stdio
		match: 	a ClapCompositeMatch
		leftovers: 	an OrderedCollection()
		session: 	a WorkingSession
		exitException: 	nil


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :m |
				m value: self.
				self exitSuccess ]
	Arguments and temporary variables: 
		anArg: 	a ClapCompositeMatch
	Receiver's instance variables: 
		outerContext: 	[
		self rememberSession;
			ifMatch: [ :m |
				m value: sel[..]
		compiledBlock: 	a CompiledBlock: [ :m |
				m value: self.
				self exitSucc[..]
		numArgs: 	1
		receiver: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/blo[..]


ClapCompositeMatch(ClapSubExpression)>>ifMatch:ifMismatch:
	Receiver: a ClapCompositeMatch
	Arguments and temporary variables: 
		matchBlock: 	[ :m |
				m value: self.
				self exitSuccess ]
		mismatchBlock: 	[ self noneMatched ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		parent: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/[..]
		startIndex: 	1
		children: 	an OrderedCollection(a ClapNamedMatch)


ClapContext>>ifMatch:ifMismatch:
	Receiver: a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/element.md'))
	Arguments and temporary variables: 
		matchBlock: 	[ :m |
				m value: self.
				self exitSuccess ]
		failBlock: 	[ self noneMatched ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		arguments: 	an OrderedCollection('referenceCheck' 'Chapters/bloc/element.md')
		obeyingExits: 	true
		stdio: 	Stdio
		match: 	a ClapCompositeMatch
		leftovers: 	an OrderedCollection()
		session: 	a WorkingSession
		exitException: 	nil


[
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ]
			ifMismatch: [ self noneMatched ]
	] in ClapContext>>executeToExit:
	Receiver: a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/element.md'))
	Arguments and temporary variables: 
		exitBlock: 	[ :exit | self handleExit: exit ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		arguments: 	an OrderedCollection('referenceCheck' 'Chapters/bloc/element.md')
		obeyingExits: 	true
		stdio: 	Stdio
		match: 	a ClapCompositeMatch
		leftovers: 	an OrderedCollection()
		session: 	a WorkingSession
		exitException: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ][..]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exception |
			exitException := exception.
			exitBlock v[..]
	Receiver's instance variables: 
		outerContext: 	ClapContext>>executeToExit:
		compiledBlock: 	a CompiledBlock: [
		self rememberSession;
			ifMatch: [ :m [..]
		numArgs: 	0
		receiver: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/blo[..]


ClapContext>>executeToExit:
	Receiver: a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/element.md'))
	Arguments and temporary variables: 
		exitBlock: 	[ :exit | self handleExit: exit ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		arguments: 	an OrderedCollection('referenceCheck' 'Chapters/bloc/element.md')
		obeyingExits: 	true
		stdio: 	Stdio
		match: 	a ClapCompositeMatch
		leftovers: 	an OrderedCollection()
		session: 	a WorkingSession
		exitException: 	nil


[
		ClapContext withPragmaCommands
			beObeyingExits;
			setStdio: Stdio;
			arguments: self arguments;
			executeToExit: [ :exit | self handleExit: exit ]
	] in ClapCommandLineHandler>>activate
	Receiver: a ClapCommandLineHandler
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
	Receiver: [
		ClapContext withPragmaCommands
			beObeyingExits;
			setStdio: Stdio;
			arguments[..]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		outerContext: 	ClapCommandLineHandler>>activate
		compiledBlock: 	a CompiledBlock: [
		ClapContext withPragmaCommands
			beObe[..]
		numArgs: 	0
		receiver: 	a ClapCommandLineHandler



--- The full stack ---
ClapMicrodownBookReferenceCheckerCommand(Object)>>halt
ClapMicrodownBookReferenceCheckerCommand>>execute
[ :args |
			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].
			(self with: args) execute ] in ClapMicrodownBookReferenceCheckerCommand class>>commandSpecification
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
ClapCommand(ClapParameter)>>valueFor:with:
[ super valueFor: aMatch with: arg ] in ClapCommand>>valueFor:with:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
ClapNamedMatch(ClapCompositeMatch)>>matchedSubcommand:ifNone:
ClapCommand>>valueFor:with:
ClapNamedMatch(ClapExpression)>>value:
[ :sub | sub value: arg ] in ClapRoot(ClapCommand)>>valueFor:with:
FullBlockClosure(BlockClosure)>>cull:
[ :cmdMatch | foundBlock cull: cmdMatch ] in ClapCompositeMatch>>matchedSubcommand:ifNone:
FullBlockClosure(BlockClosure)>>cull:
[ :each |
			(aBlock value: each)
				ifTrue: [ ^ foundBlock cull: each ] ] in OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
ClapCompositeMatch>>matchedSubcommand:ifNone:
ClapRoot(ClapCommand)>>valueFor:with:
ClapCompositeMatch(ClapExpression)>>value:
[ :m |
				m value: self.
				self exitSuccess ] in [
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ]
			ifMismatch: [ self noneMatched ]
	] in ClapContext>>executeToExit:
FullBlockClosure(BlockClosure)>>cull:
ClapCompositeMatch(ClapSubExpression)>>ifMatch:ifMismatch:
ClapContext>>ifMatch:ifMismatch:
[
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ]
			ifMismatch: [ self noneMatched ]
	] in ClapContext>>executeToExit:
FullBlockClosure(BlockClosure)>>on:do:
ClapContext>>executeToExit:
[
		ClapContext withPragmaCommands
			beObeyingExits;
			setStdio: Stdio;
			arguments: self arguments;
			executeToExit: [ :exit | self handleExit: exit ]
	] in ClapCommandLineHandler>>activate
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Message not understood: FileReference >> #referenceTo:
9 August 2024 4:18:46.954799 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 74b785ff-50d8-0d00-86f4-c64e0df24b96 Jun 28 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 74b785ff-50d8-0d00-86f4-c64e0df24b96 Jun 28 2024
v10.3.0 - Commit: ce151716 - Date: 2024-06-28 10:12:41 +0200

Image: Pharo12.0.0SNAPSHOT [Build information: Pharo-12.0.0+SNAPSHOT.build.1526.sha.404d3af7531f656b5c294762c79011c10bea1ef3 (64 Bit)]

FileReference(Object)>>doesNotUnderstand: #referenceTo:
	Receiver: File @ /Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/PharoBooks2/Booklet-Gra[..]
	Arguments and temporary variables: 
		aMessage: 	referenceTo: '/Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Wri[..]
		exception: 	Instance of FileReference did not understand #referenceTo:
		resumeValue: 	nil
	Receiver's instance variables: 
		path: 	Path / 'Users' / 'ducasse' / 'Workspace' / 'FirstCircle' / 'MyBooks' [..]
		filesystem: 	a FileSystem


[ :file |
		               fileSystem referenceTo: file ] in MicReferenceChecker>>checkProject:
	Receiver: a MicReferenceChecker
	Arguments and temporary variables: 
		aFileReference: 	File @ Chapters/bloc/element.md
		mainMic: 	a MicRootBlock
		collector: 	a MicFileCollector
		listOfFiles: 	nil
		file: 	'/Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/PharoBooks2/[..]
	Receiver's instance variables: 
		references: 	an OrderedCollection()
		anchors: 	an OrderedCollection()
		duplicatedAnchors: 	an OrderedCollection()
		results: 	an OrderedCollection()
		fileSystem: 	File @ /Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/[..]


[:each | each ifNotNil: [newSet add: (aBlock value: each enclosedElement)]] in Set>>collect:
	Receiver: a Set('/Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/PharoBooks2/Booklet-Gra[..]
	Arguments and temporary variables: 
		aBlock: 	[ :file |
		               fileSystem referenceTo: file ]
		newSet: 	a Set()
		each: 	'/Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/PharoBooks2/[..]
	Receiver's instance variables: 
		tally: 	1
		array: 	#(nil nil '/Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/P[..]


Array(SequenceableCollection)>>do:
	Receiver: #(nil nil '/Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/PharoBooks2/Booklet[..]
	Arguments and temporary variables: 
		aBlock: 	[:each | each ifNotNil: [newSet add: (aBlock value: each enclosedEl[..]
		index: 	3
	Receiver's instance variables: 
#(nil nil '/Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/PharoBooks2/Booklet[..]

Set>>collect:
	Receiver: a Set('/Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/PharoBooks2/Booklet-Gra[..]
	Arguments and temporary variables: 
		aBlock: 	[ :file |
		               fileSystem referenceTo: file ]
		newSet: 	a Set()
	Receiver's instance variables: 
		tally: 	1
		array: 	#(nil nil '/Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/P[..]


MicReferenceChecker>>checkProject:
	Receiver: a MicReferenceChecker
	Arguments and temporary variables: 
		aFileReference: 	File @ Chapters/bloc/element.md
		mainMic: 	a MicRootBlock
		collector: 	a MicFileCollector
		listOfFiles: 	nil
	Receiver's instance variables: 
		references: 	an OrderedCollection()
		anchors: 	an OrderedCollection()
		duplicatedAnchors: 	an OrderedCollection()
		results: 	an OrderedCollection()
		fileSystem: 	File @ /Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/[..]


ClapMicrodownBookReferenceCheckerCommand>>execute
	Receiver: a ClapMicrodownBookReferenceCheckerCommand
	Arguments and temporary variables: 
		file: 	File @ Chapters/bloc/element.md
		checker: 	a MicReferenceChecker
	Receiver's instance variables: 
		arguments: 	a ClapNamedMatch
		project: 	nil


[ :args |
			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].
			(self with: args) execute ] in ClapMicrodownBookReferenceCheckerCommand class>>commandSpecification
	Receiver: ClapMicrodownBookReferenceCheckerCommand
	Arguments and temporary variables: 
		args: 	a ClapNamedMatch
	Receiver's instance variables: 
		superclass: 	ClapPillarCommand
		methodDict: 	a MethodDictionary(#execute->ClapMicrodownBookReferenceCheckerC[..]
		format: 	65538
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (execution) - 3 selector(s))
		subclasses: 	nil
		name: 	#ClapMicrodownBookReferenceCheckerCommand
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	7464927
		packageTag: 	a PackageTag(Uncategorized)


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :args |
			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].
			(se[..]
	Arguments and temporary variables: 
		anArg: 	a ClapNamedMatch
	Receiver's instance variables: 
		outerContext: 	ClapMicrodownBookReferenceCheckerCommand class>>commandSpecif[..]
		compiledBlock: 	a CompiledBlock: [ :args |
			args at: #helpFlag ifPresent: [..]
		numArgs: 	1
		receiver: 	ClapMicrodownBookReferenceCheckerCommand


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ :args |
			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].
			(se[..]
	Arguments and temporary variables: 
		firstArg: 	a ClapNamedMatch
		secondArg: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bl[..]
	Receiver's instance variables: 
		outerContext: 	ClapMicrodownBookReferenceCheckerCommand class>>commandSpecif[..]
		compiledBlock: 	a CompiledBlock: [ :args |
			args at: #helpFlag ifPresent: [..]
		numArgs: 	1
		receiver: 	ClapMicrodownBookReferenceCheckerCommand


ClapCommand(ClapParameter)>>valueFor:with:
	Receiver: a ClapCommand(referenceCheck)
	Arguments and temporary variables: 
		aMatch: 	a ClapNamedMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/ele[..]
	Receiver's instance variables: 
		identifier: 	#referenceCheck
		canonicalName: 	nil
		description: 	'Check the duplicated or unknown references'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help | help val[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #requestedFile[..]
		positionals: 	an OrderedCollection(a ClapPositional(requestedFile))
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help))
		subcommands: 	an OrderedCollection()


[ super valueFor: aMatch with: arg ] in ClapCommand>>valueFor:with:
	Receiver: a ClapCommand(referenceCheck)
	Arguments and temporary variables: 
		aMatch: 	a ClapNamedMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/ele[..]
	Receiver's instance variables: 
		identifier: 	#referenceCheck
		canonicalName: 	nil
		description: 	'Check the duplicated or unknown references'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help | help val[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #requestedFile[..]
		positionals: 	an OrderedCollection(a ClapPositional(requestedFile))
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help))
		subcommands: 	an OrderedCollection()


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(a ClapWordMatch)
	Arguments and temporary variables: 
		aBlock: 	[ :child | specification subcommands includes: child specification ]
		foundBlock: 	[ :cmdMatch | foundBlock cull: cmdMatch ]
		exceptionBlock: 	[ super valueFor: aMatch with: arg ]
	Receiver's instance variables: 
		array: 	an Array(a ClapWordMatch nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


ClapNamedMatch(ClapCompositeMatch)>>matchedSubcommand:ifNone:
	Receiver: a ClapNamedMatch
	Arguments and temporary variables: 
		foundBlock: 	[ :sub | sub value: arg ]
		noneBlock: 	[ super valueFor: aMatch with: arg ]
	Receiver's instance variables: 
		specification: 	a ClapCommand(referenceCheck)
		parent: 	a ClapCompositeMatch
		startIndex: 	1
		children: 	an OrderedCollection(a ClapWordMatch)
		keyword: 	'referenceCheck'


ClapCommand>>valueFor:with:
	Receiver: a ClapCommand(referenceCheck)
	Arguments and temporary variables: 
		aMatch: 	a ClapNamedMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/ele[..]
	Receiver's instance variables: 
		identifier: 	#referenceCheck
		canonicalName: 	nil
		description: 	'Check the duplicated or unknown references'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help | help val[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #requestedFile[..]
		positionals: 	an OrderedCollection(a ClapPositional(requestedFile))
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help))
		subcommands: 	an OrderedCollection()


ClapNamedMatch(ClapExpression)>>value:
	Receiver: a ClapNamedMatch
	Arguments and temporary variables: 
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/ele[..]
	Receiver's instance variables: 
		specification: 	a ClapCommand(referenceCheck)
		parent: 	a ClapCompositeMatch
		startIndex: 	1
		children: 	an OrderedCollection(a ClapWordMatch)
		keyword: 	'referenceCheck'


[ :sub | sub value: arg ] in ClapRoot(ClapCommand)>>valueFor:with:
	Receiver: a ClapRoot(clap)
	Arguments and temporary variables: 
		aMatch: 	a ClapCompositeMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/ele[..]
		sub: 	a ClapNamedMatch
	Receiver's instance variables: 
		identifier: 	#clap
		canonicalName: 	nil
		description: 	'Entry point for commands implemented with Clap'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help |
				help[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #helpCommand->[..]
		positionals: 	an OrderedCollection()
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help) a ClapFlag(save) a ClapFlag(no[..]
		subcommands: 	an OrderedCollection(a ClapCommand(help) a ClapCommand(image) [..]


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :sub | sub value: arg ]
	Arguments and temporary variables: 
		anArg: 	a ClapNamedMatch
	Receiver's instance variables: 
		outerContext: 	ClapRoot(ClapCommand)>>valueFor:with:
		compiledBlock: 	a CompiledBlock: [ :sub | sub value: arg ]
		numArgs: 	1
		receiver: 	a ClapRoot(clap)


[ :cmdMatch | foundBlock cull: cmdMatch ] in ClapCompositeMatch>>matchedSubcommand:ifNone:
	Receiver: a ClapCompositeMatch
	Arguments and temporary variables: 
		foundBlock: 	[ :sub | sub value: arg ]
		noneBlock: 	[ super valueFor: aMatch with: arg ]
		cmdMatch: 	a ClapNamedMatch
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		parent: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/[..]
		startIndex: 	1
		children: 	an OrderedCollection(a ClapNamedMatch)


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :cmdMatch | foundBlock cull: cmdMatch ]
	Arguments and temporary variables: 
		anArg: 	a ClapNamedMatch
	Receiver's instance variables: 
		outerContext: 	ClapCompositeMatch>>matchedSubcommand:ifNone:
		compiledBlock: 	a CompiledBlock: [ :cmdMatch | foundBlock cull: cmdMatch ]
		numArgs: 	1
		receiver: 	a ClapCompositeMatch


[ :each |
			(aBlock value: each)
				ifTrue: [ ^ foundBlock cull: each ] ] in OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(a ClapNamedMatch)
	Arguments and temporary variables: 
		aBlock: 	[ :child | specification subcommands includes: child specification ]
		foundBlock: 	[ :cmdMatch | foundBlock cull: cmdMatch ]
		exceptionBlock: 	[ super valueFor: aMatch with: arg ]
		each: 	a ClapNamedMatch
	Receiver's instance variables: 
		array: 	an Array(a ClapNamedMatch nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


OrderedCollection>>do:
	Receiver: an OrderedCollection(a ClapNamedMatch)
	Arguments and temporary variables: 
		aBlock: 	[ :each |
			(aBlock value: each)
				ifTrue: [ ^ foundBlock cull: [..]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a ClapNamedMatch nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(a ClapNamedMatch)
	Arguments and temporary variables: 
		aBlock: 	[ :child | specification subcommands includes: child specification ]
		foundBlock: 	[ :cmdMatch | foundBlock cull: cmdMatch ]
		exceptionBlock: 	[ super valueFor: aMatch with: arg ]
	Receiver's instance variables: 
		array: 	an Array(a ClapNamedMatch nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


ClapCompositeMatch>>matchedSubcommand:ifNone:
	Receiver: a ClapCompositeMatch
	Arguments and temporary variables: 
		foundBlock: 	[ :sub | sub value: arg ]
		noneBlock: 	[ super valueFor: aMatch with: arg ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		parent: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/[..]
		startIndex: 	1
		children: 	an OrderedCollection(a ClapNamedMatch)


ClapRoot(ClapCommand)>>valueFor:with:
	Receiver: a ClapRoot(clap)
	Arguments and temporary variables: 
		aMatch: 	a ClapCompositeMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/ele[..]
	Receiver's instance variables: 
		identifier: 	#clap
		canonicalName: 	nil
		description: 	'Entry point for commands implemented with Clap'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help |
				help[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #helpCommand->[..]
		positionals: 	an OrderedCollection()
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help) a ClapFlag(save) a ClapFlag(no[..]
		subcommands: 	an OrderedCollection(a ClapCommand(help) a ClapCommand(image) [..]


ClapCompositeMatch(ClapExpression)>>value:
	Receiver: a ClapCompositeMatch
	Arguments and temporary variables: 
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/ele[..]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		parent: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/[..]
		startIndex: 	1
		children: 	an OrderedCollection(a ClapNamedMatch)


[ :m |
				m value: self.
				self exitSuccess ] in [
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ]
			ifMismatch: [ self noneMatched ]
	] in ClapContext>>executeToExit:
	Receiver: a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/element.md'))
	Arguments and temporary variables: 
		exitBlock: 	[ :exit | self handleExit: exit ]
		m: 	a ClapCompositeMatch
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		arguments: 	an OrderedCollection('referenceCheck' 'Chapters/bloc/element.md')
		obeyingExits: 	true
		stdio: 	Stdio
		match: 	a ClapCompositeMatch
		leftovers: 	an OrderedCollection()
		session: 	a WorkingSession
		exitException: 	nil


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :m |
				m value: self.
				self exitSuccess ]
	Arguments and temporary variables: 
		anArg: 	a ClapCompositeMatch
	Receiver's instance variables: 
		outerContext: 	[
		self rememberSession;
			ifMatch: [ :m |
				m value: sel[..]
		compiledBlock: 	a CompiledBlock: [ :m |
				m value: self.
				self exitSucc[..]
		numArgs: 	1
		receiver: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/blo[..]


ClapCompositeMatch(ClapSubExpression)>>ifMatch:ifMismatch:
	Receiver: a ClapCompositeMatch
	Arguments and temporary variables: 
		matchBlock: 	[ :m |
				m value: self.
				self exitSuccess ]
		mismatchBlock: 	[ self noneMatched ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		parent: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/[..]
		startIndex: 	1
		children: 	an OrderedCollection(a ClapNamedMatch)


ClapContext>>ifMatch:ifMismatch:
	Receiver: a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/element.md'))
	Arguments and temporary variables: 
		matchBlock: 	[ :m |
				m value: self.
				self exitSuccess ]
		failBlock: 	[ self noneMatched ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		arguments: 	an OrderedCollection('referenceCheck' 'Chapters/bloc/element.md')
		obeyingExits: 	true
		stdio: 	Stdio
		match: 	a ClapCompositeMatch
		leftovers: 	an OrderedCollection()
		session: 	a WorkingSession
		exitException: 	nil


[
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ]
			ifMismatch: [ self noneMatched ]
	] in ClapContext>>executeToExit:
	Receiver: a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/element.md'))
	Arguments and temporary variables: 
		exitBlock: 	[ :exit | self handleExit: exit ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		arguments: 	an OrderedCollection('referenceCheck' 'Chapters/bloc/element.md')
		obeyingExits: 	true
		stdio: 	Stdio
		match: 	a ClapCompositeMatch
		leftovers: 	an OrderedCollection()
		session: 	a WorkingSession
		exitException: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ][..]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exception |
			exitException := exception.
			exitBlock v[..]
	Receiver's instance variables: 
		outerContext: 	ClapContext>>executeToExit:
		compiledBlock: 	a CompiledBlock: [
		self rememberSession;
			ifMatch: [ :m [..]
		numArgs: 	0
		receiver: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/blo[..]


ClapContext>>executeToExit:
	Receiver: a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/element.md'))
	Arguments and temporary variables: 
		exitBlock: 	[ :exit | self handleExit: exit ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		arguments: 	an OrderedCollection('referenceCheck' 'Chapters/bloc/element.md')
		obeyingExits: 	true
		stdio: 	Stdio
		match: 	a ClapCompositeMatch
		leftovers: 	an OrderedCollection()
		session: 	a WorkingSession
		exitException: 	nil


[
		ClapContext withPragmaCommands
			beObeyingExits;
			setStdio: Stdio;
			arguments: self arguments;
			executeToExit: [ :exit | self handleExit: exit ]
	] in ClapCommandLineHandler>>activate
	Receiver: a ClapCommandLineHandler
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
	Receiver: [
		ClapContext withPragmaCommands
			beObeyingExits;
			setStdio: Stdio;
			arguments[..]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		outerContext: 	ClapCommandLineHandler>>activate
		compiledBlock: 	a CompiledBlock: [
		ClapContext withPragmaCommands
			beObe[..]
		numArgs: 	0
		receiver: 	a ClapCommandLineHandler



--- The full stack ---
FileReference(Object)>>doesNotUnderstand: #referenceTo:
[ :file |
		               fileSystem referenceTo: file ] in MicReferenceChecker>>checkProject:
[:each | each ifNotNil: [newSet add: (aBlock value: each enclosedElement)]] in Set>>collect:
Array(SequenceableCollection)>>do:
Set>>collect:
MicReferenceChecker>>checkProject:
ClapMicrodownBookReferenceCheckerCommand>>execute
[ :args |
			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].
			(self with: args) execute ] in ClapMicrodownBookReferenceCheckerCommand class>>commandSpecification
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
ClapCommand(ClapParameter)>>valueFor:with:
[ super valueFor: aMatch with: arg ] in ClapCommand>>valueFor:with:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
ClapNamedMatch(ClapCompositeMatch)>>matchedSubcommand:ifNone:
ClapCommand>>valueFor:with:
ClapNamedMatch(ClapExpression)>>value:
[ :sub | sub value: arg ] in ClapRoot(ClapCommand)>>valueFor:with:
FullBlockClosure(BlockClosure)>>cull:
[ :cmdMatch | foundBlock cull: cmdMatch ] in ClapCompositeMatch>>matchedSubcommand:ifNone:
FullBlockClosure(BlockClosure)>>cull:
[ :each |
			(aBlock value: each)
				ifTrue: [ ^ foundBlock cull: each ] ] in OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
ClapCompositeMatch>>matchedSubcommand:ifNone:
ClapRoot(ClapCommand)>>valueFor:with:
ClapCompositeMatch(ClapExpression)>>value:
[ :m |
				m value: self.
				self exitSuccess ] in [
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ]
			ifMismatch: [ self noneMatched ]
	] in ClapContext>>executeToExit:
FullBlockClosure(BlockClosure)>>cull:
ClapCompositeMatch(ClapSubExpression)>>ifMatch:ifMismatch:
ClapContext>>ifMatch:ifMismatch:
[
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ]
			ifMismatch: [ self noneMatched ]
	] in ClapContext>>executeToExit:
FullBlockClosure(BlockClosure)>>on:do:
ClapContext>>executeToExit:
[
		ClapContext withPragmaCommands
			beObeyingExits;
			setStdio: Stdio;
			arguments: self arguments;
			executeToExit: [ :exit | self handleExit: exit ]
	] in ClapCommandLineHandler>>activate
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Message not understood: FileReference >> #referenceTo:
9 August 2024 4:19:12.040491 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 74b785ff-50d8-0d00-86f4-c64e0df24b96 Jun 28 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 74b785ff-50d8-0d00-86f4-c64e0df24b96 Jun 28 2024
v10.3.0 - Commit: ce151716 - Date: 2024-06-28 10:12:41 +0200

Image: Pharo12.0.0SNAPSHOT [Build information: Pharo-12.0.0+SNAPSHOT.build.1526.sha.404d3af7531f656b5c294762c79011c10bea1ef3 (64 Bit)]

FileReference(Object)>>doesNotUnderstand: #referenceTo:
	Receiver: File @ /Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/PharoBooks2/Booklet-Gra[..]
	Arguments and temporary variables: 
		aMessage: 	referenceTo: '/Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Wri[..]
		exception: 	Instance of FileReference did not understand #referenceTo:
		resumeValue: 	nil
	Receiver's instance variables: 
		path: 	Path / 'Users' / 'ducasse' / 'Workspace' / 'FirstCircle' / 'MyBooks' [..]
		filesystem: 	a FileSystem


[ :file |
		               fileSystem referenceTo: file ] in MicReferenceChecker>>checkProject:
	Receiver: a MicReferenceChecker
	Arguments and temporary variables: 
		aFileReference: 	File @ Chapters/bloc/element.md
		mainMic: 	a MicRootBlock
		collector: 	a MicFileCollector
		listOfFiles: 	nil
		file: 	'/Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/PharoBooks2/[..]
	Receiver's instance variables: 
		references: 	an OrderedCollection()
		anchors: 	an OrderedCollection()
		duplicatedAnchors: 	an OrderedCollection()
		results: 	an OrderedCollection()
		fileSystem: 	File @ /Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/[..]


[:each | each ifNotNil: [newSet add: (aBlock value: each enclosedElement)]] in Set>>collect:
	Receiver: a Set('/Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/PharoBooks2/Booklet-Gra[..]
	Arguments and temporary variables: 
		aBlock: 	[ :file |
		               fileSystem referenceTo: file ]
		newSet: 	a Set()
		each: 	'/Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/PharoBooks2/[..]
	Receiver's instance variables: 
		tally: 	1
		array: 	#(nil nil '/Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/P[..]


Array(SequenceableCollection)>>do:
	Receiver: #(nil nil '/Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/PharoBooks2/Booklet[..]
	Arguments and temporary variables: 
		aBlock: 	[:each | each ifNotNil: [newSet add: (aBlock value: each enclosedEl[..]
		index: 	3
	Receiver's instance variables: 
#(nil nil '/Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/PharoBooks2/Booklet[..]

Set>>collect:
	Receiver: a Set('/Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/PharoBooks2/Booklet-Gra[..]
	Arguments and temporary variables: 
		aBlock: 	[ :file |
		               fileSystem referenceTo: file ]
		newSet: 	a Set()
	Receiver's instance variables: 
		tally: 	1
		array: 	#(nil nil '/Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/P[..]


MicReferenceChecker>>checkProject:
	Receiver: a MicReferenceChecker
	Arguments and temporary variables: 
		aFileReference: 	File @ Chapters/bloc/element.md
		mainMic: 	a MicRootBlock
		collector: 	a MicFileCollector
		listOfFiles: 	nil
	Receiver's instance variables: 
		references: 	an OrderedCollection()
		anchors: 	an OrderedCollection()
		duplicatedAnchors: 	an OrderedCollection()
		results: 	an OrderedCollection()
		fileSystem: 	File @ /Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/[..]


ClapMicrodownBookReferenceCheckerCommand>>execute
	Receiver: a ClapMicrodownBookReferenceCheckerCommand
	Arguments and temporary variables: 
		file: 	File @ Chapters/bloc/element.md
		checker: 	a MicReferenceChecker
	Receiver's instance variables: 
		arguments: 	a ClapNamedMatch
		project: 	nil


[ :args |
			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].
			(self with: args) execute ] in ClapMicrodownBookReferenceCheckerCommand class>>commandSpecification
	Receiver: ClapMicrodownBookReferenceCheckerCommand
	Arguments and temporary variables: 
		args: 	a ClapNamedMatch
	Receiver's instance variables: 
		superclass: 	ClapPillarCommand
		methodDict: 	a MethodDictionary(#execute->ClapMicrodownBookReferenceCheckerC[..]
		format: 	65538
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (execution) - 3 selector(s))
		subclasses: 	nil
		name: 	#ClapMicrodownBookReferenceCheckerCommand
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	7464927
		packageTag: 	a PackageTag(Uncategorized)


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :args |
			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].
			(se[..]
	Arguments and temporary variables: 
		anArg: 	a ClapNamedMatch
	Receiver's instance variables: 
		outerContext: 	ClapMicrodownBookReferenceCheckerCommand class>>commandSpecif[..]
		compiledBlock: 	a CompiledBlock: [ :args |
			args at: #helpFlag ifPresent: [..]
		numArgs: 	1
		receiver: 	ClapMicrodownBookReferenceCheckerCommand


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ :args |
			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].
			(se[..]
	Arguments and temporary variables: 
		firstArg: 	a ClapNamedMatch
		secondArg: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bl[..]
	Receiver's instance variables: 
		outerContext: 	ClapMicrodownBookReferenceCheckerCommand class>>commandSpecif[..]
		compiledBlock: 	a CompiledBlock: [ :args |
			args at: #helpFlag ifPresent: [..]
		numArgs: 	1
		receiver: 	ClapMicrodownBookReferenceCheckerCommand


ClapCommand(ClapParameter)>>valueFor:with:
	Receiver: a ClapCommand(referenceCheck)
	Arguments and temporary variables: 
		aMatch: 	a ClapNamedMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/ele[..]
	Receiver's instance variables: 
		identifier: 	#referenceCheck
		canonicalName: 	nil
		description: 	'Check the duplicated or unknown references'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help | help val[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #requestedFile[..]
		positionals: 	an OrderedCollection(a ClapPositional(requestedFile))
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help))
		subcommands: 	an OrderedCollection()


[ super valueFor: aMatch with: arg ] in ClapCommand>>valueFor:with:
	Receiver: a ClapCommand(referenceCheck)
	Arguments and temporary variables: 
		aMatch: 	a ClapNamedMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/ele[..]
	Receiver's instance variables: 
		identifier: 	#referenceCheck
		canonicalName: 	nil
		description: 	'Check the duplicated or unknown references'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help | help val[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #requestedFile[..]
		positionals: 	an OrderedCollection(a ClapPositional(requestedFile))
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help))
		subcommands: 	an OrderedCollection()


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(a ClapWordMatch)
	Arguments and temporary variables: 
		aBlock: 	[ :child | specification subcommands includes: child specification ]
		foundBlock: 	[ :cmdMatch | foundBlock cull: cmdMatch ]
		exceptionBlock: 	[ super valueFor: aMatch with: arg ]
	Receiver's instance variables: 
		array: 	an Array(a ClapWordMatch nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


ClapNamedMatch(ClapCompositeMatch)>>matchedSubcommand:ifNone:
	Receiver: a ClapNamedMatch
	Arguments and temporary variables: 
		foundBlock: 	[ :sub | sub value: arg ]
		noneBlock: 	[ super valueFor: aMatch with: arg ]
	Receiver's instance variables: 
		specification: 	a ClapCommand(referenceCheck)
		parent: 	a ClapCompositeMatch
		startIndex: 	1
		children: 	an OrderedCollection(a ClapWordMatch)
		keyword: 	'referenceCheck'


ClapCommand>>valueFor:with:
	Receiver: a ClapCommand(referenceCheck)
	Arguments and temporary variables: 
		aMatch: 	a ClapNamedMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/ele[..]
	Receiver's instance variables: 
		identifier: 	#referenceCheck
		canonicalName: 	nil
		description: 	'Check the duplicated or unknown references'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help | help val[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #requestedFile[..]
		positionals: 	an OrderedCollection(a ClapPositional(requestedFile))
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help))
		subcommands: 	an OrderedCollection()


ClapNamedMatch(ClapExpression)>>value:
	Receiver: a ClapNamedMatch
	Arguments and temporary variables: 
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/ele[..]
	Receiver's instance variables: 
		specification: 	a ClapCommand(referenceCheck)
		parent: 	a ClapCompositeMatch
		startIndex: 	1
		children: 	an OrderedCollection(a ClapWordMatch)
		keyword: 	'referenceCheck'


[ :sub | sub value: arg ] in ClapRoot(ClapCommand)>>valueFor:with:
	Receiver: a ClapRoot(clap)
	Arguments and temporary variables: 
		aMatch: 	a ClapCompositeMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/ele[..]
		sub: 	a ClapNamedMatch
	Receiver's instance variables: 
		identifier: 	#clap
		canonicalName: 	nil
		description: 	'Entry point for commands implemented with Clap'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help |
				help[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #helpCommand->[..]
		positionals: 	an OrderedCollection()
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help) a ClapFlag(save) a ClapFlag(no[..]
		subcommands: 	an OrderedCollection(a ClapCommand(help) a ClapCommand(image) [..]


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :sub | sub value: arg ]
	Arguments and temporary variables: 
		anArg: 	a ClapNamedMatch
	Receiver's instance variables: 
		outerContext: 	ClapRoot(ClapCommand)>>valueFor:with:
		compiledBlock: 	a CompiledBlock: [ :sub | sub value: arg ]
		numArgs: 	1
		receiver: 	a ClapRoot(clap)


[ :cmdMatch | foundBlock cull: cmdMatch ] in ClapCompositeMatch>>matchedSubcommand:ifNone:
	Receiver: a ClapCompositeMatch
	Arguments and temporary variables: 
		foundBlock: 	[ :sub | sub value: arg ]
		noneBlock: 	[ super valueFor: aMatch with: arg ]
		cmdMatch: 	a ClapNamedMatch
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		parent: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/[..]
		startIndex: 	1
		children: 	an OrderedCollection(a ClapNamedMatch)


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :cmdMatch | foundBlock cull: cmdMatch ]
	Arguments and temporary variables: 
		anArg: 	a ClapNamedMatch
	Receiver's instance variables: 
		outerContext: 	ClapCompositeMatch>>matchedSubcommand:ifNone:
		compiledBlock: 	a CompiledBlock: [ :cmdMatch | foundBlock cull: cmdMatch ]
		numArgs: 	1
		receiver: 	a ClapCompositeMatch


[ :each |
			(aBlock value: each)
				ifTrue: [ ^ foundBlock cull: each ] ] in OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(a ClapNamedMatch)
	Arguments and temporary variables: 
		aBlock: 	[ :child | specification subcommands includes: child specification ]
		foundBlock: 	[ :cmdMatch | foundBlock cull: cmdMatch ]
		exceptionBlock: 	[ super valueFor: aMatch with: arg ]
		each: 	a ClapNamedMatch
	Receiver's instance variables: 
		array: 	an Array(a ClapNamedMatch nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


OrderedCollection>>do:
	Receiver: an OrderedCollection(a ClapNamedMatch)
	Arguments and temporary variables: 
		aBlock: 	[ :each |
			(aBlock value: each)
				ifTrue: [ ^ foundBlock cull: [..]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a ClapNamedMatch nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(a ClapNamedMatch)
	Arguments and temporary variables: 
		aBlock: 	[ :child | specification subcommands includes: child specification ]
		foundBlock: 	[ :cmdMatch | foundBlock cull: cmdMatch ]
		exceptionBlock: 	[ super valueFor: aMatch with: arg ]
	Receiver's instance variables: 
		array: 	an Array(a ClapNamedMatch nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


ClapCompositeMatch>>matchedSubcommand:ifNone:
	Receiver: a ClapCompositeMatch
	Arguments and temporary variables: 
		foundBlock: 	[ :sub | sub value: arg ]
		noneBlock: 	[ super valueFor: aMatch with: arg ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		parent: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/[..]
		startIndex: 	1
		children: 	an OrderedCollection(a ClapNamedMatch)


ClapRoot(ClapCommand)>>valueFor:with:
	Receiver: a ClapRoot(clap)
	Arguments and temporary variables: 
		aMatch: 	a ClapCompositeMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/ele[..]
	Receiver's instance variables: 
		identifier: 	#clap
		canonicalName: 	nil
		description: 	'Entry point for commands implemented with Clap'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help |
				help[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #helpCommand->[..]
		positionals: 	an OrderedCollection()
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help) a ClapFlag(save) a ClapFlag(no[..]
		subcommands: 	an OrderedCollection(a ClapCommand(help) a ClapCommand(image) [..]


ClapCompositeMatch(ClapExpression)>>value:
	Receiver: a ClapCompositeMatch
	Arguments and temporary variables: 
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/ele[..]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		parent: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/[..]
		startIndex: 	1
		children: 	an OrderedCollection(a ClapNamedMatch)


[ :m |
				m value: self.
				self exitSuccess ] in [
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ]
			ifMismatch: [ self noneMatched ]
	] in ClapContext>>executeToExit:
	Receiver: a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/element.md'))
	Arguments and temporary variables: 
		exitBlock: 	[ :exit | self handleExit: exit ]
		m: 	a ClapCompositeMatch
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		arguments: 	an OrderedCollection('referenceCheck' 'Chapters/bloc/element.md')
		obeyingExits: 	true
		stdio: 	Stdio
		match: 	a ClapCompositeMatch
		leftovers: 	an OrderedCollection()
		session: 	a WorkingSession
		exitException: 	nil


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :m |
				m value: self.
				self exitSuccess ]
	Arguments and temporary variables: 
		anArg: 	a ClapCompositeMatch
	Receiver's instance variables: 
		outerContext: 	[
		self rememberSession;
			ifMatch: [ :m |
				m value: sel[..]
		compiledBlock: 	a CompiledBlock: [ :m |
				m value: self.
				self exitSucc[..]
		numArgs: 	1
		receiver: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/blo[..]


ClapCompositeMatch(ClapSubExpression)>>ifMatch:ifMismatch:
	Receiver: a ClapCompositeMatch
	Arguments and temporary variables: 
		matchBlock: 	[ :m |
				m value: self.
				self exitSuccess ]
		mismatchBlock: 	[ self noneMatched ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		parent: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/[..]
		startIndex: 	1
		children: 	an OrderedCollection(a ClapNamedMatch)


ClapContext>>ifMatch:ifMismatch:
	Receiver: a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/element.md'))
	Arguments and temporary variables: 
		matchBlock: 	[ :m |
				m value: self.
				self exitSuccess ]
		failBlock: 	[ self noneMatched ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		arguments: 	an OrderedCollection('referenceCheck' 'Chapters/bloc/element.md')
		obeyingExits: 	true
		stdio: 	Stdio
		match: 	a ClapCompositeMatch
		leftovers: 	an OrderedCollection()
		session: 	a WorkingSession
		exitException: 	nil


[
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ]
			ifMismatch: [ self noneMatched ]
	] in ClapContext>>executeToExit:
	Receiver: a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/element.md'))
	Arguments and temporary variables: 
		exitBlock: 	[ :exit | self handleExit: exit ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		arguments: 	an OrderedCollection('referenceCheck' 'Chapters/bloc/element.md')
		obeyingExits: 	true
		stdio: 	Stdio
		match: 	a ClapCompositeMatch
		leftovers: 	an OrderedCollection()
		session: 	a WorkingSession
		exitException: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ][..]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exception |
			exitException := exception.
			exitBlock v[..]
	Receiver's instance variables: 
		outerContext: 	ClapContext>>executeToExit:
		compiledBlock: 	a CompiledBlock: [
		self rememberSession;
			ifMatch: [ :m [..]
		numArgs: 	0
		receiver: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/blo[..]


ClapContext>>executeToExit:
	Receiver: a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/element.md'))
	Arguments and temporary variables: 
		exitBlock: 	[ :exit | self handleExit: exit ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		arguments: 	an OrderedCollection('referenceCheck' 'Chapters/bloc/element.md')
		obeyingExits: 	true
		stdio: 	Stdio
		match: 	a ClapCompositeMatch
		leftovers: 	an OrderedCollection()
		session: 	a WorkingSession
		exitException: 	nil


[
		ClapContext withPragmaCommands
			beObeyingExits;
			setStdio: Stdio;
			arguments: self arguments;
			executeToExit: [ :exit | self handleExit: exit ]
	] in ClapCommandLineHandler>>activate
	Receiver: a ClapCommandLineHandler
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
	Receiver: [
		ClapContext withPragmaCommands
			beObeyingExits;
			setStdio: Stdio;
			arguments[..]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		outerContext: 	ClapCommandLineHandler>>activate
		compiledBlock: 	a CompiledBlock: [
		ClapContext withPragmaCommands
			beObe[..]
		numArgs: 	0
		receiver: 	a ClapCommandLineHandler



--- The full stack ---
FileReference(Object)>>doesNotUnderstand: #referenceTo:
[ :file |
		               fileSystem referenceTo: file ] in MicReferenceChecker>>checkProject:
[:each | each ifNotNil: [newSet add: (aBlock value: each enclosedElement)]] in Set>>collect:
Array(SequenceableCollection)>>do:
Set>>collect:
MicReferenceChecker>>checkProject:
ClapMicrodownBookReferenceCheckerCommand>>execute
[ :args |
			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].
			(self with: args) execute ] in ClapMicrodownBookReferenceCheckerCommand class>>commandSpecification
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
ClapCommand(ClapParameter)>>valueFor:with:
[ super valueFor: aMatch with: arg ] in ClapCommand>>valueFor:with:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
ClapNamedMatch(ClapCompositeMatch)>>matchedSubcommand:ifNone:
ClapCommand>>valueFor:with:
ClapNamedMatch(ClapExpression)>>value:
[ :sub | sub value: arg ] in ClapRoot(ClapCommand)>>valueFor:with:
FullBlockClosure(BlockClosure)>>cull:
[ :cmdMatch | foundBlock cull: cmdMatch ] in ClapCompositeMatch>>matchedSubcommand:ifNone:
FullBlockClosure(BlockClosure)>>cull:
[ :each |
			(aBlock value: each)
				ifTrue: [ ^ foundBlock cull: each ] ] in OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
ClapCompositeMatch>>matchedSubcommand:ifNone:
ClapRoot(ClapCommand)>>valueFor:with:
ClapCompositeMatch(ClapExpression)>>value:
[ :m |
				m value: self.
				self exitSuccess ] in [
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ]
			ifMismatch: [ self noneMatched ]
	] in ClapContext>>executeToExit:
FullBlockClosure(BlockClosure)>>cull:
ClapCompositeMatch(ClapSubExpression)>>ifMatch:ifMismatch:
ClapContext>>ifMatch:ifMismatch:
[
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ]
			ifMismatch: [ self noneMatched ]
	] in ClapContext>>executeToExit:
FullBlockClosure(BlockClosure)>>on:do:
ClapContext>>executeToExit:
[
		ClapContext withPragmaCommands
			beObeyingExits;
			setStdio: Stdio;
			arguments: self arguments;
			executeToExit: [ :exit | self handleExit: exit ]
	] in ClapCommandLineHandler>>activate
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Message not understood: FileReference >> #referenceTo:
9 August 2024 4:19:46.447 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 74b785ff-50d8-0d00-86f4-c64e0df24b96 Jun 28 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 74b785ff-50d8-0d00-86f4-c64e0df24b96 Jun 28 2024
v10.3.0 - Commit: ce151716 - Date: 2024-06-28 10:12:41 +0200

Image: Pharo12.0.0SNAPSHOT [Build information: Pharo-12.0.0+SNAPSHOT.build.1526.sha.404d3af7531f656b5c294762c79011c10bea1ef3 (64 Bit)]

FileReference(Object)>>doesNotUnderstand: #referenceTo:
	Receiver: File @ /Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/PharoBooks2/Booklet-Gra[..]
	Arguments and temporary variables: 
		aMessage: 	referenceTo: '/Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Wri[..]
		exception: 	Instance of FileReference did not understand #referenceTo:
		resumeValue: 	nil
	Receiver's instance variables: 
		path: 	Path / 'Users' / 'ducasse' / 'Workspace' / 'FirstCircle' / 'MyBooks' [..]
		filesystem: 	a FileSystem


[ :file |
		               fileSystem referenceTo: file ] in MicReferenceChecker>>checkProject:
	Receiver: a MicReferenceChecker
	Arguments and temporary variables: 
		aFileReference: 	File @ Chapters/bloc/element.md
		mainMic: 	a MicRootBlock
		collector: 	a MicFileCollector
		listOfFiles: 	nil
		file: 	'/Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/PharoBooks2/[..]
	Receiver's instance variables: 
		references: 	an OrderedCollection()
		anchors: 	an OrderedCollection()
		duplicatedAnchors: 	an OrderedCollection()
		results: 	an OrderedCollection()
		fileSystem: 	File @ /Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/[..]


[:each | each ifNotNil: [newSet add: (aBlock value: each enclosedElement)]] in Set>>collect:
	Receiver: a Set('/Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/PharoBooks2/Booklet-Gra[..]
	Arguments and temporary variables: 
		aBlock: 	[ :file |
		               fileSystem referenceTo: file ]
		newSet: 	a Set()
		each: 	'/Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/PharoBooks2/[..]
	Receiver's instance variables: 
		tally: 	1
		array: 	#(nil nil '/Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/P[..]


Array(SequenceableCollection)>>do:
	Receiver: #(nil nil '/Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/PharoBooks2/Booklet[..]
	Arguments and temporary variables: 
		aBlock: 	[:each | each ifNotNil: [newSet add: (aBlock value: each enclosedEl[..]
		index: 	3
	Receiver's instance variables: 
#(nil nil '/Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/PharoBooks2/Booklet[..]

Set>>collect:
	Receiver: a Set('/Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/PharoBooks2/Booklet-Gra[..]
	Arguments and temporary variables: 
		aBlock: 	[ :file |
		               fileSystem referenceTo: file ]
		newSet: 	a Set()
	Receiver's instance variables: 
		tally: 	1
		array: 	#(nil nil '/Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/P[..]


MicReferenceChecker>>checkProject:
	Receiver: a MicReferenceChecker
	Arguments and temporary variables: 
		aFileReference: 	File @ Chapters/bloc/element.md
		mainMic: 	a MicRootBlock
		collector: 	a MicFileCollector
		listOfFiles: 	nil
	Receiver's instance variables: 
		references: 	an OrderedCollection()
		anchors: 	an OrderedCollection()
		duplicatedAnchors: 	an OrderedCollection()
		results: 	an OrderedCollection()
		fileSystem: 	File @ /Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/[..]


ClapMicrodownBookReferenceCheckerCommand>>execute
	Receiver: a ClapMicrodownBookReferenceCheckerCommand
	Arguments and temporary variables: 
		file: 	File @ Chapters/bloc/element.md
		checker: 	a MicReferenceChecker
	Receiver's instance variables: 
		arguments: 	a ClapNamedMatch
		project: 	nil


[ :args |
			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].
			(self with: args) execute ] in ClapMicrodownBookReferenceCheckerCommand class>>commandSpecification
	Receiver: ClapMicrodownBookReferenceCheckerCommand
	Arguments and temporary variables: 
		args: 	a ClapNamedMatch
	Receiver's instance variables: 
		superclass: 	ClapPillarCommand
		methodDict: 	a MethodDictionary(#execute->ClapMicrodownBookReferenceCheckerC[..]
		format: 	65538
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (execution) - 3 selector(s))
		subclasses: 	nil
		name: 	#ClapMicrodownBookReferenceCheckerCommand
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	7464927
		packageTag: 	a PackageTag(Uncategorized)


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :args |
			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].
			(se[..]
	Arguments and temporary variables: 
		anArg: 	a ClapNamedMatch
	Receiver's instance variables: 
		outerContext: 	ClapMicrodownBookReferenceCheckerCommand class>>commandSpecif[..]
		compiledBlock: 	a CompiledBlock: [ :args |
			args at: #helpFlag ifPresent: [..]
		numArgs: 	1
		receiver: 	ClapMicrodownBookReferenceCheckerCommand


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ :args |
			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].
			(se[..]
	Arguments and temporary variables: 
		firstArg: 	a ClapNamedMatch
		secondArg: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bl[..]
	Receiver's instance variables: 
		outerContext: 	ClapMicrodownBookReferenceCheckerCommand class>>commandSpecif[..]
		compiledBlock: 	a CompiledBlock: [ :args |
			args at: #helpFlag ifPresent: [..]
		numArgs: 	1
		receiver: 	ClapMicrodownBookReferenceCheckerCommand


ClapCommand(ClapParameter)>>valueFor:with:
	Receiver: a ClapCommand(referenceCheck)
	Arguments and temporary variables: 
		aMatch: 	a ClapNamedMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/ele[..]
	Receiver's instance variables: 
		identifier: 	#referenceCheck
		canonicalName: 	nil
		description: 	'Check the duplicated or unknown references'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help | help val[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #requestedFile[..]
		positionals: 	an OrderedCollection(a ClapPositional(requestedFile))
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help))
		subcommands: 	an OrderedCollection()


[ super valueFor: aMatch with: arg ] in ClapCommand>>valueFor:with:
	Receiver: a ClapCommand(referenceCheck)
	Arguments and temporary variables: 
		aMatch: 	a ClapNamedMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/ele[..]
	Receiver's instance variables: 
		identifier: 	#referenceCheck
		canonicalName: 	nil
		description: 	'Check the duplicated or unknown references'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help | help val[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #requestedFile[..]
		positionals: 	an OrderedCollection(a ClapPositional(requestedFile))
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help))
		subcommands: 	an OrderedCollection()


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(a ClapWordMatch)
	Arguments and temporary variables: 
		aBlock: 	[ :child | specification subcommands includes: child specification ]
		foundBlock: 	[ :cmdMatch | foundBlock cull: cmdMatch ]
		exceptionBlock: 	[ super valueFor: aMatch with: arg ]
	Receiver's instance variables: 
		array: 	an Array(a ClapWordMatch nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


ClapNamedMatch(ClapCompositeMatch)>>matchedSubcommand:ifNone:
	Receiver: a ClapNamedMatch
	Arguments and temporary variables: 
		foundBlock: 	[ :sub | sub value: arg ]
		noneBlock: 	[ super valueFor: aMatch with: arg ]
	Receiver's instance variables: 
		specification: 	a ClapCommand(referenceCheck)
		parent: 	a ClapCompositeMatch
		startIndex: 	1
		children: 	an OrderedCollection(a ClapWordMatch)
		keyword: 	'referenceCheck'


ClapCommand>>valueFor:with:
	Receiver: a ClapCommand(referenceCheck)
	Arguments and temporary variables: 
		aMatch: 	a ClapNamedMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/ele[..]
	Receiver's instance variables: 
		identifier: 	#referenceCheck
		canonicalName: 	nil
		description: 	'Check the duplicated or unknown references'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help | help val[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #requestedFile[..]
		positionals: 	an OrderedCollection(a ClapPositional(requestedFile))
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help))
		subcommands: 	an OrderedCollection()


ClapNamedMatch(ClapExpression)>>value:
	Receiver: a ClapNamedMatch
	Arguments and temporary variables: 
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/ele[..]
	Receiver's instance variables: 
		specification: 	a ClapCommand(referenceCheck)
		parent: 	a ClapCompositeMatch
		startIndex: 	1
		children: 	an OrderedCollection(a ClapWordMatch)
		keyword: 	'referenceCheck'


[ :sub | sub value: arg ] in ClapRoot(ClapCommand)>>valueFor:with:
	Receiver: a ClapRoot(clap)
	Arguments and temporary variables: 
		aMatch: 	a ClapCompositeMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/ele[..]
		sub: 	a ClapNamedMatch
	Receiver's instance variables: 
		identifier: 	#clap
		canonicalName: 	nil
		description: 	'Entry point for commands implemented with Clap'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help |
				help[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #helpCommand->[..]
		positionals: 	an OrderedCollection()
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help) a ClapFlag(save) a ClapFlag(no[..]
		subcommands: 	an OrderedCollection(a ClapCommand(help) a ClapCommand(image) [..]


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :sub | sub value: arg ]
	Arguments and temporary variables: 
		anArg: 	a ClapNamedMatch
	Receiver's instance variables: 
		outerContext: 	ClapRoot(ClapCommand)>>valueFor:with:
		compiledBlock: 	a CompiledBlock: [ :sub | sub value: arg ]
		numArgs: 	1
		receiver: 	a ClapRoot(clap)


[ :cmdMatch | foundBlock cull: cmdMatch ] in ClapCompositeMatch>>matchedSubcommand:ifNone:
	Receiver: a ClapCompositeMatch
	Arguments and temporary variables: 
		foundBlock: 	[ :sub | sub value: arg ]
		noneBlock: 	[ super valueFor: aMatch with: arg ]
		cmdMatch: 	a ClapNamedMatch
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		parent: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/[..]
		startIndex: 	1
		children: 	an OrderedCollection(a ClapNamedMatch)


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :cmdMatch | foundBlock cull: cmdMatch ]
	Arguments and temporary variables: 
		anArg: 	a ClapNamedMatch
	Receiver's instance variables: 
		outerContext: 	ClapCompositeMatch>>matchedSubcommand:ifNone:
		compiledBlock: 	a CompiledBlock: [ :cmdMatch | foundBlock cull: cmdMatch ]
		numArgs: 	1
		receiver: 	a ClapCompositeMatch


[ :each |
			(aBlock value: each)
				ifTrue: [ ^ foundBlock cull: each ] ] in OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(a ClapNamedMatch)
	Arguments and temporary variables: 
		aBlock: 	[ :child | specification subcommands includes: child specification ]
		foundBlock: 	[ :cmdMatch | foundBlock cull: cmdMatch ]
		exceptionBlock: 	[ super valueFor: aMatch with: arg ]
		each: 	a ClapNamedMatch
	Receiver's instance variables: 
		array: 	an Array(a ClapNamedMatch nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


OrderedCollection>>do:
	Receiver: an OrderedCollection(a ClapNamedMatch)
	Arguments and temporary variables: 
		aBlock: 	[ :each |
			(aBlock value: each)
				ifTrue: [ ^ foundBlock cull: [..]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a ClapNamedMatch nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(a ClapNamedMatch)
	Arguments and temporary variables: 
		aBlock: 	[ :child | specification subcommands includes: child specification ]
		foundBlock: 	[ :cmdMatch | foundBlock cull: cmdMatch ]
		exceptionBlock: 	[ super valueFor: aMatch with: arg ]
	Receiver's instance variables: 
		array: 	an Array(a ClapNamedMatch nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


ClapCompositeMatch>>matchedSubcommand:ifNone:
	Receiver: a ClapCompositeMatch
	Arguments and temporary variables: 
		foundBlock: 	[ :sub | sub value: arg ]
		noneBlock: 	[ super valueFor: aMatch with: arg ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		parent: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/[..]
		startIndex: 	1
		children: 	an OrderedCollection(a ClapNamedMatch)


ClapRoot(ClapCommand)>>valueFor:with:
	Receiver: a ClapRoot(clap)
	Arguments and temporary variables: 
		aMatch: 	a ClapCompositeMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/ele[..]
	Receiver's instance variables: 
		identifier: 	#clap
		canonicalName: 	nil
		description: 	'Entry point for commands implemented with Clap'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help |
				help[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #helpCommand->[..]
		positionals: 	an OrderedCollection()
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help) a ClapFlag(save) a ClapFlag(no[..]
		subcommands: 	an OrderedCollection(a ClapCommand(help) a ClapCommand(image) [..]


ClapCompositeMatch(ClapExpression)>>value:
	Receiver: a ClapCompositeMatch
	Arguments and temporary variables: 
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/ele[..]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		parent: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/[..]
		startIndex: 	1
		children: 	an OrderedCollection(a ClapNamedMatch)


[ :m |
				m value: self.
				self exitSuccess ] in [
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ]
			ifMismatch: [ self noneMatched ]
	] in ClapContext>>executeToExit:
	Receiver: a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/element.md'))
	Arguments and temporary variables: 
		exitBlock: 	[ :exit | self handleExit: exit ]
		m: 	a ClapCompositeMatch
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		arguments: 	an OrderedCollection('referenceCheck' 'Chapters/bloc/element.md')
		obeyingExits: 	true
		stdio: 	Stdio
		match: 	a ClapCompositeMatch
		leftovers: 	an OrderedCollection()
		session: 	a WorkingSession
		exitException: 	nil


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :m |
				m value: self.
				self exitSuccess ]
	Arguments and temporary variables: 
		anArg: 	a ClapCompositeMatch
	Receiver's instance variables: 
		outerContext: 	[
		self rememberSession;
			ifMatch: [ :m |
				m value: sel[..]
		compiledBlock: 	a CompiledBlock: [ :m |
				m value: self.
				self exitSucc[..]
		numArgs: 	1
		receiver: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/blo[..]


ClapCompositeMatch(ClapSubExpression)>>ifMatch:ifMismatch:
	Receiver: a ClapCompositeMatch
	Arguments and temporary variables: 
		matchBlock: 	[ :m |
				m value: self.
				self exitSuccess ]
		mismatchBlock: 	[ self noneMatched ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		parent: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/[..]
		startIndex: 	1
		children: 	an OrderedCollection(a ClapNamedMatch)


ClapContext>>ifMatch:ifMismatch:
	Receiver: a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/element.md'))
	Arguments and temporary variables: 
		matchBlock: 	[ :m |
				m value: self.
				self exitSuccess ]
		failBlock: 	[ self noneMatched ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		arguments: 	an OrderedCollection('referenceCheck' 'Chapters/bloc/element.md')
		obeyingExits: 	true
		stdio: 	Stdio
		match: 	a ClapCompositeMatch
		leftovers: 	an OrderedCollection()
		session: 	a WorkingSession
		exitException: 	nil


[
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ]
			ifMismatch: [ self noneMatched ]
	] in ClapContext>>executeToExit:
	Receiver: a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/element.md'))
	Arguments and temporary variables: 
		exitBlock: 	[ :exit | self handleExit: exit ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		arguments: 	an OrderedCollection('referenceCheck' 'Chapters/bloc/element.md')
		obeyingExits: 	true
		stdio: 	Stdio
		match: 	a ClapCompositeMatch
		leftovers: 	an OrderedCollection()
		session: 	a WorkingSession
		exitException: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ][..]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exception |
			exitException := exception.
			exitBlock v[..]
	Receiver's instance variables: 
		outerContext: 	ClapContext>>executeToExit:
		compiledBlock: 	a CompiledBlock: [
		self rememberSession;
			ifMatch: [ :m [..]
		numArgs: 	0
		receiver: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/blo[..]


ClapContext>>executeToExit:
	Receiver: a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/element.md'))
	Arguments and temporary variables: 
		exitBlock: 	[ :exit | self handleExit: exit ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		arguments: 	an OrderedCollection('referenceCheck' 'Chapters/bloc/element.md')
		obeyingExits: 	true
		stdio: 	Stdio
		match: 	a ClapCompositeMatch
		leftovers: 	an OrderedCollection()
		session: 	a WorkingSession
		exitException: 	nil


[
		ClapContext withPragmaCommands
			beObeyingExits;
			setStdio: Stdio;
			arguments: self arguments;
			executeToExit: [ :exit | self handleExit: exit ]
	] in ClapCommandLineHandler>>activate
	Receiver: a ClapCommandLineHandler
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
	Receiver: [
		ClapContext withPragmaCommands
			beObeyingExits;
			setStdio: Stdio;
			arguments[..]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		outerContext: 	ClapCommandLineHandler>>activate
		compiledBlock: 	a CompiledBlock: [
		ClapContext withPragmaCommands
			beObe[..]
		numArgs: 	0
		receiver: 	a ClapCommandLineHandler



--- The full stack ---
FileReference(Object)>>doesNotUnderstand: #referenceTo:
[ :file |
		               fileSystem referenceTo: file ] in MicReferenceChecker>>checkProject:
[:each | each ifNotNil: [newSet add: (aBlock value: each enclosedElement)]] in Set>>collect:
Array(SequenceableCollection)>>do:
Set>>collect:
MicReferenceChecker>>checkProject:
ClapMicrodownBookReferenceCheckerCommand>>execute
[ :args |
			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].
			(self with: args) execute ] in ClapMicrodownBookReferenceCheckerCommand class>>commandSpecification
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
ClapCommand(ClapParameter)>>valueFor:with:
[ super valueFor: aMatch with: arg ] in ClapCommand>>valueFor:with:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
ClapNamedMatch(ClapCompositeMatch)>>matchedSubcommand:ifNone:
ClapCommand>>valueFor:with:
ClapNamedMatch(ClapExpression)>>value:
[ :sub | sub value: arg ] in ClapRoot(ClapCommand)>>valueFor:with:
FullBlockClosure(BlockClosure)>>cull:
[ :cmdMatch | foundBlock cull: cmdMatch ] in ClapCompositeMatch>>matchedSubcommand:ifNone:
FullBlockClosure(BlockClosure)>>cull:
[ :each |
			(aBlock value: each)
				ifTrue: [ ^ foundBlock cull: each ] ] in OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
ClapCompositeMatch>>matchedSubcommand:ifNone:
ClapRoot(ClapCommand)>>valueFor:with:
ClapCompositeMatch(ClapExpression)>>value:
[ :m |
				m value: self.
				self exitSuccess ] in [
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ]
			ifMismatch: [ self noneMatched ]
	] in ClapContext>>executeToExit:
FullBlockClosure(BlockClosure)>>cull:
ClapCompositeMatch(ClapSubExpression)>>ifMatch:ifMismatch:
ClapContext>>ifMatch:ifMismatch:
[
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ]
			ifMismatch: [ self noneMatched ]
	] in ClapContext>>executeToExit:
FullBlockClosure(BlockClosure)>>on:do:
ClapContext>>executeToExit:
[
		ClapContext withPragmaCommands
			beObeyingExits;
			setStdio: Stdio;
			arguments: self arguments;
			executeToExit: [ :exit | self handleExit: exit ]
	] in ClapCommandLineHandler>>activate
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Message not understood: FileReference >> #referenceTo:
9 August 2024 4:20:03.068519 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 74b785ff-50d8-0d00-86f4-c64e0df24b96 Jun 28 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 74b785ff-50d8-0d00-86f4-c64e0df24b96 Jun 28 2024
v10.3.0 - Commit: ce151716 - Date: 2024-06-28 10:12:41 +0200

Image: Pharo12.0.0SNAPSHOT [Build information: Pharo-12.0.0+SNAPSHOT.build.1526.sha.404d3af7531f656b5c294762c79011c10bea1ef3 (64 Bit)]

FileReference(Object)>>doesNotUnderstand: #referenceTo:
	Receiver: File @ /Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/PharoBooks2/Booklet-Gra[..]
	Arguments and temporary variables: 
		aMessage: 	referenceTo: '/Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Wri[..]
		exception: 	Instance of FileReference did not understand #referenceTo:
		resumeValue: 	nil
	Receiver's instance variables: 
		path: 	Path / 'Users' / 'ducasse' / 'Workspace' / 'FirstCircle' / 'MyBooks' [..]
		filesystem: 	a FileSystem


[ :file |
		               fileSystem referenceTo: file ] in MicReferenceChecker>>checkProject:
	Receiver: a MicReferenceChecker
	Arguments and temporary variables: 
		aFileReference: 	File @ Chapters/bloc/element.md
		mainMic: 	a MicRootBlock
		collector: 	a MicFileCollector
		listOfFiles: 	nil
		file: 	'/Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/PharoBooks2/[..]
	Receiver's instance variables: 
		references: 	an OrderedCollection()
		anchors: 	an OrderedCollection()
		duplicatedAnchors: 	an OrderedCollection()
		results: 	an OrderedCollection()
		fileSystem: 	File @ /Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/[..]


[:each | each ifNotNil: [newSet add: (aBlock value: each enclosedElement)]] in Set>>collect:
	Receiver: a Set('/Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/PharoBooks2/Booklet-Gra[..]
	Arguments and temporary variables: 
		aBlock: 	[ :file |
		               fileSystem referenceTo: file ]
		newSet: 	a Set()
		each: 	'/Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/PharoBooks2/[..]
	Receiver's instance variables: 
		tally: 	1
		array: 	#(nil nil '/Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/P[..]


Array(SequenceableCollection)>>do:
	Receiver: #(nil nil '/Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/PharoBooks2/Booklet[..]
	Arguments and temporary variables: 
		aBlock: 	[:each | each ifNotNil: [newSet add: (aBlock value: each enclosedEl[..]
		index: 	3
	Receiver's instance variables: 
#(nil nil '/Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/PharoBooks2/Booklet[..]

Set>>collect:
	Receiver: a Set('/Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/PharoBooks2/Booklet-Gra[..]
	Arguments and temporary variables: 
		aBlock: 	[ :file |
		               fileSystem referenceTo: file ]
		newSet: 	a Set()
	Receiver's instance variables: 
		tally: 	1
		array: 	#(nil nil '/Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/P[..]


MicReferenceChecker>>checkProject:
	Receiver: a MicReferenceChecker
	Arguments and temporary variables: 
		aFileReference: 	File @ Chapters/bloc/element.md
		mainMic: 	a MicRootBlock
		collector: 	a MicFileCollector
		listOfFiles: 	nil
	Receiver's instance variables: 
		references: 	an OrderedCollection()
		anchors: 	an OrderedCollection()
		duplicatedAnchors: 	an OrderedCollection()
		results: 	an OrderedCollection()
		fileSystem: 	File @ /Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/[..]


ClapMicrodownBookReferenceCheckerCommand>>execute
	Receiver: a ClapMicrodownBookReferenceCheckerCommand
	Arguments and temporary variables: 
		file: 	File @ Chapters/bloc/element.md
		checker: 	a MicReferenceChecker
	Receiver's instance variables: 
		arguments: 	a ClapNamedMatch
		project: 	nil


[ :args |
			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].
			(self with: args) execute ] in ClapMicrodownBookReferenceCheckerCommand class>>commandSpecification
	Receiver: ClapMicrodownBookReferenceCheckerCommand
	Arguments and temporary variables: 
		args: 	a ClapNamedMatch
	Receiver's instance variables: 
		superclass: 	ClapPillarCommand
		methodDict: 	a MethodDictionary(#execute->ClapMicrodownBookReferenceCheckerC[..]
		format: 	65538
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (execution) - 3 selector(s))
		subclasses: 	nil
		name: 	#ClapMicrodownBookReferenceCheckerCommand
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	7464927
		packageTag: 	a PackageTag(Uncategorized)


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :args |
			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].
			(se[..]
	Arguments and temporary variables: 
		anArg: 	a ClapNamedMatch
	Receiver's instance variables: 
		outerContext: 	ClapMicrodownBookReferenceCheckerCommand class>>commandSpecif[..]
		compiledBlock: 	a CompiledBlock: [ :args |
			args at: #helpFlag ifPresent: [..]
		numArgs: 	1
		receiver: 	ClapMicrodownBookReferenceCheckerCommand


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ :args |
			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].
			(se[..]
	Arguments and temporary variables: 
		firstArg: 	a ClapNamedMatch
		secondArg: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bl[..]
	Receiver's instance variables: 
		outerContext: 	ClapMicrodownBookReferenceCheckerCommand class>>commandSpecif[..]
		compiledBlock: 	a CompiledBlock: [ :args |
			args at: #helpFlag ifPresent: [..]
		numArgs: 	1
		receiver: 	ClapMicrodownBookReferenceCheckerCommand


ClapCommand(ClapParameter)>>valueFor:with:
	Receiver: a ClapCommand(referenceCheck)
	Arguments and temporary variables: 
		aMatch: 	a ClapNamedMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/ele[..]
	Receiver's instance variables: 
		identifier: 	#referenceCheck
		canonicalName: 	nil
		description: 	'Check the duplicated or unknown references'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help | help val[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #requestedFile[..]
		positionals: 	an OrderedCollection(a ClapPositional(requestedFile))
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help))
		subcommands: 	an OrderedCollection()


[ super valueFor: aMatch with: arg ] in ClapCommand>>valueFor:with:
	Receiver: a ClapCommand(referenceCheck)
	Arguments and temporary variables: 
		aMatch: 	a ClapNamedMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/ele[..]
	Receiver's instance variables: 
		identifier: 	#referenceCheck
		canonicalName: 	nil
		description: 	'Check the duplicated or unknown references'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help | help val[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #requestedFile[..]
		positionals: 	an OrderedCollection(a ClapPositional(requestedFile))
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help))
		subcommands: 	an OrderedCollection()


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(a ClapWordMatch)
	Arguments and temporary variables: 
		aBlock: 	[ :child | specification subcommands includes: child specification ]
		foundBlock: 	[ :cmdMatch | foundBlock cull: cmdMatch ]
		exceptionBlock: 	[ super valueFor: aMatch with: arg ]
	Receiver's instance variables: 
		array: 	an Array(a ClapWordMatch nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


ClapNamedMatch(ClapCompositeMatch)>>matchedSubcommand:ifNone:
	Receiver: a ClapNamedMatch
	Arguments and temporary variables: 
		foundBlock: 	[ :sub | sub value: arg ]
		noneBlock: 	[ super valueFor: aMatch with: arg ]
	Receiver's instance variables: 
		specification: 	a ClapCommand(referenceCheck)
		parent: 	a ClapCompositeMatch
		startIndex: 	1
		children: 	an OrderedCollection(a ClapWordMatch)
		keyword: 	'referenceCheck'


ClapCommand>>valueFor:with:
	Receiver: a ClapCommand(referenceCheck)
	Arguments and temporary variables: 
		aMatch: 	a ClapNamedMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/ele[..]
	Receiver's instance variables: 
		identifier: 	#referenceCheck
		canonicalName: 	nil
		description: 	'Check the duplicated or unknown references'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help | help val[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #requestedFile[..]
		positionals: 	an OrderedCollection(a ClapPositional(requestedFile))
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help))
		subcommands: 	an OrderedCollection()


ClapNamedMatch(ClapExpression)>>value:
	Receiver: a ClapNamedMatch
	Arguments and temporary variables: 
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/ele[..]
	Receiver's instance variables: 
		specification: 	a ClapCommand(referenceCheck)
		parent: 	a ClapCompositeMatch
		startIndex: 	1
		children: 	an OrderedCollection(a ClapWordMatch)
		keyword: 	'referenceCheck'


[ :sub | sub value: arg ] in ClapRoot(ClapCommand)>>valueFor:with:
	Receiver: a ClapRoot(clap)
	Arguments and temporary variables: 
		aMatch: 	a ClapCompositeMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/ele[..]
		sub: 	a ClapNamedMatch
	Receiver's instance variables: 
		identifier: 	#clap
		canonicalName: 	nil
		description: 	'Entry point for commands implemented with Clap'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help |
				help[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #helpCommand->[..]
		positionals: 	an OrderedCollection()
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help) a ClapFlag(save) a ClapFlag(no[..]
		subcommands: 	an OrderedCollection(a ClapCommand(help) a ClapCommand(image) [..]


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :sub | sub value: arg ]
	Arguments and temporary variables: 
		anArg: 	a ClapNamedMatch
	Receiver's instance variables: 
		outerContext: 	ClapRoot(ClapCommand)>>valueFor:with:
		compiledBlock: 	a CompiledBlock: [ :sub | sub value: arg ]
		numArgs: 	1
		receiver: 	a ClapRoot(clap)


[ :cmdMatch | foundBlock cull: cmdMatch ] in ClapCompositeMatch>>matchedSubcommand:ifNone:
	Receiver: a ClapCompositeMatch
	Arguments and temporary variables: 
		foundBlock: 	[ :sub | sub value: arg ]
		noneBlock: 	[ super valueFor: aMatch with: arg ]
		cmdMatch: 	a ClapNamedMatch
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		parent: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/[..]
		startIndex: 	1
		children: 	an OrderedCollection(a ClapNamedMatch)


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :cmdMatch | foundBlock cull: cmdMatch ]
	Arguments and temporary variables: 
		anArg: 	a ClapNamedMatch
	Receiver's instance variables: 
		outerContext: 	ClapCompositeMatch>>matchedSubcommand:ifNone:
		compiledBlock: 	a CompiledBlock: [ :cmdMatch | foundBlock cull: cmdMatch ]
		numArgs: 	1
		receiver: 	a ClapCompositeMatch


[ :each |
			(aBlock value: each)
				ifTrue: [ ^ foundBlock cull: each ] ] in OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(a ClapNamedMatch)
	Arguments and temporary variables: 
		aBlock: 	[ :child | specification subcommands includes: child specification ]
		foundBlock: 	[ :cmdMatch | foundBlock cull: cmdMatch ]
		exceptionBlock: 	[ super valueFor: aMatch with: arg ]
		each: 	a ClapNamedMatch
	Receiver's instance variables: 
		array: 	an Array(a ClapNamedMatch nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


OrderedCollection>>do:
	Receiver: an OrderedCollection(a ClapNamedMatch)
	Arguments and temporary variables: 
		aBlock: 	[ :each |
			(aBlock value: each)
				ifTrue: [ ^ foundBlock cull: [..]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a ClapNamedMatch nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(a ClapNamedMatch)
	Arguments and temporary variables: 
		aBlock: 	[ :child | specification subcommands includes: child specification ]
		foundBlock: 	[ :cmdMatch | foundBlock cull: cmdMatch ]
		exceptionBlock: 	[ super valueFor: aMatch with: arg ]
	Receiver's instance variables: 
		array: 	an Array(a ClapNamedMatch nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


ClapCompositeMatch>>matchedSubcommand:ifNone:
	Receiver: a ClapCompositeMatch
	Arguments and temporary variables: 
		foundBlock: 	[ :sub | sub value: arg ]
		noneBlock: 	[ super valueFor: aMatch with: arg ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		parent: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/[..]
		startIndex: 	1
		children: 	an OrderedCollection(a ClapNamedMatch)


ClapRoot(ClapCommand)>>valueFor:with:
	Receiver: a ClapRoot(clap)
	Arguments and temporary variables: 
		aMatch: 	a ClapCompositeMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/ele[..]
	Receiver's instance variables: 
		identifier: 	#clap
		canonicalName: 	nil
		description: 	'Entry point for commands implemented with Clap'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help |
				help[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #helpCommand->[..]
		positionals: 	an OrderedCollection()
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help) a ClapFlag(save) a ClapFlag(no[..]
		subcommands: 	an OrderedCollection(a ClapCommand(help) a ClapCommand(image) [..]


ClapCompositeMatch(ClapExpression)>>value:
	Receiver: a ClapCompositeMatch
	Arguments and temporary variables: 
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/ele[..]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		parent: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/[..]
		startIndex: 	1
		children: 	an OrderedCollection(a ClapNamedMatch)


[ :m |
				m value: self.
				self exitSuccess ] in [
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ]
			ifMismatch: [ self noneMatched ]
	] in ClapContext>>executeToExit:
	Receiver: a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/element.md'))
	Arguments and temporary variables: 
		exitBlock: 	[ :exit | self handleExit: exit ]
		m: 	a ClapCompositeMatch
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		arguments: 	an OrderedCollection('referenceCheck' 'Chapters/bloc/element.md')
		obeyingExits: 	true
		stdio: 	Stdio
		match: 	a ClapCompositeMatch
		leftovers: 	an OrderedCollection()
		session: 	a WorkingSession
		exitException: 	nil


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :m |
				m value: self.
				self exitSuccess ]
	Arguments and temporary variables: 
		anArg: 	a ClapCompositeMatch
	Receiver's instance variables: 
		outerContext: 	[
		self rememberSession;
			ifMatch: [ :m |
				m value: sel[..]
		compiledBlock: 	a CompiledBlock: [ :m |
				m value: self.
				self exitSucc[..]
		numArgs: 	1
		receiver: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/blo[..]


ClapCompositeMatch(ClapSubExpression)>>ifMatch:ifMismatch:
	Receiver: a ClapCompositeMatch
	Arguments and temporary variables: 
		matchBlock: 	[ :m |
				m value: self.
				self exitSuccess ]
		mismatchBlock: 	[ self noneMatched ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		parent: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/[..]
		startIndex: 	1
		children: 	an OrderedCollection(a ClapNamedMatch)


ClapContext>>ifMatch:ifMismatch:
	Receiver: a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/element.md'))
	Arguments and temporary variables: 
		matchBlock: 	[ :m |
				m value: self.
				self exitSuccess ]
		failBlock: 	[ self noneMatched ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		arguments: 	an OrderedCollection('referenceCheck' 'Chapters/bloc/element.md')
		obeyingExits: 	true
		stdio: 	Stdio
		match: 	a ClapCompositeMatch
		leftovers: 	an OrderedCollection()
		session: 	a WorkingSession
		exitException: 	nil


[
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ]
			ifMismatch: [ self noneMatched ]
	] in ClapContext>>executeToExit:
	Receiver: a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/element.md'))
	Arguments and temporary variables: 
		exitBlock: 	[ :exit | self handleExit: exit ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		arguments: 	an OrderedCollection('referenceCheck' 'Chapters/bloc/element.md')
		obeyingExits: 	true
		stdio: 	Stdio
		match: 	a ClapCompositeMatch
		leftovers: 	an OrderedCollection()
		session: 	a WorkingSession
		exitException: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ][..]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exception |
			exitException := exception.
			exitBlock v[..]
	Receiver's instance variables: 
		outerContext: 	ClapContext>>executeToExit:
		compiledBlock: 	a CompiledBlock: [
		self rememberSession;
			ifMatch: [ :m [..]
		numArgs: 	0
		receiver: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/blo[..]


ClapContext>>executeToExit:
	Receiver: a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/element.md'))
	Arguments and temporary variables: 
		exitBlock: 	[ :exit | self handleExit: exit ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		arguments: 	an OrderedCollection('referenceCheck' 'Chapters/bloc/element.md')
		obeyingExits: 	true
		stdio: 	Stdio
		match: 	a ClapCompositeMatch
		leftovers: 	an OrderedCollection()
		session: 	a WorkingSession
		exitException: 	nil


[
		ClapContext withPragmaCommands
			beObeyingExits;
			setStdio: Stdio;
			arguments: self arguments;
			executeToExit: [ :exit | self handleExit: exit ]
	] in ClapCommandLineHandler>>activate
	Receiver: a ClapCommandLineHandler
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
	Receiver: [
		ClapContext withPragmaCommands
			beObeyingExits;
			setStdio: Stdio;
			arguments[..]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		outerContext: 	ClapCommandLineHandler>>activate
		compiledBlock: 	a CompiledBlock: [
		ClapContext withPragmaCommands
			beObe[..]
		numArgs: 	0
		receiver: 	a ClapCommandLineHandler



--- The full stack ---
FileReference(Object)>>doesNotUnderstand: #referenceTo:
[ :file |
		               fileSystem referenceTo: file ] in MicReferenceChecker>>checkProject:
[:each | each ifNotNil: [newSet add: (aBlock value: each enclosedElement)]] in Set>>collect:
Array(SequenceableCollection)>>do:
Set>>collect:
MicReferenceChecker>>checkProject:
ClapMicrodownBookReferenceCheckerCommand>>execute
[ :args |
			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].
			(self with: args) execute ] in ClapMicrodownBookReferenceCheckerCommand class>>commandSpecification
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
ClapCommand(ClapParameter)>>valueFor:with:
[ super valueFor: aMatch with: arg ] in ClapCommand>>valueFor:with:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
ClapNamedMatch(ClapCompositeMatch)>>matchedSubcommand:ifNone:
ClapCommand>>valueFor:with:
ClapNamedMatch(ClapExpression)>>value:
[ :sub | sub value: arg ] in ClapRoot(ClapCommand)>>valueFor:with:
FullBlockClosure(BlockClosure)>>cull:
[ :cmdMatch | foundBlock cull: cmdMatch ] in ClapCompositeMatch>>matchedSubcommand:ifNone:
FullBlockClosure(BlockClosure)>>cull:
[ :each |
			(aBlock value: each)
				ifTrue: [ ^ foundBlock cull: each ] ] in OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
ClapCompositeMatch>>matchedSubcommand:ifNone:
ClapRoot(ClapCommand)>>valueFor:with:
ClapCompositeMatch(ClapExpression)>>value:
[ :m |
				m value: self.
				self exitSuccess ] in [
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ]
			ifMismatch: [ self noneMatched ]
	] in ClapContext>>executeToExit:
FullBlockClosure(BlockClosure)>>cull:
ClapCompositeMatch(ClapSubExpression)>>ifMatch:ifMismatch:
ClapContext>>ifMatch:ifMismatch:
[
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ]
			ifMismatch: [ self noneMatched ]
	] in ClapContext>>executeToExit:
FullBlockClosure(BlockClosure)>>on:do:
ClapContext>>executeToExit:
[
		ClapContext withPragmaCommands
			beObeyingExits;
			setStdio: Stdio;
			arguments: self arguments;
			executeToExit: [ :exit | self handleExit: exit ]
	] in ClapCommandLineHandler>>activate
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Message not understood: FileReference >> #referenceTo:
9 August 2024 4:20:18.892796 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 74b785ff-50d8-0d00-86f4-c64e0df24b96 Jun 28 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 74b785ff-50d8-0d00-86f4-c64e0df24b96 Jun 28 2024
v10.3.0 - Commit: ce151716 - Date: 2024-06-28 10:12:41 +0200

Image: Pharo12.0.0SNAPSHOT [Build information: Pharo-12.0.0+SNAPSHOT.build.1526.sha.404d3af7531f656b5c294762c79011c10bea1ef3 (64 Bit)]

FileReference(Object)>>doesNotUnderstand: #referenceTo:
	Receiver: File @ /Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/PharoBooks2/Booklet-Gra[..]
	Arguments and temporary variables: 
		aMessage: 	referenceTo: '/Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Wri[..]
		exception: 	Instance of FileReference did not understand #referenceTo:
		resumeValue: 	nil
	Receiver's instance variables: 
		path: 	Path / 'Users' / 'ducasse' / 'Workspace' / 'FirstCircle' / 'MyBooks' [..]
		filesystem: 	a FileSystem


[ :file |
		               fileSystem referenceTo: file ] in MicReferenceChecker>>checkProject:
	Receiver: a MicReferenceChecker
	Arguments and temporary variables: 
		aFileReference: 	File @ Chapters/bloc/element.md
		mainMic: 	a MicRootBlock
		collector: 	a MicFileCollector
		listOfFiles: 	nil
		file: 	'/Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/PharoBooks2/[..]
	Receiver's instance variables: 
		references: 	an OrderedCollection()
		anchors: 	an OrderedCollection()
		duplicatedAnchors: 	an OrderedCollection()
		results: 	an OrderedCollection()
		fileSystem: 	File @ /Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/[..]


[:each | each ifNotNil: [newSet add: (aBlock value: each enclosedElement)]] in Set>>collect:
	Receiver: a Set('/Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/PharoBooks2/Booklet-Gra[..]
	Arguments and temporary variables: 
		aBlock: 	[ :file |
		               fileSystem referenceTo: file ]
		newSet: 	a Set()
		each: 	'/Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/PharoBooks2/[..]
	Receiver's instance variables: 
		tally: 	1
		array: 	#(nil nil '/Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/P[..]


Array(SequenceableCollection)>>do:
	Receiver: #(nil nil '/Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/PharoBooks2/Booklet[..]
	Arguments and temporary variables: 
		aBlock: 	[:each | each ifNotNil: [newSet add: (aBlock value: each enclosedEl[..]
		index: 	3
	Receiver's instance variables: 
#(nil nil '/Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/PharoBooks2/Booklet[..]

Set>>collect:
	Receiver: a Set('/Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/PharoBooks2/Booklet-Gra[..]
	Arguments and temporary variables: 
		aBlock: 	[ :file |
		               fileSystem referenceTo: file ]
		newSet: 	a Set()
	Receiver's instance variables: 
		tally: 	1
		array: 	#(nil nil '/Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/P[..]


MicReferenceChecker>>checkProject:
	Receiver: a MicReferenceChecker
	Arguments and temporary variables: 
		aFileReference: 	File @ Chapters/bloc/element.md
		mainMic: 	a MicRootBlock
		collector: 	a MicFileCollector
		listOfFiles: 	nil
	Receiver's instance variables: 
		references: 	an OrderedCollection()
		anchors: 	an OrderedCollection()
		duplicatedAnchors: 	an OrderedCollection()
		results: 	an OrderedCollection()
		fileSystem: 	File @ /Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/[..]


ClapMicrodownBookReferenceCheckerCommand>>execute
	Receiver: a ClapMicrodownBookReferenceCheckerCommand
	Arguments and temporary variables: 
		file: 	File @ Chapters/bloc/element.md
		checker: 	a MicReferenceChecker
	Receiver's instance variables: 
		arguments: 	a ClapNamedMatch
		project: 	nil


[ :args |
			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].
			(self with: args) execute ] in ClapMicrodownBookReferenceCheckerCommand class>>commandSpecification
	Receiver: ClapMicrodownBookReferenceCheckerCommand
	Arguments and temporary variables: 
		args: 	a ClapNamedMatch
	Receiver's instance variables: 
		superclass: 	ClapPillarCommand
		methodDict: 	a MethodDictionary(#execute->ClapMicrodownBookReferenceCheckerC[..]
		format: 	65538
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (execution) - 3 selector(s))
		subclasses: 	nil
		name: 	#ClapMicrodownBookReferenceCheckerCommand
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	7464927
		packageTag: 	a PackageTag(Uncategorized)


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :args |
			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].
			(se[..]
	Arguments and temporary variables: 
		anArg: 	a ClapNamedMatch
	Receiver's instance variables: 
		outerContext: 	ClapMicrodownBookReferenceCheckerCommand class>>commandSpecif[..]
		compiledBlock: 	a CompiledBlock: [ :args |
			args at: #helpFlag ifPresent: [..]
		numArgs: 	1
		receiver: 	ClapMicrodownBookReferenceCheckerCommand


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ :args |
			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].
			(se[..]
	Arguments and temporary variables: 
		firstArg: 	a ClapNamedMatch
		secondArg: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bl[..]
	Receiver's instance variables: 
		outerContext: 	ClapMicrodownBookReferenceCheckerCommand class>>commandSpecif[..]
		compiledBlock: 	a CompiledBlock: [ :args |
			args at: #helpFlag ifPresent: [..]
		numArgs: 	1
		receiver: 	ClapMicrodownBookReferenceCheckerCommand


ClapCommand(ClapParameter)>>valueFor:with:
	Receiver: a ClapCommand(referenceCheck)
	Arguments and temporary variables: 
		aMatch: 	a ClapNamedMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/ele[..]
	Receiver's instance variables: 
		identifier: 	#referenceCheck
		canonicalName: 	nil
		description: 	'Check the duplicated or unknown references'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help | help val[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #requestedFile[..]
		positionals: 	an OrderedCollection(a ClapPositional(requestedFile))
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help))
		subcommands: 	an OrderedCollection()


[ super valueFor: aMatch with: arg ] in ClapCommand>>valueFor:with:
	Receiver: a ClapCommand(referenceCheck)
	Arguments and temporary variables: 
		aMatch: 	a ClapNamedMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/ele[..]
	Receiver's instance variables: 
		identifier: 	#referenceCheck
		canonicalName: 	nil
		description: 	'Check the duplicated or unknown references'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help | help val[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #requestedFile[..]
		positionals: 	an OrderedCollection(a ClapPositional(requestedFile))
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help))
		subcommands: 	an OrderedCollection()


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(a ClapWordMatch)
	Arguments and temporary variables: 
		aBlock: 	[ :child | specification subcommands includes: child specification ]
		foundBlock: 	[ :cmdMatch | foundBlock cull: cmdMatch ]
		exceptionBlock: 	[ super valueFor: aMatch with: arg ]
	Receiver's instance variables: 
		array: 	an Array(a ClapWordMatch nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


ClapNamedMatch(ClapCompositeMatch)>>matchedSubcommand:ifNone:
	Receiver: a ClapNamedMatch
	Arguments and temporary variables: 
		foundBlock: 	[ :sub | sub value: arg ]
		noneBlock: 	[ super valueFor: aMatch with: arg ]
	Receiver's instance variables: 
		specification: 	a ClapCommand(referenceCheck)
		parent: 	a ClapCompositeMatch
		startIndex: 	1
		children: 	an OrderedCollection(a ClapWordMatch)
		keyword: 	'referenceCheck'


ClapCommand>>valueFor:with:
	Receiver: a ClapCommand(referenceCheck)
	Arguments and temporary variables: 
		aMatch: 	a ClapNamedMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/ele[..]
	Receiver's instance variables: 
		identifier: 	#referenceCheck
		canonicalName: 	nil
		description: 	'Check the duplicated or unknown references'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help | help val[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #requestedFile[..]
		positionals: 	an OrderedCollection(a ClapPositional(requestedFile))
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help))
		subcommands: 	an OrderedCollection()


ClapNamedMatch(ClapExpression)>>value:
	Receiver: a ClapNamedMatch
	Arguments and temporary variables: 
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/ele[..]
	Receiver's instance variables: 
		specification: 	a ClapCommand(referenceCheck)
		parent: 	a ClapCompositeMatch
		startIndex: 	1
		children: 	an OrderedCollection(a ClapWordMatch)
		keyword: 	'referenceCheck'


[ :sub | sub value: arg ] in ClapRoot(ClapCommand)>>valueFor:with:
	Receiver: a ClapRoot(clap)
	Arguments and temporary variables: 
		aMatch: 	a ClapCompositeMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/ele[..]
		sub: 	a ClapNamedMatch
	Receiver's instance variables: 
		identifier: 	#clap
		canonicalName: 	nil
		description: 	'Entry point for commands implemented with Clap'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help |
				help[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #helpCommand->[..]
		positionals: 	an OrderedCollection()
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help) a ClapFlag(save) a ClapFlag(no[..]
		subcommands: 	an OrderedCollection(a ClapCommand(help) a ClapCommand(image) [..]


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :sub | sub value: arg ]
	Arguments and temporary variables: 
		anArg: 	a ClapNamedMatch
	Receiver's instance variables: 
		outerContext: 	ClapRoot(ClapCommand)>>valueFor:with:
		compiledBlock: 	a CompiledBlock: [ :sub | sub value: arg ]
		numArgs: 	1
		receiver: 	a ClapRoot(clap)


[ :cmdMatch | foundBlock cull: cmdMatch ] in ClapCompositeMatch>>matchedSubcommand:ifNone:
	Receiver: a ClapCompositeMatch
	Arguments and temporary variables: 
		foundBlock: 	[ :sub | sub value: arg ]
		noneBlock: 	[ super valueFor: aMatch with: arg ]
		cmdMatch: 	a ClapNamedMatch
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		parent: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/[..]
		startIndex: 	1
		children: 	an OrderedCollection(a ClapNamedMatch)


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :cmdMatch | foundBlock cull: cmdMatch ]
	Arguments and temporary variables: 
		anArg: 	a ClapNamedMatch
	Receiver's instance variables: 
		outerContext: 	ClapCompositeMatch>>matchedSubcommand:ifNone:
		compiledBlock: 	a CompiledBlock: [ :cmdMatch | foundBlock cull: cmdMatch ]
		numArgs: 	1
		receiver: 	a ClapCompositeMatch


[ :each |
			(aBlock value: each)
				ifTrue: [ ^ foundBlock cull: each ] ] in OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(a ClapNamedMatch)
	Arguments and temporary variables: 
		aBlock: 	[ :child | specification subcommands includes: child specification ]
		foundBlock: 	[ :cmdMatch | foundBlock cull: cmdMatch ]
		exceptionBlock: 	[ super valueFor: aMatch with: arg ]
		each: 	a ClapNamedMatch
	Receiver's instance variables: 
		array: 	an Array(a ClapNamedMatch nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


OrderedCollection>>do:
	Receiver: an OrderedCollection(a ClapNamedMatch)
	Arguments and temporary variables: 
		aBlock: 	[ :each |
			(aBlock value: each)
				ifTrue: [ ^ foundBlock cull: [..]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a ClapNamedMatch nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(a ClapNamedMatch)
	Arguments and temporary variables: 
		aBlock: 	[ :child | specification subcommands includes: child specification ]
		foundBlock: 	[ :cmdMatch | foundBlock cull: cmdMatch ]
		exceptionBlock: 	[ super valueFor: aMatch with: arg ]
	Receiver's instance variables: 
		array: 	an Array(a ClapNamedMatch nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


ClapCompositeMatch>>matchedSubcommand:ifNone:
	Receiver: a ClapCompositeMatch
	Arguments and temporary variables: 
		foundBlock: 	[ :sub | sub value: arg ]
		noneBlock: 	[ super valueFor: aMatch with: arg ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		parent: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/[..]
		startIndex: 	1
		children: 	an OrderedCollection(a ClapNamedMatch)


ClapRoot(ClapCommand)>>valueFor:with:
	Receiver: a ClapRoot(clap)
	Arguments and temporary variables: 
		aMatch: 	a ClapCompositeMatch
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/ele[..]
	Receiver's instance variables: 
		identifier: 	#clap
		canonicalName: 	nil
		description: 	'Entry point for commands implemented with Clap'
		multiple: 	false
		meaningBlock: 	[ :args |
			args at: #helpFlag ifPresent: [ :help |
				help[..]
		validationBlock: 	nil
		implicitMeaningBlock: 	[ :match | match ]
		parameters: 	an OrderedDictionary(#helpFlag->a ClapFlag(help) #helpCommand->[..]
		positionals: 	an OrderedCollection()
		aliases: 	#()
		flags: 	an OrderedCollection(a ClapFlag(help) a ClapFlag(save) a ClapFlag(no[..]
		subcommands: 	an OrderedCollection(a ClapCommand(help) a ClapCommand(image) [..]


ClapCompositeMatch(ClapExpression)>>value:
	Receiver: a ClapCompositeMatch
	Arguments and temporary variables: 
		arg: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/ele[..]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		parent: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/[..]
		startIndex: 	1
		children: 	an OrderedCollection(a ClapNamedMatch)


[ :m |
				m value: self.
				self exitSuccess ] in [
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ]
			ifMismatch: [ self noneMatched ]
	] in ClapContext>>executeToExit:
	Receiver: a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/element.md'))
	Arguments and temporary variables: 
		exitBlock: 	[ :exit | self handleExit: exit ]
		m: 	a ClapCompositeMatch
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		arguments: 	an OrderedCollection('referenceCheck' 'Chapters/bloc/element.md')
		obeyingExits: 	true
		stdio: 	Stdio
		match: 	a ClapCompositeMatch
		leftovers: 	an OrderedCollection()
		session: 	a WorkingSession
		exitException: 	nil


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :m |
				m value: self.
				self exitSuccess ]
	Arguments and temporary variables: 
		anArg: 	a ClapCompositeMatch
	Receiver's instance variables: 
		outerContext: 	[
		self rememberSession;
			ifMatch: [ :m |
				m value: sel[..]
		compiledBlock: 	a CompiledBlock: [ :m |
				m value: self.
				self exitSucc[..]
		numArgs: 	1
		receiver: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/blo[..]


ClapCompositeMatch(ClapSubExpression)>>ifMatch:ifMismatch:
	Receiver: a ClapCompositeMatch
	Arguments and temporary variables: 
		matchBlock: 	[ :m |
				m value: self.
				self exitSuccess ]
		mismatchBlock: 	[ self noneMatched ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		parent: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/[..]
		startIndex: 	1
		children: 	an OrderedCollection(a ClapNamedMatch)


ClapContext>>ifMatch:ifMismatch:
	Receiver: a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/element.md'))
	Arguments and temporary variables: 
		matchBlock: 	[ :m |
				m value: self.
				self exitSuccess ]
		failBlock: 	[ self noneMatched ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		arguments: 	an OrderedCollection('referenceCheck' 'Chapters/bloc/element.md')
		obeyingExits: 	true
		stdio: 	Stdio
		match: 	a ClapCompositeMatch
		leftovers: 	an OrderedCollection()
		session: 	a WorkingSession
		exitException: 	nil


[
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ]
			ifMismatch: [ self noneMatched ]
	] in ClapContext>>executeToExit:
	Receiver: a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/element.md'))
	Arguments and temporary variables: 
		exitBlock: 	[ :exit | self handleExit: exit ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		arguments: 	an OrderedCollection('referenceCheck' 'Chapters/bloc/element.md')
		obeyingExits: 	true
		stdio: 	Stdio
		match: 	a ClapCompositeMatch
		leftovers: 	an OrderedCollection()
		session: 	a WorkingSession
		exitException: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ][..]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exception |
			exitException := exception.
			exitBlock v[..]
	Receiver's instance variables: 
		outerContext: 	ClapContext>>executeToExit:
		compiledBlock: 	a CompiledBlock: [
		self rememberSession;
			ifMatch: [ :m [..]
		numArgs: 	0
		receiver: 	a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/blo[..]


ClapContext>>executeToExit:
	Receiver: a ClapContext(an OrderedCollection('referenceCheck' 'Chapters/bloc/element.md'))
	Arguments and temporary variables: 
		exitBlock: 	[ :exit | self handleExit: exit ]
	Receiver's instance variables: 
		specification: 	a ClapRoot(clap)
		arguments: 	an OrderedCollection('referenceCheck' 'Chapters/bloc/element.md')
		obeyingExits: 	true
		stdio: 	Stdio
		match: 	a ClapCompositeMatch
		leftovers: 	an OrderedCollection()
		session: 	a WorkingSession
		exitException: 	nil


[
		ClapContext withPragmaCommands
			beObeyingExits;
			setStdio: Stdio;
			arguments: self arguments;
			executeToExit: [ :exit | self handleExit: exit ]
	] in ClapCommandLineHandler>>activate
	Receiver: a ClapCommandLineHandler
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
	Receiver: [
		ClapContext withPragmaCommands
			beObeyingExits;
			setStdio: Stdio;
			arguments[..]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		outerContext: 	ClapCommandLineHandler>>activate
		compiledBlock: 	a CompiledBlock: [
		ClapContext withPragmaCommands
			beObe[..]
		numArgs: 	0
		receiver: 	a ClapCommandLineHandler



--- The full stack ---
FileReference(Object)>>doesNotUnderstand: #referenceTo:
[ :file |
		               fileSystem referenceTo: file ] in MicReferenceChecker>>checkProject:
[:each | each ifNotNil: [newSet add: (aBlock value: each enclosedElement)]] in Set>>collect:
Array(SequenceableCollection)>>do:
Set>>collect:
MicReferenceChecker>>checkProject:
ClapMicrodownBookReferenceCheckerCommand>>execute
[ :args |
			args at: #helpFlag ifPresent: [ :help | help value; exitSuccess ].
			(self with: args) execute ] in ClapMicrodownBookReferenceCheckerCommand class>>commandSpecification
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
ClapCommand(ClapParameter)>>valueFor:with:
[ super valueFor: aMatch with: arg ] in ClapCommand>>valueFor:with:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
ClapNamedMatch(ClapCompositeMatch)>>matchedSubcommand:ifNone:
ClapCommand>>valueFor:with:
ClapNamedMatch(ClapExpression)>>value:
[ :sub | sub value: arg ] in ClapRoot(ClapCommand)>>valueFor:with:
FullBlockClosure(BlockClosure)>>cull:
[ :cmdMatch | foundBlock cull: cmdMatch ] in ClapCompositeMatch>>matchedSubcommand:ifNone:
FullBlockClosure(BlockClosure)>>cull:
[ :each |
			(aBlock value: each)
				ifTrue: [ ^ foundBlock cull: each ] ] in OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
ClapCompositeMatch>>matchedSubcommand:ifNone:
ClapRoot(ClapCommand)>>valueFor:with:
ClapCompositeMatch(ClapExpression)>>value:
[ :m |
				m value: self.
				self exitSuccess ] in [
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ]
			ifMismatch: [ self noneMatched ]
	] in ClapContext>>executeToExit:
FullBlockClosure(BlockClosure)>>cull:
ClapCompositeMatch(ClapSubExpression)>>ifMatch:ifMismatch:
ClapContext>>ifMatch:ifMismatch:
[
		self rememberSession;
			ifMatch: [ :m |
				m value: self.
				self exitSuccess ]
			ifMismatch: [ self noneMatched ]
	] in ClapContext>>executeToExit:
FullBlockClosure(BlockClosure)>>on:do:
ClapContext>>executeToExit:
[
		ClapContext withPragmaCommands
			beObeyingExits;
			setStdio: Stdio;
			arguments: self arguments;
			executeToExit: [ :exit | self handleExit: exit ]
	] in ClapCommandLineHandler>>activate
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

